<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Flying in the ocean of knowledge</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xuchunfa.cn/"/>
  <updated>2019-06-27T11:30:11.698Z</updated>
  <id>http://www.xuchunfa.cn/</id>
  
  <author>
    <name>Xu chunfa</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试总结-Java并发编程2</title>
    <link href="http://www.xuchunfa.cn/2019/06/27/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B2/"/>
    <id>http://www.xuchunfa.cn/2019/06/27/面试总结-Java并发编程2/</id>
    <published>2019-06-27T11:27:30.000Z</published>
    <updated>2019-06-27T11:30:11.698Z</updated>
    
    <content type="html"><![CDATA[<ol><li>volatile作用，指令重排相关？    </li></ol><p>参考：</p><p><a href="http://www.xuchunfa.cn/2018/07/24/volatile%E8%AF%AD%E4%B9%89%E5%92%8Cfinal%E8%AF%AD%E4%B9%89%E7%9A%84%E7%90%86%E8%A7%A3/">volatile理解</a></p><p><a href="https://www.itcodemonkey.com/article/1725.html" target="_blank" rel="noopener">小灰漫画volatile</a></p><pre><code>1.volatile变量在线程之间具有可见性；基于CPU的内存屏障实现的。2.volatile变量禁止指令重排；3.每个volatile写操作前插入StoreStore屏障，写操作之后插入StoreLoad屏障；4.每个volatile读操作前插入LoadLoad屏障，读操作之后插入LoadStore屏障；</code></pre><p>2.java内存模型？</p><p><img src="/images/内存模型.png" alt=""></p><pre><code>1.JMM是一种规范，用于决解由于多线程通过共享内存（主存）进行通信时，存在本地内存数据不一致，编译器对代码指令重排等带来的问题。2.java并发编程中保证原子性、可见性和有序性的方法：    原子性：synchronized保证方法和代码块内的操作是原子性的。    可见性：synchronized、volatile和final关键字；    有序性：synchronized关键字；3.happens-before原则（8个）：    3.1 程序次序规则：单线程内顺序发生；    3.2 锁定规则：unlock操作先于对同一个锁的lock操作；    3.3 volatile规则：对volatile变量的写操作先于读操作；    3.4 传递规则:A先于B，B先于C，则A先于C；    3.5 线程启动规则：Thread对象的start()先于该线程的每一个动作；    3.6 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；    3.7 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；    3.8 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；</code></pre><p>16.为什么ReentrantLock的锁粒度小，synchronized不是也可以用方法块来降低锁粒度?</p><p>17.公平锁和非公平锁的定义，及其优缺点，ReentrantLock和synchronized使用公平还是非公平锁?</p><p>19.简述线程池原理，FixedThreadPool用的阻塞队列是什么?</p><p>20.简述AQS，及其核心组件，哪些地方用到AQS，用到什么设计模式？</p><p>21.volatile关键字，他是如何保证可见性，有序性?</p><p>22.Java内存模型的可见性，原子性，有序性，用什么方法来分别保证这些特性?</p><p>23.CAS操作，及其可能带来问题和可以怎么解决？</p><p>24.run和start方法区别或联系？</p><p>25.如何让几个线程按顺序先后执行？</p><p>26.ReadWriteLock读写之间互斥吗？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;volatile作用，指令重排相关？    &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.xuchunfa.cn/2018/07/24/volatile%E8%AF%AD%E4%B9%89%E5%92%8Cfinal
      
    
    </summary>
    
      <category term="面试总结" scheme="http://www.xuchunfa.cn/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
      <category term="Java并发编程" scheme="http://www.xuchunfa.cn/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Socket详解</title>
    <link href="http://www.xuchunfa.cn/2019/06/20/Socket%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.xuchunfa.cn/2019/06/20/Socket详解/</id>
    <published>2019-06-20T11:44:54.000Z</published>
    <updated>2019-06-20T12:44:13.423Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/socket.JPG" alt=""></p><p>Socket服务端：</p><pre><code>public class Server {    private ServerSocket serverSocket = null;    private Socket socket = null;    private DataInputStream input = null;    public Server(int port) {        try {            //绑定端口            serverSocket = new ServerSocket(port);            //获取客户端连接请求            socket = serverSocket.accept();            input = new DataInputStream(new BufferedInputStream(socket.getInputStream()));            String line = &quot;&quot;;            while (!line.equals(&quot;exit&quot;)){                //客户端通过writeUTF()写入数据                line = input.readUTF();                System.out.println(&quot;Server read: &quot;+line);            }            System.out.println(&quot;socket closed.....&quot;);            input.close();            socket.close();        } catch (IOException e) {            e.printStackTrace();        }    }    public static void main(String[] args){        Server server = new Server(6000);    }}</code></pre><p>Client客户端：</p><pre><code>public class Client {    private Socket socket = null;    private DataOutputStream out = null;    private BufferedReader input = null;    public Client(String host,int port) {        try {            //与服务器建立连接            socket = new Socket(host,port);            input = new BufferedReader(new InputStreamReader(System.in));            out = new DataOutputStream(socket.getOutputStream());            String line = &quot;&quot;;            while (!line.equals(&quot;exit&quot;)){                line = input.readLine();                System.out.println(&quot;Client write: &quot;+ line);                out.writeUTF(line);            }        } catch (IOException e) {            e.printStackTrace();        } finally {             try {                    out.close();                    input.close();                    socket.close();                  } catch (Exception e) {                         e.printStackTrace();                  }        }    }    public static void main(String[] args){        Client client = new Client(&quot;localhost&quot;,6000);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/socket.JPG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Socket服务端：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Server {
    private ServerSocket serverSocket = null
      
    
    </summary>
    
      <category term="面试总结" scheme="http://www.xuchunfa.cn/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
      <category term="计算机网络" scheme="http://www.xuchunfa.cn/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>基于Redis的分布式锁</title>
    <link href="http://www.xuchunfa.cn/2019/06/18/%E5%9F%BA%E4%BA%8ERedis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://www.xuchunfa.cn/2019/06/18/基于Redis的分布式锁/</id>
    <published>2019-06-18T06:36:47.000Z</published>
    <updated>2019-06-24T12:06:16.038Z</updated>
    
    <content type="html"><![CDATA[<p><strong>分布式锁的实现方式？</strong></p><pre><code>1.Memcached分布式锁2.Redis分布式锁3.Zookeeper分布式锁4.Chubby</code></pre><p><strong>基于Redis分布式锁的实现方式？</strong></p><p><a href="https://juejin.im/post/5b16148a518825136137c8db" target="_blank" rel="noopener">小灰详解</a></p><p>使用setnx + expire指令</p><pre><code>问题1：    1.setnx指令和expire指令之间的操作是非原子性的，在执行完setnx指令之后，expire指令之前，如果宕机将会产生死锁；解决办法：    使用set命令将setnx和expire命令合并成一个命令；    例如:jedis.set(key,value,&quot;NX&quot;,&quot;EX&quot;,seconds);成功则返回OK;问题2：    1.可能会发生del(key)的误删，假如线程1在还未执行完代码时，锁就已经过期释放锁了，线程2获取到锁开始执行，      执行中线程1执行完开始del(key),此时如果不加处理的话会释放掉线程2的锁；解决办法：    实现LUA脚本比较: 释放锁的线程Id和此时占有锁的线程Id是否相等;问题3：即在问题2中出现了同一时间两个线程访问代码块的情况；解决办法：    让获取到锁的线程开启一个守护线程，当锁要过期但代码还没执行完的时候，守护线程将会延长锁过期的时间，执行完任务后关闭守护线程；</code></pre><p><strong>分布式锁的标准格式？</strong></p><pre><code>boolean isLocked = jedisPoolManager.tryLock(key,seconds)//获取锁if(!isLocked){    return;}try{    //业务逻辑}catch{    //异常处理}finally{    jedisPoolManager.del(key)}</code></pre><p><strong>Bitmap算法？</strong></p><p><img src="/images/bitmap.JPG" alt=""></p><p><a href="https://juejin.im/post/5c4fd2af51882525da267385" target="_blank" rel="noopener">小灰讲解BitMap</a></p><pre><code>Bitmap就是用一个bit位来映射某个元素的value值，key是该元素值；应用：(内存有限)1.40亿个不重复的整数，未排序，给出一个数，快速判断是否存在该群数字中？2.对10亿个不重复的整数进行排序？3.10亿个数字中查找/去除重复的数字？</code></pre><p>思路：</p><pre><code>//N为数据个数bit.length = N/32 + 1;//设置数字bit[]中为1int row = num &gt;&gt; 5bit[row] |= 1 &lt;&lt; (num &amp; 0x1F)//查找数字是否存在，不存在bit置为1，存在则bit保持不变实现去重int row = num &gt;&gt; 5bit[row] &amp; 1 &lt;&lt; (num &amp; 0x1F)//排序for(int i = 0;i &lt; N;i++)    if(isExist(i))        system.out.print(i)</code></pre><p><strong>布隆过滤器？</strong></p><pre><code>用来告诉你某样东西一定不存在或者可能存在；仅仅存储指纹空间(l/n)1.k个hash函数计算出来的hash值，取模位数组，对应下标的值有一个为0，元素不存在；2.如果全为1，可能存在，这些值可能是其他key带来的；</code></pre><p>优点：</p><pre><code>占用空间小，查询效率越高；</code></pre><p>缺点：</p><pre><code>存在误判，删除困难；</code></pre><p>1.基本用法：</p><pre><code>不怎么精确的set结构。bf.add : 添加元素；bf.exist : 查询元素是否存在；</code></pre><p>2.应用场景</p><pre><code>爬虫系统中URL的去重、去除数据库中不存在row的请求来降低数据库磁盘IO请求数量、垃圾邮件的过滤功能、缓存穿透；</code></pre><p>3.基本原理</p><p><img src="/images/bloom.JPG" alt=""></p><p>参数的计算方式;</p><p><img src="/images/bloom1.JPG" alt=""></p><p>其中的参数：</p><pre><code>l : 位数组的长度；n : 添加的元素个数；k : Hash函数的个数；f : 错误率；</code></pre><p><strong>缓存问题？</strong></p><p>1.缓存穿透</p><pre><code>1.1 什么是缓存穿透？    指查询一个一定不存在的数据，后果是直接访问数据库，恶意攻击将使数据库瘫痪；1.2 解决办法？    1.缓存空对象        返回key的null对象到缓存，并设置过期时间。        存在问题：        1.1 key的数量太多影响缓存内存空间，        1.2 设置过期时间会导致Cache层和Storage层数据短期不一致；            例如：Cache层保存了某个key为null之后，Storage层新增了这个key,但是从缓存得到的还是null;    2.Bloom过滤器         将所有可能存在的key放在一个足够大的bitmap中，不存在的key将会被拦截；</code></pre><p>2.缓存雪崩</p><pre><code>2.1 什么是缓存雪崩？    指所有key的缓存时间相同，在同一时间失效，或者缓存服务器宕机，导致所有请求同时访问数据库，从而使系统崩溃；2.2 解决办法？    1.交错失效时间。进行缓存失效时间设置时，在某个基础时间值上加上两秒内的随机数；    2.增加互斥锁。集群环境下使用分布式锁(setnx + expire)，对于每个key，让一个线程构建缓存，其他线程等待，    之后重新从缓存中获取数据；    3.提高缓存的HA。</code></pre><p>3.缓存击穿</p><pre><code>3.1 什么是缓存击穿？    缓存雪崩的一个特例，缓存雪崩是对于全部数据，而缓存击穿是针对热点数据。3.2 解决办法？    1.对于热点数据进行二级缓存，并对于不同级别的缓存设置不同的失效时间。    2.本地缓存（集群不可用时） + 限流（限制请求量）</code></pre><p>4.热点数据集中失效</p><pre><code>4.1 解决办法？    1.设置不同失效时间；    2.互斥锁；</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;分布式锁的实现方式？&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.Memcached分布式锁

2.Redis分布式锁

3.Zookeeper分布式锁

4.Chubby
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;基于Redis分布式锁的实现
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.xuchunfa.cn/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>命令模式</title>
    <link href="http://www.xuchunfa.cn/2019/05/27/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuchunfa.cn/2019/05/27/命令模式/</id>
    <published>2019-05-27T10:19:10.000Z</published>
    <updated>2019-05-29T02:10:13.819Z</updated>
    
    <content type="html"><![CDATA[<p>UML图：</p><p><img src="/images/command.PNG" alt=""></p><p>Command角色：</p><pre><code>public abstract class Command {    protected Receiver receiver;    public Command(Receiver receiver) {        this.receiver = receiver;    }    public void setReceiver(Receiver receiver) {        this.receiver = receiver;    }    abstract void execute();}</code></pre><p>ConcreteCommand角色：</p><pre><code>public class ConcreteCommand extends Command {    public ConcreteCommand(Receiver receiver) {        super(receiver);    }    @Override    public void execute() {        receiver.action();    }}</code></pre><p>Receiver角色：</p><pre><code>public interface Receiver {    void action();}</code></pre><p>ConcreteReceiver角色：</p><pre><code>public class ConcreteReceiver implements Receiver {    @Override    public void action() {        System.out.println(&quot;executing one kind command&quot;);    }}</code></pre><p>Invoker角色：封装命令请求</p><pre><code>public class Invoker {    private Command command;    public Invoker(Command command) {        this.command = command;    }    public void setCommand(Command command) {        this.command = command;    }    public void call(){        command.execute();    }}</code></pre><p>Client角色：</p><pre><code>public static void main(String[] args){    Receiver receiver = new ConcreteReceiver();    Command command = new ConcreteCommand(receiver);    //command.execute();    Invoker invoker = new Invoker(command);    invoker.call();}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;UML图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/command.PNG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Command角色：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public abstract class Command {
    protected Receiv
      
    
    </summary>
    
      <category term="Java设计模式" scheme="http://www.xuchunfa.cn/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>中介者模式</title>
    <link href="http://www.xuchunfa.cn/2019/05/27/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuchunfa.cn/2019/05/27/中介者模式/</id>
    <published>2019-05-27T06:56:22.000Z</published>
    <updated>2019-05-29T02:12:35.210Z</updated>
    
    <content type="html"><![CDATA[<p>UML图：</p><p><img src="/images/mediator.PNG" alt=""></p><p><strong>中介者模式</strong></p><pre><code> 使用一个中介对象来封装一系列的对象交互，使得各对象间不需要显示地相互引用，中介者模式的本质是：封装交互；</code></pre><p>Colleague角色：抽象交互对象</p><pre><code>//持有中介者的引用public abstract class AbstractDatabase {    protected AbstractMediator mediator;    public static final String REDIS = &quot;redis&quot;;    public static final String MYSQL = &quot;mysql&quot;;    public static final String HDFS = &quot;hdfs&quot;;    public AbstractDatabase(AbstractMediator mediator) {        this.mediator = mediator;    }    abstract void addData(String data);}</code></pre><p>ConcreteColleague角色:具体交互对象</p><pre><code>public class RedisDatabase extends AbstractDatabase {    private List&lt;String&gt; redisSet = new ArrayList&lt;&gt;();    public RedisDatabase(AbstractMediator mediator) {        super(mediator);    }    public void synInfo(String data){        System.out.println(&quot;redis data is synchronizing......&quot;);        //交由中介者实现数据同步        mediator.sync(AbstractDatabase.REDIS,data);        System.out.println(&quot;redis data finished synchronize&quot;);    }    @Override    void addData(String data) {        System.out.println(&quot;add data to Redis&quot;);        redisSet.add(data);        synInfo(data);    }    public void redisInfo(){        System.out.println(&quot;stored REDIS data number: &quot;+redisSet.size() + &quot; Info : &quot;+redisSet.toString());    }}MysqlDatabase......HdfsDatabase......</code></pre><p>Mediator角色：抽象中介者</p><pre><code>public abstract class AbstractMediator {    protected RedisDatabase redisDatabase;    protected MysqlDatabase mysqlDatabase;    protected HdfsDatabase hdfsDatabase;    abstract void sync(String database,String data);    public void setRedisDatabase(RedisDatabase redisDatabase) {        this.redisDatabase = redisDatabase;    }    public void setMysqlDatabase(MysqlDatabase mysqlDatabase) {        this.mysqlDatabase = mysqlDatabase;    }    public void setHdfsDatabase(HdfsDatabase hdfsDatabase) {        this.hdfsDatabase = hdfsDatabase;    }}</code></pre><p>ConcreteMediator角色:具体中介者</p><pre><code>//实现 redis 和 mysql 的数据同步到 hdfspublic class SyncMediator extends AbstractMediator {    @Override    void sync(String database, String data) {        if (database.equals(AbstractDatabase.REDIS)) {            hdfsDatabase.addData(data);        } else if (database.equals(AbstractDatabase.MYSQL)) {            hdfsDatabase.addData(data);        }    }}</code></pre><p>Client角色：</p><pre><code> public static void main(String[] args){    AbstractMediator mediator = new SyncMediator();    RedisDatabase redis = new RedisDatabase(mediator);    MysqlDatabase mysql = new MysqlDatabase(mediator);    HdfsDatabase hdfs = new HdfsDatabase(mediator)；    mediator.setRedisDatabase(redis);    mediator.setMysqlDatabase(mysql);    mediator.setMysqlDatabase(hdfs);    redis.addData(&quot;1&quot;);    redis.redisInfo();    mysql.mysqlInfo();    hdfs.hdfsInfo();}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;UML图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/mediator.PNG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中介者模式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 使用一个中介对象来封装一系列的对象交互，使得各对象间不需要显示地相互引用，

      
    
    </summary>
    
      <category term="Java设计模式" scheme="http://www.xuchunfa.cn/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>访问者模式</title>
    <link href="http://www.xuchunfa.cn/2019/05/26/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuchunfa.cn/2019/05/26/访问者模式/</id>
    <published>2019-05-26T08:20:16.000Z</published>
    <updated>2019-05-29T02:07:59.801Z</updated>
    
    <content type="html"><![CDATA[<p>UML图：</p><p><img src="/images/visitor.PNG" alt=""></p><p><strong>访问者模式</strong></p><pre><code>封装一些作用于某种数据结构中的各元素的操作，可以在不改变这个数据结构的前提下定义作用于这些元素的新操作。</code></pre><p>Visitor角色：</p><pre><code>public interface Visitor {    //Engine 和 Wheel 类指那些不易发生变化的数据结构    void visit(Engine engine);    void visit(Wheel wheel);}</code></pre><p>具体访问的行为角色：</p><pre><code>//修理零件public class RepairVisitor implements Visitor {    @Override    public void visit(Engine engine) {        System.out.println(&quot;repairing engine......&quot;);    }    @Override    public void visit(Wheel wheel) {        System.out.println(&quot;repairing wheel......&quot;);    }}</code></pre><p>被访问的角色：</p><pre><code>//通常是那些稳定的数据结构public interface Visitable {    void accept(Visitor visitor);}</code></pre><p>具体被访问的角色：</p><pre><code>public class Engine implements Visitable {    @Override    public void accept(Visitor visitor) {        visitor.visit(this);    }}public class Wheel implements Visitable {    @Override    public void accept(Visitor visitor) {        visitor.visit(this);    }}</code></pre><p>整个对象结构角色：</p><pre><code>public class Car {    private List&lt;Visitable&gt; components = new ArrayList&lt;&gt;();    private Visitor visitor;    public void addComponent(Visitable visitable){        components.add(visitable);    }    public void setVisitor(Visitor visitor) {        this.visitor = visitor;    }    //visitor方式一一访问visitable角色    public void startVisit(){        for(Visitable v : components){            v.accept(visitor);        }    }}</code></pre><p>客户端：</p><pre><code>public static void main(String[] args){    Car car = new Car();    Visitable engine = new Engine();    Visitable wheel = new Wheel();    car.addComponent(engine);//添加被访问的结构    car.addComponent(wheel);    Visitor repair = new RepairVisitor();    car.setVisitor(repair);//设置访问行为    car.startVisit();}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;UML图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/visitor.PNG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;访问者模式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;封装一些作用于某种数据结构中的各元素的操作，可以在不改变这个数据结构的前提下定义
      
    
    </summary>
    
      <category term="Java设计模式" scheme="http://www.xuchunfa.cn/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>责任链模式</title>
    <link href="http://www.xuchunfa.cn/2019/05/26/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuchunfa.cn/2019/05/26/责任链模式/</id>
    <published>2019-05-26T02:53:11.000Z</published>
    <updated>2019-05-29T02:00:40.514Z</updated>
    
    <content type="html"><![CDATA[<p>UML图：</p><p><img src="/images/chain.PNG" alt=""></p><p>特点：</p><pre><code>把请求的传递从子类中剥夺出来了，子类可以专心处理业务逻辑，子类不再需要进行传递的判断；</code></pre><p>问题角色：</p><pre><code>public enum Problem {    STRUCTURE(1), ARCHITECTURE(2);    private int level;    Problem(int  level) {        this.level = level;    }    public int getLevel() {        return level;    }}</code></pre><p>Handler角色：</p><pre><code>public abstract class Handler {    protected int level;//表示问题的级别    private Handler next;    public Handler(int level) {        this.level = level;    }    //责任链的入口    public final void transfer(Problem problem){        if(level == problem.getLevel()){            this.report();        }else if(this.next != null){            this.next.transfer(problem);        }else{            System.out.println(&quot;Final boss can&apos;t resolve the problem&quot;);        }    }    public void setNext(Handler next) {        this.next = next;    }    abstract void report();}</code></pre><p>项目经理角色：</p><pre><code>public class Manager extends Handler {    //项目经理解决structure问题    public Manager() {        super(1);    }    @Override    void report() {        System.out.println(&quot;项目经理解决软件结构布局&quot;);    }}</code></pre><p>架构师角色：</p><pre><code>public class Architect extends Handler {    //架构师解决architecture问题    public Architect() {        super(2);    }    @Override    void report() {        System.out.println(&quot;架构师解决软件架构设计&quot;);    }}</code></pre><p>客户端：</p><pre><code>public static void main(String[] args){    Manager manager = new Manager();    Architect architect = new Architect();    manager.setNext(architect);    manager.transfer(Problem.STRUCTURE);    manager.transfer(Problem.ARCHITECTURE);}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;UML图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/chain.PNG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;把请求的传递从子类中剥夺出来了，子类可以专心处理业务逻辑，子类不再需要进行传递的判断；
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;问
      
    
    </summary>
    
      <category term="Java设计模式" scheme="http://www.xuchunfa.cn/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="http://www.xuchunfa.cn/2019/05/25/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuchunfa.cn/2019/05/25/策略模式/</id>
    <published>2019-05-25T11:24:25.000Z</published>
    <updated>2019-05-29T01:56:41.545Z</updated>
    
    <content type="html"><![CDATA[<p>UML图：</p><p><img src="/images/strategy.PNG" alt=""></p><p>枚举方法实现的策略模式：</p><pre><code>public enum StrategyEnum {    ADD{        @Override        public int calculate(int a, int b) {            return a + b;        }    },    SUBTRACT{        @Override        public int calculate(int a, int b) {            return a - b;        }    };    //抽象方法放后面    public abstract int calculate(int a, int b);}</code></pre><p>Client:</p><pre><code>public static void main(String[] args){    StrategyEnum.ADD.calculate(1,1);    StrategyEnum.SUBTRACT.calculate(1,1);}</code></pre><p>实际应用：</p><pre><code>利用策略模式解决if else 分支过多的情况，项目中使用到了反射和策略模式的方法；</code></pre><p>隶属度计算接口：</p><pre><code>public interface MembershipMath {    double calculate(double attr);}</code></pre><p>不同隶属度计算函数类：</p><pre><code>public class MaxNormal implements MembershipMath {    private double middle;    public MaxNormal() {    }    @Override    public double calculate(double attr) {        DecimalFormat df = new DecimalFormat(&quot;#0.00&quot;);        if(Double.compare(attr,middle) &lt; 0){            return 0;        }else{            return Double.parseDouble(df.format(1 - Math.exp(-Math.pow(attr-middle,2))));        }    }    public double getMiddle() {        return middle;    }    public void setMiddle(double middle) {        this.middle = middle;    }}</code></pre><p>客户端：</p><pre><code>public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException {    String classPath = &quot;neu.cloud.functionpackage.membershipes.impl.MinTrapezoid&quot;;    String minName = &quot;min&quot;;    double min = 1;    String maxName = &quot;max&quot;;    double max = 1;    //获取隶属函数的参数    HashMap&lt;String,Double&gt; fieldMap = new HashMap&lt;&gt;();    fieldMap.put(minName,min);    fieldMap.put(maxName,max);    //全限域名获取隶属函数实例    Class&lt;?&gt; clazz = Class.forName(classPath);    MembershipMath membershipMath = (MembershipMath) clazz.newInstance();    //反射调用真正实例的setMin、setMax、setMiddle方法，来设置参数    invokeSetParams(membershipMath,fieldMap);    System.out.println(membershipMath.calculate(3));}private static void invokeSetParams(MembershipMath membershipMath, HashMap&lt;String, Double&gt; fieldMap) {    Iterator&lt;Map.Entry&lt;String,Double&gt;&gt; params = fieldMap.entrySet().iterator();    while (params.hasNext()){        StringBuilder sb = new StringBuilder();        Map.Entry&lt;String,Double&gt; entry = params.next();        String method = entry.getKey();        String methodName = sb.append(&quot;set&quot;).append(Character.toUpperCase(method.charAt(0))).                append(method.substring(1,method.length())).toString();        double methodValue = entry.getValue();        Method[] methods = membershipMath.getClass().getMethods();        for(Method method1 : methods){            if(method1.getName().equals(methodName)){                try {                    method1.invoke(membershipMath,methodValue);                } catch (IllegalAccessException e) {                    e.printStackTrace();                } catch (InvocationTargetException e) {                    e.printStackTrace();                }            }        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;UML图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/strategy.PNG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;枚举方法实现的策略模式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public enum StrategyEnum {
    ADD{
        @Over
      
    
    </summary>
    
      <category term="Java设计模式" scheme="http://www.xuchunfa.cn/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>享元模式</title>
    <link href="http://www.xuchunfa.cn/2019/05/24/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuchunfa.cn/2019/05/24/享元模式/</id>
    <published>2019-05-24T06:31:10.000Z</published>
    <updated>2019-05-29T01:54:33.199Z</updated>
    
    <content type="html"><![CDATA[<p>UML图：</p><p><img src="/images/flyWeight.PNG" alt=""></p><p><strong>享元模式</strong></p><pre><code>通过共享实现细粒度对象的复用，一般结合单例模式/工厂方法模式获取FlyweightFactory实例；设计享元类时要将内部状态和外部状态分开，通常内部状态作为享元类的成员变量，外部状态通过注入的方式添加到享元类中；</code></pre><p>同名书共享订单实例：</p><pre><code>//抽象享元public interface FlyWeight {    void sell();}//具体享元类public class BookOrder implements FlyWeight {    private String name;    public BookOrder(String name) {        this.name = name;    }    @Override    public void sell() {        System.out.println(&quot;sell a book named by: &quot; + name);    }}//public class FlyWeightFactory {    //饿汉模式线程安全    private static final FlyWeightFactory factory = new FlyWeightFactory();    //享元池    private HashMap&lt;String,FlyWeight&gt; pool = new HashMap&lt;&gt;();    private FlyWeightFactory(){    }    public static FlyWeightFactory getInstance(){        return factory;    }    public FlyWeight addOrder(String bookName){        FlyWeight order = null;        if(pool.containsKey(bookName)){            order = pool.get(bookName);        }else {            order = new BookOrder(bookName);            pool.put(bookName,order);        }        return order;    }    public int getAllOrder(){        return pool.size();    }}</code></pre><p>Client:</p><pre><code>public static void main(String[] args){    List&lt;FlyWeight&gt; orders = new ArrayList&lt;&gt;();    FlyWeightFactory factory = FlyWeightFactory.getInstance();    //一本书生成一个订单对象(同名书共享一个订单对象)    orders.add(factory.addOrder(&quot;红楼梦&quot;));    orders.add(factory.addOrder(&quot;水浒传&quot;));    orders.add(factory.addOrder(&quot;红楼梦&quot;));    //调用享元类接口    for(FlyWeight order : orders){        order.sell();    }    System.out.println(&quot;num of book sold: &quot;+orders.size());    System.out.println(&quot;num of book order: &quot;+factory.getAllOrder());}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;UML图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/flyWeight.PNG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;享元模式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;通过共享实现细粒度对象的复用，一般结合单例模式/工厂方法模式获取Flyweig
      
    
    </summary>
    
      <category term="Java设计模式" scheme="http://www.xuchunfa.cn/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>组合模式</title>
    <link href="http://www.xuchunfa.cn/2019/05/24/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuchunfa.cn/2019/05/24/组合模式/</id>
    <published>2019-05-24T03:41:09.000Z</published>
    <updated>2019-05-29T01:52:47.373Z</updated>
    
    <content type="html"><![CDATA[<p>组合模式安全模式-UML图：</p><p><img src="/images/safeComponent.PNG" alt=""></p><p>组合模式透明模式-UML图：</p><p><img src="/images/transparentComponent.PNG" alt=""></p><p><strong>组合模式</strong></p><pre><code>也叫合成模式，用来描述整体-部分的关系，将对象组合成树形结构，使得用户对单个对象和组合对象的使用具有一致性；</code></pre><p>安全式组合模式实例：</p><pre><code>//叶子和非叶子抽象出来的模板方法public abstract class Component {    protected String name;    abstract void display();}//叶子public class Leaf extends Component {    public Leaf(String name) {        this.name = name;    }    @Override    void display() {        System.out.println(&quot;Name of leaf: &quot; + name);    }}//分支public class Branch extends Component {    public Branch(String name) {        this.name = name;    }    private List&lt;Component&gt; children = new ArrayList&lt;&gt;();    public Component add(Component node){        children.add(node);        return node;    }    public Component remove(Component node){        children.remove(node);        return node;    }    public List&lt;Component&gt; getChildren() {        return children;    }    @Override    void display() {        System.out.println(&quot;Name of branch: &quot; + name);    }}</code></pre><p>Client:</p><pre><code>public static void main(String[] args){    Branch root = new Branch(&quot;root&quot;);    Branch branch = new Branch(&quot;branch1&quot;);    Component leaf1 = new Leaf(&quot;leaf1&quot;);    Component leaf2 = new Leaf(&quot;leaf2&quot;);    root.add(branch);    branch.add(leaf1);    branch.add(leaf2);    root.display();    show(root);}private static void show(Branch root) {    for(Component node : root.getChildren()){        if(node instanceof Leaf){            node.display();        }else {            show((Branch) node);            //或者树枝节点的其他方法            node.display();        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;组合模式安全模式-UML图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/safeComponent.PNG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;组合模式透明模式-UML图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/transparentComponent.PN
      
    
    </summary>
    
      <category term="Java设计模式" scheme="http://www.xuchunfa.cn/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>桥接模式</title>
    <link href="http://www.xuchunfa.cn/2019/05/23/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuchunfa.cn/2019/05/23/桥接模式/</id>
    <published>2019-05-23T13:13:01.000Z</published>
    <updated>2019-05-29T01:47:53.755Z</updated>
    
    <content type="html"><![CDATA[<p>UML图：</p><p><img src="/images/bridge.PNG" alt=""></p><p><strong>桥接模式</strong></p><pre><code>将抽象部分与它的实现部分分离，使它们都可以独立的变化；好处就是减少类的爆炸增长；</code></pre><p>抽象功能角色：</p><pre><code>public abstract class Car {    protected Engine engine;    public void setEngine(Engine engine) {        this.engine = engine;    }    abstract void run();}</code></pre><p>具体功能角色：</p><pre><code>//聚合 Engine public class BenZCar extends Car {    private static final Logger LOG = LoggerFactory.getLogger(BenZCar.class);    @Override    void run() {        engine.gear();        LOG.info(&quot;running by BenZCar......&quot;);    }}</code></pre><p>抽象实现角色：</p><pre><code>public abstract class Engine {    abstract void gear();}</code></pre><p>具体实现角色：</p><pre><code>public class AutoEngine extends Engine {    private static final Logger LOG = LoggerFactory.getLogger(AutoEngine.class);    @Override    void gear() {        LOG.info(&quot;use AutoEngine &quot;);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;UML图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/bridge.PNG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;桥接模式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;将抽象部分与它的实现部分分离，使它们都可以独立的变化；好处就是减少类的爆炸增长；
&lt;
      
    
    </summary>
    
      <category term="Java设计模式" scheme="http://www.xuchunfa.cn/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>外观模式</title>
    <link href="http://www.xuchunfa.cn/2019/05/23/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuchunfa.cn/2019/05/23/外观模式/</id>
    <published>2019-05-23T07:59:06.000Z</published>
    <updated>2019-05-29T01:46:08.288Z</updated>
    
    <content type="html"><![CDATA[<p>UML图：</p><p><img src="/images/facade.PNG" alt=""></p><p><strong>外观模式（门面模式）</strong></p><pre><code>通过外观类将子系统和客户端解耦，为复杂的子系统调用提供一统一的入口；在层次结构中，可以使用外观模式定义系统中每一层的入口，降低层之间的耦合度；</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;UML图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/facade.PNG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;外观模式（门面模式）&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;通过外观类将子系统和客户端解耦，为复杂的子系统调用提供一统一的入口；
在
      
    
    </summary>
    
      <category term="Java设计模式" scheme="http://www.xuchunfa.cn/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>原型模式</title>
    <link href="http://www.xuchunfa.cn/2019/05/21/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuchunfa.cn/2019/05/21/原型模式/</id>
    <published>2019-05-21T12:36:57.000Z</published>
    <updated>2019-05-29T01:29:52.275Z</updated>
    
    <content type="html"><![CDATA[<p>UML图：</p><p><img src="/images/prototype.PNG" alt=""></p><p><strong>原型模式：</strong></p><pre><code>复制原对象，克隆出与原型对象一模一样的对象；</code></pre><p>原型接口：</p><pre><code>public interface Product extends Cloneable{    Object cloneProduct();}</code></pre><p>具体原型：</p><pre><code>public class ProductA implements Product {    @Override    public Object cloneProduct() {        try {            return clone();        } catch (CloneNotSupportedException e) {            e.printStackTrace();        }        return null;    }}</code></pre><p>使用者：</p><pre><code>public class Manager {    private Product product;    public Manager(Product product) {        this.product = product;    }    public Product create(){        return (Product) product.cloneProduct();    }    public static void main(String[] args){        ProductA productA = new ProductA();        Manager manager = new Manager(productA);        Product clonedProductA = manager.create();        System.out.println(productA == clonedProductA);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;UML图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/prototype.PNG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原型模式：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;复制原对象，克隆出与原型对象一模一样的对象；
&lt;/code&gt;&lt;/pre&gt;&lt;p
      
    
    </summary>
    
      <category term="Java设计模式" scheme="http://www.xuchunfa.cn/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>建造者模式</title>
    <link href="http://www.xuchunfa.cn/2019/05/15/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuchunfa.cn/2019/05/15/建造者模式/</id>
    <published>2019-05-15T12:44:57.000Z</published>
    <updated>2019-05-29T01:28:03.500Z</updated>
    
    <content type="html"><![CDATA[<p>UML图：</p><p><img src="/images/builder.PNG" alt=""></p><p><strong>建造者模式</strong></p><pre><code>用户不必知道对象的构建过程和具体实现细节就能创建出复杂的对象，将建造复杂对象的过程和组成对象的部件解耦。</code></pre><p>Builder:</p><pre><code>//构建部件的抽象类或接口public abstract class Builder {    protected HomeStruct struct = new HomeStruct();    abstract void bulidFoundation();    abstract void buildArchitecture();    public HomeStruct finishConstruct(){        return struct;    }}</code></pre><p>ConcreteBuiler:</p><pre><code>//具体部件构建的实现（木屋材料）public class WoodenBuilder extends Builder {    private String material = &quot;wood&quot;;    @Override    public void bulidFoundation() {        System.out.println(&quot;地基使用：&quot; + material);        struct.setFoundation(material);    }    @Override    public void buildArchitecture() {        System.out.println(&quot;架构使用：&quot; + material);        struct.setArchitecture(material);    }    public HomeStruct finishContruct(){        return struct;    }}//水泥材料public class CementBuilder extends Builder {    private String material = &quot;cement&quot;;    @Override    public void bulidFoundation() {        System.out.println(&quot;地基使用：&quot; + material);        struct.setFoundation(material);    }    @Override    public void buildArchitecture() {        System.out.println(&quot;架构使用：&quot; + material);        struct.setArchitecture(material);    }    public HomeStruct finishContruct(){        return struct;    }}</code></pre><p>Director:</p><pre><code>//使用不同材料可以构造不同建筑物public class Director {    private Builder builder;    public Director(Builder builder) {        this.builder = builder;    }    public void construct(){        builder.bulidFoundation();        builder.buildArchitecture();    }}</code></pre><p>测试:</p><pre><code>public class Construction {    @Test    public void test(){        Builder woodenBuilder = new WoodenBuilder();        Director director = new Director(woodenBuilder);        director.construct();        HomeStruct homeStruct = woodenBuilder.finishConstruct();        System.out.println(homeStruct.getFoundation());        System.out.println(homeStruct.getArchitecture());    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;UML图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/builder.PNG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;建造者模式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;用户不必知道对象的构建过程和具体实现细节就能创建出复杂的对象，将建造复杂对象的过
      
    
    </summary>
    
      <category term="Java设计模式" scheme="http://www.xuchunfa.cn/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>抽象工厂模式</title>
    <link href="http://www.xuchunfa.cn/2019/05/13/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuchunfa.cn/2019/05/13/抽象工厂模式/</id>
    <published>2019-05-13T11:51:32.000Z</published>
    <updated>2019-05-27T13:54:13.675Z</updated>
    
    <content type="html"><![CDATA[<p>UML图：</p><p><img src="/images/AbstractFactory.PNG" alt=""></p><p><strong>抽象工厂模式</strong></p><pre><code>工厂类不单单是创建一个对象，而是创建一组对象；</code></pre><p>抽象工厂类：</p><pre><code>public interface PhoneFactory {    HUAWEI produceHW();    XIAOMI produceXM();}</code></pre><p>具体工厂类：</p><pre><code>//生产一代手机的具体工厂public class Phone1Factory implements PhoneFactory {    @Override    public HUAWEI produceHW() {        return new HUAWEI1();    }    @Override    public XIAOMI produceXM() {        return new XIAOMI1();    }}//生产二代手机的具体工厂public class Phone2Factory implements PhoneFactory {    @Override    public HUAWEI produceHW() {        return new HUAWEI2();    }    @Override    public XIAOMI produceXM() {        return new XIAOMI2();    }}</code></pre><p>抽象产品类：</p><pre><code>//产品Apublic interface HUAWEI {    void huaweiInfo();}//产品Bpublic interface XIAOMI {    void xiaomiInfo();}</code></pre><p>具体产品类：</p><pre><code>//产品A1public class HUAWEI1 implements HUAWEI {    @Override    public void huaweiInfo() {        System.out.println(&quot;华为1代&quot;);    }}//产品A2public class HUAWEI2 implements HUAWEI {    @Override    public void huaweiInfo() {        System.out.println(&quot;华为2代&quot;);    }}//产品B1public class XIAOMI1 implements XIAOMI {    @Override    public void xiaomiInfo() {        System.out.println(&quot;小米1代&quot;);    }}//产品B2public class XIAOMI2 implements XIAOMI {    @Override    public void xiaomiInfo() {        System.out.println(&quot;小米2代&quot;);    }}</code></pre><p>测试用例：</p><pre><code>PhoneFactory pf1 = new Phone1Factory();HUAWEI huawei = pf1.produceHW();XIAOMI xiaomi = pf1.produceXM();huawei.huaweiInfo();//华为1代xiaomi.xiaomiInfo();//小米1代</code></pre><p><a href="https://blog.51cto.com/zero01/2070033" target="_blank" rel="noopener">理解工厂方法模式和抽象工厂模式</a></p><h4 id="抽象工厂模式和工厂方法模式的不同处？"><a href="#抽象工厂模式和工厂方法模式的不同处？" class="headerlink" title="抽象工厂模式和工厂方法模式的不同处？"></a>抽象工厂模式和工厂方法模式的不同处？</h4><pre><code>1.抽象工厂是可以生产多个产品的，并且这些产品属于同一系列，工厂方法模式只能生产一个产品；</code></pre><h4 id="抽象工厂模式优点"><a href="#抽象工厂模式优点" class="headerlink" title="抽象工厂模式优点"></a>抽象工厂模式优点</h4><pre><code>1.具体实例的创建过程与客户端分离，客户端通过抽象接口操作实例对象；</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;UML图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/AbstractFactory.PNG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抽象工厂模式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;工厂类不单单是创建一个对象，而是创建一组对象；
&lt;/code&gt;
      
    
    </summary>
    
      <category term="Java设计模式" scheme="http://www.xuchunfa.cn/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式分类与原则</title>
    <link href="http://www.xuchunfa.cn/2019/05/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB%E4%B8%8E%E5%8E%9F%E5%88%99/"/>
    <id>http://www.xuchunfa.cn/2019/05/12/设计模式分类与原则/</id>
    <published>2019-05-12T11:46:55.000Z</published>
    <updated>2019-05-27T12:11:36.518Z</updated>
    
    <content type="html"><![CDATA[<p><strong>设计模式分类</strong></p><ul><li>创建型模式(5种)：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</li></ul><ul><li><p>结构型模式（7种）：适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p></li><li><p>行为模式（11种）：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p></li></ul><p><strong>设计模式功能分类</strong></p><ul><li><p>适应设计模式</p><pre><code>迭代器模式、适配器模式。</code></pre></li><li><p>交给子类</p><pre><code>模板方法模式、工厂方法模式</code></pre></li><li><p>生成实例</p><pre><code>单例模式、原型模式、建造者模式、抽象工厂模式</code></pre></li><li><p>分开考虑</p><pre><code>桥接模式、策略模式</code></pre></li><li><p>一致性（继承某类又持有该类的引用）</p><pre><code>组合模式（持有一组引用）、装饰者模式</code></pre></li><li><p>访问数据结构</p><pre><code>访问者模式、责任链模式</code></pre></li><li><p>简单化</p><pre><code>外观模式、中介者模式（封装交互）</code></pre></li><li><p>管理状态</p><pre><code>观察者模式、备忘录模式、状态模式</code></pre></li><li><p>避免浪费</p><pre><code>享元模式、代理模式</code></pre></li><li><p>用类来表现</p><pre><code>命令模式、解释器模式</code></pre></li></ul><p><strong>设计模式原则</strong></p><ul><li><p>开闭原则：对拓展开放，对修改关闭，多使用接口和抽象类。</p></li><li><p>里氏替换原则</p></li><li><p>依赖倒转原则</p></li><li><p>接口隔离原则：多使用多个隔离的接口，比使用单个接口要好，降低了类与类的耦合性。</p></li><li><p>迪米特原则</p></li><li><p>合成复用原则：尽量多使用合成/聚合方式，而不是继承。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;设计模式分类&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建型模式(5种)：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;结构型模式（7种）：适配器模式、装饰者模式、代理模式、外观模式、桥接模式
      
    
    </summary>
    
      <category term="Java设计模式" scheme="http://www.xuchunfa.cn/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>阻塞队列源码详解</title>
    <link href="http://www.xuchunfa.cn/2019/04/19/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.xuchunfa.cn/2019/04/19/阻塞队列源码详解/</id>
    <published>2019-04-19T07:42:02.000Z</published>
    <updated>2019-04-19T12:34:32.213Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.javadoop.com/post/java-concurrent-queue" target="_blank" rel="noopener">阻塞队列详解</a></p><p>总结：</p><pre><code>1.ArrayBlockingQueue:底层数组，有界队列；2.LinkedBlockingQueue：底层链表，可以当作无界和有界队列使用；3.SynchronousQueue：本身不带有空间存储任何元素，有公平和非公平；4.PriorityBlockingQueue：无界队列，基于数组，数据结构为二叉堆，数组第一个是最小值；</code></pre><h4 id="ArrayBlockingQueue详解"><a href="#ArrayBlockingQueue详解" class="headerlink" title="ArrayBlockingQueue详解"></a>ArrayBlockingQueue详解</h4><p>核心成员变量：</p><pre><code>final Object[] items;int takeIndex;int putIndex;int count;final ReentrantLock lock;private final Condition notEmpty;private final Condition notFull;</code></pre><p>带阻塞插入方法：(offer方法不带阻塞)</p><pre><code>public void put(E e) throws InterruptedException {    checkNotNull(e);//插入元素不允许为null    final ReentrantLock lock = this.lock;    lock.lockInterruptibly();    try {        while (count == items.length)            notFull.await();        enqueue(e);//入队    } finally {        lock.unlock();    }}</code></pre><p>元素入队：</p><pre><code>private void enqueue(E x) {    final Object[] items = this.items;    items[putIndex] = x;    if (++putIndex == items.length)        putIndex = 0;    count++;    notEmpty.signal();//唤醒notEmpty条件队列的头节点}</code></pre><p>带阻塞获取方法：</p><pre><code>public E take() throws InterruptedException {    final ReentrantLock lock = this.lock;    lock.lockInterruptibly();    try {        while (count == 0)            notEmpty.await();        return dequeue();    } finally {        lock.unlock();    }}</code></pre><p>元素出队：</p><pre><code>private E dequeue() {    final Object[] items = this.items;    @SuppressWarnings(&quot;unchecked&quot;)    E x = (E) items[takeIndex];    items[takeIndex] = null;//help GC    if (++takeIndex == items.length)        takeIndex = 0;    count--;    if (itrs != null)        itrs.elementDequeued();    notFull.signal();//唤醒notFull条件队列的头节点    return x;}</code></pre><h4 id="LinkedBlockingQueue详解"><a href="#LinkedBlockingQueue详解" class="headerlink" title="LinkedBlockingQueue详解"></a>LinkedBlockingQueue详解</h4><p>核心变量：</p><pre><code>private final int capacity;//默认Integer.MAXVALUEprivate final AtomicInteger count = new AtomicInteger();//当前队列元素个数transient Node&lt;E&gt; head;private transient Node&lt;E&gt; last;//take、poll方法时加锁private final ReentrantLock takeLock = new ReentrantLock();//offer、offer方法时加锁private final ReentrantLock putLock = new ReentrantLock();private final Condition notEmpty = takeLock.newCondition();private final Condition notFull = putLock.newCondition();</code></pre><p>put方法源码分析：</p><pre><code>public void put(E e) throws InterruptedException {    if (e == null) throw new NullPointerException();    int c = -1;//标识是否成功，-1表示不成功    Node&lt;E&gt; node = new Node&lt;E&gt;(e);    final ReentrantLock putLock = this.putLock;    final AtomicInteger count = this.count;    putLock.lockInterruptibly();    try {        while (count.get() == capacity) {            notFull.await();        }        enqueue(node);        c = count.getAndIncrement();//返回的是旧值        if (c + 1 &lt; capacity)            //还有空间可用，唤醒notFull上的线程，哪些线程            notFull.signal();    } finally {        putLock.unlock();    }    if (c == 0)        signalNotEmpty();//唤醒notEmpty}</code></pre><p>唤醒notEmpty:</p><pre><code> private void signalNotEmpty() {    final ReentrantLock takeLock = this.takeLock;    takeLock.lock();    try {        notEmpty.signal();    } finally {        takeLock.unlock();    }}</code></pre><p>元素入队：</p><pre><code>private void enqueue(Node&lt;E&gt; node) {    last = last.next = node;//初始化时last就不会为空了}</code></pre><p>take方法源码详解：</p><pre><code>public E take() throws InterruptedException {    E x;    int c = -1;    final AtomicInteger count = this.count;    final ReentrantLock takeLock = this.takeLock;    takeLock.lockInterruptibly();    try {        while (count.get() == 0) {            notEmpty.await();        }        x = dequeue();        c = count.getAndDecrement();        if (c &gt; 1)            notEmpty.signal();    } finally {        takeLock.unlock();    }    if (c == capacity)        signalNotFull();//唤醒notFull    return x;}</code></pre><p>元素出队：</p><pre><code>private E dequeue() {    Node&lt;E&gt; h = head;//头节点内容为空    Node&lt;E&gt; first = h.next;    h.next = h; // help GC    head = first;    E x = first.item;    first.item = null;    return x;}</code></pre><h4 id="SynchronousQueue源码解析"><a href="#SynchronousQueue源码解析" class="headerlink" title="SynchronousQueue源码解析"></a>SynchronousQueue源码解析</h4><p>有公平和非公平两种队列：默认非公平</p><pre><code>public SynchronousQueue(boolean fair) {    transferer = fair ? new TransferQueue&lt;E&gt;() : new TransferStack&lt;E&gt;();}</code></pre><p>先看一下TransferQueue的put源码：</p><pre><code>public void put(E e) throws InterruptedException {    if (e == null) throw new NullPointerException();    if (transferer.transfer(e, false, 0) == null) {        Thread.interrupted();        throw new InterruptedException();    }    }</code></pre><p>核心代码：</p><pre><code>E transfer(E e, boolean timed, long nanos) {    QNode s = null;    boolean isData = (e != null);//e != null代表将元素从生产者转移到消费者    for (;;) {        QNode t = tail;        QNode h = head;        if (t == null || h == null)                      continue;                               //队列为空或者当前线程类型和队列中的一致        if (h == t || t.isData == isData) {             QNode tn = t.next;            if (t != tail)                                  continue;            if (tn != null) {                               advanceTail(t, tn);//CAS设置tn为尾节点                continue;            }            if (timed &amp;&amp; nanos &lt;= 0)                        return null;            if (s == null)                s = new QNode(e, isData);            if (!t.casNext(null, s))//节点插入到尾节点                        continue;            advanceTail(t, s);                          Object x = awaitFulfill(s, e, timed, nanos);            if (x == s) {                                   clean(t, s);                return null;            }            if (!s.isOffList()) {                           advanceHead(t, s);                          if (x != null)                                  s.item = s;                s.waiter = null;            }            return (x != null) ? (E)x : e;        } else {//当前线程类型与队列中类型不匹配，读或写相匹配                                       QNode m = h.next;                           if (t != tail || m == null || h != head)                continue;                               Object x = m.item;            if (isData == (x != null) ||                   x == m ||                                   !m.casItem(x, e)) {                         advanceHead(h, m);                         continue;            }            advanceHead(h, m);                          LockSupport.unpark(m.waiter);            return (x != null) ? (E)x : e;        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.javadoop.com/post/java-concurrent-queue&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阻塞队列详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.Array
      
    
    </summary>
    
      <category term="面试总结" scheme="http://www.xuchunfa.cn/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
      <category term="Java并发编程" scheme="http://www.xuchunfa.cn/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>ReentrantReadWriteLock源码详解</title>
    <link href="http://www.xuchunfa.cn/2019/04/16/ReentrantReadWriteLock%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.xuchunfa.cn/2019/04/16/ReentrantReadWriteLock源码详解/</id>
    <published>2019-04-16T01:57:13.000Z</published>
    <updated>2019-04-16T14:10:36.925Z</updated>
    
    <content type="html"><![CDATA[<p>参考文献</p><p><a href="https://www.javadoop.com/post/reentrant-read-write-lock" target="_blank" rel="noopener">读写锁源码详解</a></p><p>文献已经给出详细的解析，作简单总结：</p><p>使用场景：</p><pre><code>1.适用于读多于写的场景；</code></pre><p>关键问题：</p><pre><code>1.将state状态一分为二，高16位用于共享模式，低16位用于独占模式；2.持有写锁的线程去获取读锁的过程称为锁降级；不支持读锁升级为写锁（会产生死锁），可能读锁在竞争写锁时可能会使自己进入阻塞队列，导致无法被唤醒。3.在获取写锁前会判断是否有读锁存在的原因：确保写锁的操作对读锁可见，这样读锁才能感知到写锁的操作了；</code></pre><p>读锁源码分析：</p><pre><code>public void lock() {    sync.acquireShared(1);}public final void acquireShared(int arg) {    if (tryAcquireShared(arg) &lt; 0)        doAcquireShared(arg);}protected final int tryAcquireShared(int unused) {    Thread current = Thread.currentThread();    int c = getState();    //exclusiveCount(c) != 0 &amp;&amp; getExclusiveOwnerThread()=current表示锁降级的情况    if (exclusiveCount(c) != 0 &amp;&amp;//有线程持有写锁而且还不是当前线程        getExclusiveOwnerThread() != current)//注意持有写锁的当前线程还可以继续持有读锁        return -1;    int r = sharedCount(c);    if (!readerShouldBlock() &amp;&amp;//公平锁排队和写锁先于读锁时，readerShouldBlock()返回true        r &lt; MAX_COUNT &amp;&amp;        //设置高16位的state，失败的话说明发生读锁竞争或者当前写锁和其他读锁的竞争        compareAndSetState(c, c + SHARED_UNIT)) {        if (r == 0) {            firstReader = current;            firstReaderHoldCount = 1;        } else if (firstReader == current) {            firstReaderHoldCount++;        } else {            HoldCounter rh = cachedHoldCounter;            if (rh == null || rh.tid != getThreadId(current))                cachedHoldCounter = rh = readHolds.get();            else if (rh.count == 0)                readHolds.set(rh);            rh.count++;        }        return 1;//成功获取读锁    }    return fullTryAcquireShared(current);//尝试再次获取锁}</code></pre><p>尝试再次获取锁：</p><pre><code>final int fullTryAcquireShared(Thread current) {    HoldCounter rh = null;    for (;;) {        int c = getState();        if (exclusiveCount(c) != 0) {//还是其他线程获取写锁，阻塞读锁            if (getExclusiveOwnerThread() != current)                return -1;        } else if (readerShouldBlock()) {            //1.写锁没有被占            //2.阻塞队列有其他线程在等待            if (firstReader == current) {                // assert firstReaderHoldCount &gt; 0;            } else {                if (rh == null) {                    rh = cachedHoldCounter;                    if (rh == null || rh.tid != getThreadId(current)) {                        rh = readHolds.get();                        if (rh.count == 0)                            readHolds.remove();                    }                }                if (rh.count == 0)                    return -1;            }        }        if (sharedCount(c) == MAX_COUNT)            throw new Error(&quot;Maximum lock count exceeded&quot;);        //处理线程重入的情况        if (compareAndSetState(c, c + SHARED_UNIT)) {            if (sharedCount(c) == 0) {                firstReader = current;                firstReaderHoldCount = 1;            } else if (firstReader == current) {                firstReaderHoldCount++;            } else {                if (rh == null)                    rh = cachedHoldCounter;                if (rh == null || rh.tid != getThreadId(current))                    rh = readHolds.get();                else if (rh.count == 0)                    readHolds.set(rh);                rh.count++;                cachedHoldCounter = rh; // cache for release            }            return 1;        }    }</code></pre><p>读锁的释放源码：</p><pre><code> public void unlock() {    sync.releaseShared(1);}public final boolean releaseShared(int arg) {    if (tryReleaseShared(arg)) {        doReleaseShared();        return true;    }    return false;}protected final boolean tryReleaseShared(int unused) {    Thread current = Thread.currentThread();    if (firstReader == current) {        //反正优先处理的是第一个获取读锁的线程        if (firstReaderHoldCount == 1)            firstReader = null;        else            firstReaderHoldCount--;    } else {        HoldCounter rh = cachedHoldCounter;//缓存最近获取读锁的线程，为了提高效率        if (rh == null || rh.tid != getThreadId(current))            rh = readHolds.get();        int count = rh.count;        if (count &lt;= 1) {            readHolds.remove();//防止内存泄露            if (count &lt;= 0)//一次lock()多次unlock()的情况                throw unmatchedUnlockException();        }        --rh.count;    }    for (;;) {        int c = getState();        int nextc = c - SHARED_UNIT;//高位减1        if (compareAndSetState(c, nextc))            return nextc == 0;//读写锁都空了，唤醒后面的所有节点（共享模式的特点）    }}</code></pre><p>最后看一下写锁的源码：</p><p>获取写锁：</p><pre><code>public void lock() {        sync.acquire(1);    }public final void acquire(int arg) {    if (!tryAcquire(arg) &amp;&amp;        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))        selfInterrupt();}protected final boolean tryAcquire(int acquires) {    Thread current = Thread.currentThread();    int c = getState();    int w = exclusiveCount(c);    if (c != 0) {        //c!=0 &amp;&amp; w=0表示有线程持有读锁，这个线程可能是他自己或者其他线程        //c!=0 &amp;&amp; w!=0 &amp;&amp; current != getExclusiveOwnerThread()表示其他线程持有写锁        //c!=0 &amp;&amp; w!=0 &amp;&amp; current = getExclusiveOwnerThread()表示先获取写锁，后获取读锁的线程        if (w == 0 || current != getExclusiveOwnerThread())            return false;        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)            throw new Error(&quot;Maximum lock count exceeded&quot;);        //写锁重入        setState(c + acquires);        return true;    }    //非公平锁writerShouldBlock()=false，直接CAS设置state    //公平锁有前驱节点排队的话，writerShouldBlock()=true进入阻塞队列，否则正常设置    if (writerShouldBlock() ||        !compareAndSetState(c, c + acquires))        return false;    setExclusiveOwnerThread(current);    return true;}</code></pre><p>看一下写锁是否应该阻塞的情况：</p><pre><code>static final class NonfairSync extends Sync {// 如果是非公平模式，那么 lock 的时候就可以直接用 CAS 去抢锁，抢不到再排队final boolean writerShouldBlock() {    return false; // writers can always barge}...}static final class FairSync extends Sync {final boolean writerShouldBlock() {    // 如果是公平模式，那么如果阻塞队列有线程等待的话，就乖乖去排队    return hasQueuedPredecessors();}...}</code></pre><p>释放写锁：</p><pre><code>public void unlock() {        sync.release(1);    }public final boolean release(int arg) {    if (tryRelease(arg)) {        Node h = head;        if (h != null &amp;&amp; h.waitStatus != 0)            unparkSuccessor(h);        return true;    }    return false;}protected final boolean tryRelease(int releases) {    if (!isHeldExclusively())        throw new IllegalMonitorStateException();    //线程安全，写锁是排他锁    int nextc = getState() - releases；    boolean free = exclusiveCount(nextc) == 0;    if (free)        setExclusiveOwnerThread(null);    setState(nextc);    return free;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考文献&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.javadoop.com/post/reentrant-read-write-lock&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;读写锁源码详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文献已经给出详细的
      
    
    </summary>
    
      <category term="面试总结" scheme="http://www.xuchunfa.cn/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
      <category term="Java并发编程" scheme="http://www.xuchunfa.cn/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>CyclicBarrier源码解析</title>
    <link href="http://www.xuchunfa.cn/2019/04/15/CyclicBarrier%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://www.xuchunfa.cn/2019/04/15/CyclicBarrier源码解析/</id>
    <published>2019-04-15T12:50:10.000Z</published>
    <updated>2019-04-15T13:09:05.163Z</updated>
    
    <content type="html"><![CDATA[<p>参考文献</p><p><a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer-3" target="_blank" rel="noopener">CyclicBarrier源码解析</a></p><p>看一下构造函数：</p><pre><code>//parties代表线程数，当最后一个线程执行await()方法时，会进入下一代。public CyclicBarrier(int parties) {    this(parties, null);}</code></pre><p>核心await()方法：</p><pre><code>public int await() throws InterruptedException, BrokenBarrierException {    try {        return dowait(false, 0L);    } catch (TimeoutException toe) {        throw new Error(toe); // cannot happen    }}</code></pre><p>进入到dowait()方法：</p><pre><code>private int dowait(boolean timed, long nanos)    throws InterruptedException, BrokenBarrierException,           TimeoutException {    final ReentrantLock lock = this.lock;    lock.lock();    try {        final Generation g = generation;        if (g.broken)            throw new BrokenBarrierException();        if (Thread.interrupted()) {            breakBarrier();            throw new InterruptedException();        }        int index = --count;        if (index == 0) {              boolean ranAction = false;            try {                final Runnable command = barrierCommand;                if (command != null)                    command.run();                ranAction = true;                nextGeneration();//唤醒所有线程，开启下一代                return 0;            } finally {                if (!ranAction)//在执行command.run()时发生了异常                    breakBarrier();//唤醒所有线程，broker=true            }        }        //不是最后一个到达栅栏的线程走到这        for (;;) {            try {                if (!timed)                    //Condition trip = reentrantLock.newCondition                    trip.await();                else if (nanos &gt; 0L)                    nanos = trip.awaitNanos(nanos);            } catch (InterruptedException ie) {                if (g == generation &amp;&amp; ! g.broken) {                    breakBarrier();                    throw ie;                } else {                    Thread.currentThread().interrupt();                }            }            if (g.broken)                throw new BrokenBarrierException();            if (g != generation)                return index;            if (timed &amp;&amp; nanos &lt;= 0L) {                breakBarrier();                throw new TimeoutException();            }        }    } finally {        lock.unlock();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考文献&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.javadoop.com/post/AbstractQueuedSynchronizer-3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CyclicBarrier源码解析&lt;/a&gt;&lt;/p&gt;
      
    
    </summary>
    
      <category term="面试总结" scheme="http://www.xuchunfa.cn/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
      <category term="Java并发编程" scheme="http://www.xuchunfa.cn/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>CountDownLatch源码解析</title>
    <link href="http://www.xuchunfa.cn/2019/04/15/CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://www.xuchunfa.cn/2019/04/15/CountDownLatch源码解析/</id>
    <published>2019-04-15T12:06:48.000Z</published>
    <updated>2019-04-15T12:26:32.644Z</updated>
    
    <content type="html"><![CDATA[<p>参考文献</p><p><a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer-3" target="_blank" rel="noopener">CountDownLatch源码解析</a></p><p>文献已经给出了详细的讲解，这里作简单的总结：</p><p>在CountDownLatch中重写了tryAcquiredShared()和tryReleaseShared()方法：</p><pre><code>protected int tryAcquireShared(int acquires) {        return (getState() == 0) ? 1 : -1;    }protected boolean tryReleaseShared(int releases) {    // Decrement count; signal when transition to zero    for (;;) {        int c = getState();        if (c == 0)            return false;        int nextc = c-1;        if (compareAndSetState(c, nextc))            return nextc == 0;    }}</code></pre><p>线程阻塞的await()方法：</p><pre><code>public void await() throws InterruptedException {    sync.acquireSharedInterruptibly(1);}public final void acquireSharedInterruptibly(int arg)        throws InterruptedException {    if (Thread.interrupted())        throw new InterruptedException();    //countdown()方法会使state的值减1，当state还未为0时会进入到该方法    if (tryAcquireShared(arg) &lt; 0)        doAcquireSharedInterruptibly(arg);}</code></pre><p>进入到阻塞队列中：</p><pre><code>private void doAcquireSharedInterruptibly(int arg)    throws InterruptedException {    final Node node = addWaiter(Node.SHARED);    boolean failed = true;    try {        for (;;) {            final Node p = node.predecessor();            if (p == head) {                int r = tryAcquireShared(arg);                if (r &gt;= 0) {//调用countdown()方法使state=1的线程会唤醒阻塞的线程，并将节点设置为head                    setHeadAndPropagate(node, r);                    p.next = null; // help GC                    failed = false;                    return;                }            }            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                parkAndCheckInterrupt())//LockSupport阻塞线程                throw new InterruptedException();        }    } finally {        if (failed)            cancelAcquire(node);    }}</code></pre><p>阻塞队列被唤醒的过程：</p><pre><code>private void setHeadAndPropagate(Node node, int propagate) {    Node h = head;     setHead(node);    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||        (h = head) == null || h.waitStatus &lt; 0) {        Node s = node.next;        if (s == null || s.isShared())            doReleaseShared();//继续唤醒下一个节点    }}</code></pre><p>继续唤醒队列中的其他节点：</p><pre><code> private void doReleaseShared() {    for (;;) {//不断唤醒线程直到head不再发生变化        Node h = head;        if (h != null &amp;&amp; h != tail) {            int ws = h.waitStatus;            if (ws == Node.SIGNAL) {                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))                    continue;            // loop to recheck cases                unparkSuccessor(h);            }            else if (ws == 0 &amp;&amp;                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))                continue;                        }        if (h == head)                               break;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考文献&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.javadoop.com/post/AbstractQueuedSynchronizer-3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CountDownLatch源码解析&lt;/a&gt;&lt;/p
      
    
    </summary>
    
      <category term="面试总结" scheme="http://www.xuchunfa.cn/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
      <category term="Java并发编程" scheme="http://www.xuchunfa.cn/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
</feed>
