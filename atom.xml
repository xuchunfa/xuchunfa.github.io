<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Flying in the ocean of knowledge</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xuchunfa.cn/"/>
  <updated>2019-07-21T13:30:50.324Z</updated>
  <id>http://www.xuchunfa.cn/</id>
  
  <author>
    <name>Xu chunfa</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NIO详解</title>
    <link href="http://www.xuchunfa.cn/2019/07/18/NIO%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.xuchunfa.cn/2019/07/18/NIO详解/</id>
    <published>2019-07-18T02:14:50.000Z</published>
    <updated>2019-07-21T13:30:50.324Z</updated>
    
    <content type="html"><![CDATA[<p><strong>阻塞/非阻塞 和 同步/异步？</strong></p><pre><code>1.同步/异步：同步是会阻塞请求进程的，异步不会阻塞请求进程的，所以BIO、NIO            和IO多路复用都是同步的；2.阻塞/非阻塞：在等待一件事情的处理结果时，如果你还去干点其他的事，则为  非阻塞，否则为阻塞；</code></pre><p><strong>阻塞IO和非阻塞IO？</strong></p><p>1.阻塞IO</p><p><img src="/images/io.png" alt=""></p><p>分析：</p><pre><code>1.两个阶段都是阻塞的。第一个阶段指等待网络数据到达内核空间缓存区域，第二个阶段  是将内核空间缓冲区的数据复制到用户进程缓冲区；2.调用recvfrom时就开始阻塞；</code></pre><p>2.非阻塞IO</p><p><img src="/images/nio.png" alt=""></p><p>分析：</p><pre><code>1.第一个阶段是非阻塞的，第二个阶段是阻塞的；2.调用recvfrom时，如果数据没有准备好，是不会阻塞进程的，应用进程会轮询内核，检查数据是否准备好，准备好以后，数据复制到应用进程缓冲区，这段时间进程是被阻塞的；</code></pre><p>3.IO多路复用</p><p><img src="/images/io多路复用.png" alt=""></p><p>分析：</p><pre><code>1.进程阻塞于select，内核监视所有select负责的套接字，任何一个套接字数据准备好  以后，select方法返回；2.一个进程能同时等待多个文件描述符，它们中的任意一个进入读就绪状态时，select()函数就可以返回；3.第一个阶段和第二个阶段都阻塞；</code></pre><p>4.异步IO</p><p><img src="/images/异步IO.png" alt=""></p><pre><code>1.aio_read后立马返回，不会阻塞用户进程，kernel等待数据准备完成，然后将数据拷贝到用户内存，完成以后给用户进程发一个signal，告诉它read操作完成；</code></pre><p><strong>BIO、NIO、AIO的区别？</strong></p><pre><code>1.BIO：进程从调用recvfrom开始就阻塞；2.NIO：进程大部分时间都不会block，但仍然要求进程去主动check，当数据准备完成以后，也需要进程主动去调用recvfrom，将数据拷贝到用户空间；3.AIO：用户进程完全不会阻塞，将整个IO操作交给kernel完成，它完成以后发信号       通知，在此期间用户进程不需要检查IO操作的状态，也不需要主动拷贝数据；</code></pre><p><strong>同步IO、异步IO的区别？</strong></p><pre><code>1.同步IO：导致请求进程阻塞，直到I/O完成，其中阻塞IO、非阻塞IO、IO多路复用都是  同步IO；2.异步IO：不导致请求进程阻塞；</code></pre><p><strong>IO和NIO的区别？</strong></p><pre><code>1.前者面向流的，后者面向缓冲区的；2.前者是阻塞的，后者非阻塞的；    从硬盘读数据，程序一直等着，数据读完以后，继续操作，这叫阻塞IO；    从硬盘读数据，然后程序继续向下执行，等数据读完以后，通知当前程序，    然后此程序立即处理数据，这叫非阻塞IO；3.后者selector单线程处理多个通道；</code></pre><p><strong>Selector的Reactor模型？</strong></p><p><img src="/images/reactor.png" alt=""></p><pre><code>1.Dispatcher：1.1 持有Synchronous Event Demultiplexer对象(理解为Selector对象)和 CHM Handler和ConcreteHandler的映射集合，Handler可以包装成事件，所以CHM也可以表示EventType和EventHandler的映射集合；1.2 内部dispatch方法调用Selector的select方法，若无事件则阻塞，否则获取    事件列表，轮询获取ConcreteHandler来处理每个Handler；2.Selector：内部维护一个阻塞队列，队列为空时，调用select()方法阻塞，不为空返回事件列表；3.Acceptor：内部持有Selector对象，用来接收客户端的连接事件，并添加到selector对象中，之后再通过Dispatcher中具体的ACCEPT EventHandler将事件的状态置为READ；</code></pre><p>单线程的Reactor模式</p><p><img src="/images/reactor1.png" alt=""></p><pre><code>注意：1.单线程是针对所有的I/O操作，例如accept()、read()、write()以及connect（）等  都是在一个线程上完成的；2.可以将非IO操作的业务逻辑从Reactor单线程中卸载，来加速Reactor线程对IO请求的响应；3.不适合高并发、高负载的应用场景；</code></pre><p>多Reactor线程模式</p><p><img src="/images/reactor2.png" alt=""></p><pre><code>注意：1.mainReactor：注册一个Acceptor事件处理器到mainReactor中，监听客户端的ACCEPT事件，并将事件派发给acceptor；2.acceptor：处理器通过调用accept()方法获取客户端的SocketChannel，并将它  传递给subReactor线程池；3.subReactor：负责和客户端通信，可以开多个subReactor线程来处理海量请求；4.所有的I/O操作还是在Reactor线程中完成的；</code></pre><p><strong>select、poll、epoll的区别？</strong></p><p>总结：</p><pre><code>1.select缺点：    1.1 单个进程所打开的fd是有一定数量限制的，32位默认1024，64位默认        2048；    1.2 对socket进行扫描是线性扫描，效率低；    1.3 用户空间和内核空间传递fd数据结构开销大；2.poll优点：    2.1 基于链表存储，没有fd数量限制；缺点：    2.1 用户空间和内核空间传递fd数据结构开销大；    2.2 水平触发，报告了的fd如果未处理，下次poll时会再次报告该poll；3.epoll特点：    3.1 支持水平触发和边缘触发，最大特点在于边缘触发，它只告诉你哪些刚        刚变为就绪，而且只会通知一次。    3.2 使用事件的就绪通知方式，通过epoll_ctl注册fd，一旦fd就绪，内核        会采用类似callback的回调机制来激活该fd，epoll_wait就可以收到        通知；        去掉了遍历文件描述符，而是通过监听回调的机制；优点：    3.1 没有最大并发连接数的限制；    3.2 不是轮询的方式扫描socket，只有活跃的fd才会调用callback函数，        epoll只管活跃的连接，跟连接总数无关；    3.3 使用mmap减少复制开销；</code></pre><p>区别：</p><pre><code>1.支持一个进程所能打开的最大连接数。    select有限，poll和epoll没有限制。2.fd剧增后带来的IO效率问题。    select和poll的&quot;线性下降性能问题&quot;，epoll是根据每个fd上callback函数    来实现的，只有活跃的socket才会主动调用callback。3.消息传递方式。    select和poll中内核需要将消息传递到用户空间，都需要内核拷贝，    epoll通过内核和用户空间共享一块内存实现的；</code></pre><p>select</p><pre><code>//返回值为fd的数量，超时返回0，出错返回-1；//如果timeout=null，select会一直阻塞，直到有描述符就绪；1.int select (int n, fd_set *readfds, fd_set *writefds,  fd_set *exceptfds, struct timeval *timeout)</code></pre><p>poll</p><pre><code>1.int poll (struct pollfd *fds, unsigned int nfds, int timeout);  struct pollfd {    int fd; //文件描述符    short events; //监视的事件    short revents; //返回的事件}</code></pre><p>epoll</p><pre><code>1.    //创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大    //size是内核的建议值    int epoll_create(int size)；    //epfd是epoll_create的返回值、op表示操作EPOLL_CTL_ADD、      EPOLL_CTL_DEL、EPOLL_CTL_MOD    //event告诉内核需要监听什么事件    int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；    //events表示从内核得到事件的集合    //maxevents &lt;= size    int epoll_wait(int epfd, struct epoll_event * events,     int maxevents, int timeout);    struct epoll_event {      //EPOLLIN对fd读      //EPOLLOUT对fd写      //.....      __uint32_t events;       epoll_data_t data;    };</code></pre><p><strong>Selector的基本使用流程？</strong></p><p><img src="/images/selector.JPG" alt=""></p><p><strong>NIO的组件详解</strong></p><ul><li>Buffer</li></ul><p>bufffer示意图</p><p><img src="/images/buffer1.png" alt=""></p><p><img src="/images/buffer.png" alt=""></p><p>buffer的flip方法：</p><pre><code>//buffer的 write模式 切换到 read模式public final Buffer flip() {    limit = position; // 将 limit 设置为实际写入的数据数量    position = 0; // 重置 position 为 0    mark = -1; // mark 之后再说    return this;}</code></pre><p>数据写入读入buffer</p><p><img src="/images/buffer3.JPG" alt=""></p><pre><code>方法一：int bytesdRead = channel.read(buf);//写入buffer                 channel.write(buf);//获取buffer数据方法二：    buf.put();//写入bufferbuf.get();//获取buffer数据</code></pre><ul><li>Channel</li></ul><p>channel示意图</p><p><img src="/images/channel.png" alt=""></p><ul><li>Selector</li></ul><p>SelectionKey的四种事件</p><pre><code>1.OP_READ：值为1，从channel读数据到buffer，channel.read(buf)2.OP_WRITE：值为4，从buffer写数据到channel，channel.write(buf)3.OP_CONNECT：值为8，channel连接事件4.OP_ACCEPT：值为16，server-socket channel 接收另一个连接的接收事件</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;阻塞/非阻塞 和 同步/异步？&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.同步/异步：同步是会阻塞请求进程的，异步不会阻塞请求进程的，所以BIO、NIO
            和IO多路复用都是同步的；


2.阻塞/非阻塞：在等待一件事情的处理
      
    
    </summary>
    
      <category term="面试总结" scheme="http://www.xuchunfa.cn/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
      <category term="操作系统" scheme="http://www.xuchunfa.cn/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>集合源码1</title>
    <link href="http://www.xuchunfa.cn/2019/07/14/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%811/"/>
    <id>http://www.xuchunfa.cn/2019/07/14/集合源码1/</id>
    <published>2019-07-14T08:14:54.000Z</published>
    <updated>2019-07-14T13:09:41.496Z</updated>
    
    <content type="html"><![CDATA[<p><strong>第一部分栈和队列</strong></p><ul><li><p>栈</p><pre><code>栈继承Vector，入栈和出栈都是线程安全的；</code></pre></li></ul><p><strong>push入栈</strong></p><pre><code>默认初始容量10.public E push(E item) {    addElement(item)；    return item;}//vector方法public synchronized void addElement(E obj) {    modCount++;    //elementCount表示插入数组的index，入栈元素放数组最后一位    ensureCapacityHelper(elementCount + 1);    elementData[elementCount++] = obj;}//无需同步private void ensureCapacityHelper(int minCapacity) {    //插入第11个元素时开始扩容    if (minCapacity - elementData.length &gt; 0)        grow(minCapacity);}//第二个参数可以指定扩容大小public Vector(int initialCapacity, int capacityIncrement)；//扩容private void grow(int minCapacity) {    int oldCapacity = elementData.length;    //不指定扩容大小，扩容后的容量是原来的两倍    int newCapacity = oldCapacity +     ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity);    //新容量溢出    if (newCapacity - minCapacity &lt; 0)        newCapacity = minCapacity;    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        //最大容量为Integer.MAX_VALUE        newCapacity = hugeCapacity(minCapacity);    //拷贝原数组元素    elementData = Arrays.copyOf(elementData, newCapacity);}</code></pre><p><strong>push出栈</strong>    </p><pre><code>public synchronized void removeElementAt(int index) {    //要copy的元素个数    int j = elementCount - index - 1;    if (j &gt; 0) {        System.arraycopy(elementData, index + 1, elementData, index, j);    }    elementCount--;    elementData[elementCount] = null;//删除最后一个元素}</code></pre><ul><li><p>队列（基于LinkedList）</p><pre><code>基于链表实现，入队和出队时间复杂度都为O(1).</code></pre></li></ul><p><strong>offer入队</strong></p><pre><code>//LinkedList为例//双向链表void linkLast(E e) {    final Node&lt;E&gt; l = last;    //第一个参数l代表prev指向的节点    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);    last = newNode;    if (l == null)        first = newNode;    else        l.next = newNode;    size++;    modCount++;}</code></pre><p><strong>poll出队</strong>    </p><pre><code>private E unlinkFirst(Node&lt;E&gt; f) {    final E element = f.item;    final Node&lt;E&gt; next = f.next;    f.item = null;    f.next = null;     first = next;    if (next == null)//就一个头节点        last = null;    else        next.prev = null;//头节点的prev=null    size--;    modCount++;    return element;}</code></pre><p><strong>第二部分ArrayList和Vector</strong></p><p>ArrayList和Vector的区别：</p><pre><code>1.前者线性不安全，后者线性安全；2.前者初始数组长度为0，插入第一个元素后扩容为10，后者初始长度为10，插入第  11个元素时发生扩容；3.前者扩容为原来的1.5倍，后者为2倍；</code></pre><ul><li>ArrayList</li></ul><p>源码参照 JDK1.8</p><pre><code>public ArrayList() {    //默认为数组长度为0    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;}</code></pre><p>add()方法</p><pre><code>public boolean add(E e) {    //插入第一个元素就发生扩容    ensureCapacityInternal(size + 1);    elementData[size++] = e;    return true;}private void ensureCapacityInternal(int minCapacity) {    //获取默认初始容量10    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);    }    ensureExplicitCapacity(minCapacity);}private void ensureExplicitCapacity(int minCapacity) {    modCount++;    //10 - 0 &gt; 0 发生第一次扩容    if (minCapacity - elementData.length &gt; 0)        grow(minCapacity);}private void grow(int minCapacity) {    int oldCapacity = elementData.length;    //扩容为原来的1.5倍    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);    //第一次扩容 newCapacity=0 新容量为10    if (newCapacity - minCapacity &lt; 0)        newCapacity = minCapacity;    //取Integer.MAX    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity = hugeCapacity(minCapacity);    elementData = Arrays.copyOf(elementData, newCapacity);}</code></pre><p>remove删除方法</p><pre><code>public E remove(int index) {    //index &gt;= size(index指针) 越界    rangeCheck(index);    modCount++;    E oldValue = elementData(index);    int numMoved = size - index - 1;    if (numMoved &gt; 0)        //第二个参数：srcIndex被复制的起始元素的index        //第四个参数: destIndex目标数组的起始index        System.arraycopy(elementData, index+1, elementData, index,                         numMoved);    elementData[--size] = null;//最后一个元素位置为null    return oldValue;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;第一部分栈和队列&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;栈&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;栈继承Vector，入栈和出栈都是线程安全的；
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;push入栈&lt;/strong&gt;&lt;/p
      
    
    </summary>
    
      <category term="面试总结" scheme="http://www.xuchunfa.cn/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
      <category term="java集合" scheme="http://www.xuchunfa.cn/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/java%E9%9B%86%E5%90%88/"/>
    
    
  </entry>
  
  <entry>
    <title>ThreadLocal详解</title>
    <link href="http://www.xuchunfa.cn/2019/07/04/ThreadLocal%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.xuchunfa.cn/2019/07/04/ThreadLocal详解/</id>
    <published>2019-07-04T12:27:16.000Z</published>
    <updated>2019-07-18T02:05:51.157Z</updated>
    
    <content type="html"><![CDATA[<h4 id="ThreadLocal解析"><a href="#ThreadLocal解析" class="headerlink" title="ThreadLocal解析"></a>ThreadLocal解析</h4><p>1.ThreadLocal？</p><p><img src="/images/threadLocal.png" alt=""></p><pre><code>1.线程的内的局部变量，在每个线程中存储的是变量的副本。2.例如多线程使用同一个Connection对象    public static final ThreadLocal&lt;Conncetion&gt; threadlocal =                         new ThreadLocal&lt;&gt;();</code></pre><p>2.ThreadLocal 的set方法</p><pre><code>//ThreadLocal.javapublic void set(T value) {    // 得到当前线程对象    Thread t = Thread.currentThread();    // 这里获取ThreadLocalMap    ThreadLocalMap map = getMap(t);    // 如果map存在，则将当前线程对象t作为key，要存储的对象作为value存到map里面去    // 例如数据库中的 connection 对象    if (map != null)        map.set(this, value);    else        createMap(t, value);}void createMap(Thread t, T firstValue) {    //key为 ThreadLocal 对象    t.threadLocals = new ThreadLocalMap(this, firstValue);}</code></pre><p>3.ThreadLocal 的get方法</p><pre><code>public T get() {    Thread t = Thread.currentThread();    //每个线程都有个threadLocals成员变量，类型是ThreadLocalMap    ThreadLocalMap map = getMap(t);    if (map != null) {        ThreadLocalMap.Entry e = map.getEntry(this);        if (e != null) {            @SuppressWarnings(&quot;unchecked&quot;)            T result = (T)e.value;            return result;        }    }    //初始化线程的ThreadLocalMap    return setInitialValue();}</code></pre><p>4.ThreadLocal 的remove方法</p><pre><code>public void remove() { ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null)     m.remove(this);//防止内存泄露</code></pre><p> }</p><p>看看ThreadLocalMap</p><pre><code>//ThreadLocal.java//存放数据的地方static class ThreadLocalMap {    static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {        Object value;        Entry(ThreadLocal&lt;?&gt; k, Object v) {            super(k);            value = v;        }    }    //....很长}</code></pre><p>4.ThreadLocalMap的set方法</p><pre><code>for (Entry e = tab[i];     e != null;     e = tab[i = nextIndex(i, len)]) {    ThreadLocal&lt;?&gt; k = e.get();    if (k == key) {        e.value = value;        return;    }    //key已经被回收，清除无效的Entry    if (k == null) {        replaceStaleEntry(key, value, i);        return;    }}</code></pre><p>5.ThreadLocalMap的get方法</p><pre><code>private Entry getEntry(ThreadLocal&lt;?&gt; key) {    int i = key.threadLocalHashCode &amp; (table.length - 1);    Entry e = table[i];    if (e != null &amp;&amp; e.get() == key)        return e;    else        //Hash冲突了使用开放地址法解决        return getEntryAfterMiss(key, i, e);    }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;ThreadLocal解析&quot;&gt;&lt;a href=&quot;#ThreadLocal解析&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal解析&quot;&gt;&lt;/a&gt;ThreadLocal解析&lt;/h4&gt;&lt;p&gt;1.ThreadLocal？&lt;/p&gt;
&lt;p&gt;&lt;img
      
    
    </summary>
    
      <category term="面试总结" scheme="http://www.xuchunfa.cn/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
      <category term="Java并发编程" scheme="http://www.xuchunfa.cn/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>面试总结-Java并发编程2</title>
    <link href="http://www.xuchunfa.cn/2019/06/27/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B2/"/>
    <id>http://www.xuchunfa.cn/2019/06/27/面试总结-Java并发编程2/</id>
    <published>2019-06-27T11:27:30.000Z</published>
    <updated>2019-07-02T07:33:00.842Z</updated>
    
    <content type="html"><![CDATA[<ol><li>volatile作用，如何保证可见性和有序性？    </li></ol><p>参考：</p><p><a href="http://www.xuchunfa.cn/2018/07/24/volatile%E8%AF%AD%E4%B9%89%E5%92%8Cfinal%E8%AF%AD%E4%B9%89%E7%9A%84%E7%90%86%E8%A7%A3/">volatile理解</a></p><p><a href="https://www.itcodemonkey.com/article/1725.html" target="_blank" rel="noopener">小灰漫画volatile</a></p><p>有序性</p><pre><code>通过在volatile变量的操作前后插入内存屏障的方式，来禁止指令重排，进而保证多线程间共享变量的有序性；具体屏障：    1.1 每个volatile写操作前插入StoreStore屏障，写操作之后插入StoreLoad屏障；    1.2 每个volatile读操作前插入LoadLoad屏障，读操作之后插入LoadStore屏障；</code></pre><p>可见性</p><pre><code>1.写入一个volatile变量时，JMM会将线程本地内存的共享变量刷新到主内存；2.读一个volatile变量时，JMM会把线程本地内存中的共享变量置为无效，直接从主存内读取共享变量；</code></pre><p>补充：</p><pre><code>volatile 修饰long和double变量，可以解决64位数据读写操作划分为两次32位的操作产生的非原子性协定问题；可以使long和double的赋值是原子的；</code></pre><p>2.java内存模型？</p><p><img src="/images/内存模型.png" alt=""></p><pre><code>1.JMM是一种规范，为了实现让Java程序在各种平台上达到一致的内存访问结果，并且能让  Java的并发内存访问操作不会出现歧义； 包括了以下内容：    1.主内存和线程本地工作内存的抽象模型；    2.主内存和本地内存的交互操作，8个原子操作；    3.volatile保证可见性和有序性；    4.8条happens-before原则保证内存模型有序性；    5.final保证可见性        5.1 final域写之后插入了storestore屏障，保证了对final域的写入发生在该对象引用被使用之前；        5.2 final域读之前插入了loadload屏障，保证了先读包含final域的引用，再读引用的final域；2.java并发编程中保证原子性、可见性和有序性的方法：    原子性：synchronized保证方法和代码块内的操作是原子性的。    可见性：synchronized、volatile和final关键字；    有序性：synchronized关键字；3.happens-before原则（8个）：    3.1 程序次序规则：单线程内顺序发生；    3.2 锁定规则：unlock操作先于对同一个锁的lock操作；    3.3 volatile规则：对volatile变量的写操作先于读操作；    3.4 传递规则:A先于B，B先于C，则A先于C；    3.5 线程启动规则：Thread对象的start()先于该线程的每一个动作；    3.6 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；    3.7 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；    3.8 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；</code></pre><p>16.为什么ReentrantLock的锁粒度小，synchronized不是也可以用方法块来降低锁粒度?</p><p>17.公平锁和非公平锁的定义，及其优缺点，ReentrantLock和synchronized使用公平还是非公平锁?</p><pre><code>前者默认使用的是非公平锁、后者是非公平锁；公平锁：先到的线程，优先获取到锁；非公平锁：释放锁的时候，同步队列在唤醒的时候，其他线程抢占式获取到锁；非公平锁    优点：吞吐率大；    缺点：阻塞队列中的线程长期处于饥饿状态；</code></pre><p>19.简述线程池原理，FixedThreadPool用的阻塞队列是什么?</p><pre><code>LinkedBlockingQueue</code></pre><p>20.简述AQS，及其核心组件，哪些地方用到AQS，用到什么设计模式？</p><pre><code>1.什么是AQS？    队列同步器。是构建锁或其他同步组件的基础框架，通过使用同步状态变量state    以及FIFO同步队列，来完成资源获取线程的排队工作；ReentrantLock、ReentrantReadWriteLock、CountDownLatch用到了AQS模板方法设计模式：抽象出了很多父类方法，tryAcquire、tryRelease等；</code></pre><p>22.Java内存模型的可见性，原子性，有序性，用什么方法来分别保证这些特性?</p><pre><code>1.Java内存模型中的8中原子操作    lock、unlock、read、load(主内存向工作内存读数据)、use、assign    store、write(工作内存向主内存写数据)2.    synchronized保证原子性、有序性、可见性；    volatile保证了可见性和有序性；</code></pre><p>23.CAS操作，及其可能带来问题和可以怎么解决？</p><pre><code>ABA问题</code></pre><p>24.run和start方法区别或联系？</p><pre><code>1.start()启动线程，真正实现多线程，一旦线程被CPU调度，就会去执行run方法run()方法是一个普通的对象方法；2.start()中的run代码没执行完就可以通过线程切换，执行后面的代码，普通run()方法必须执行完代码后，才能执行主线程中的其他代码；3.start()方法不能重复调用，即线程结束后不能再次调用start()方法，普通run  方法可以重复调用；</code></pre><p>25.如何让几个线程按顺序先后执行？</p><pre><code>1.Join()方法    Thread t1 = new Thread(new Myworker(null))；    Thread t2 = new Thread(new Myworker(t1))；    ....    Myworker{        run(){            //等待上一个线程结束            beforeThread.join();            开始自己的操作；        }    }2.CountDownLatch实现（信号量同理）    cdl1 = new CountDownLatch(0)；    cdl2 = new CountDownLatch(1)；    Mywork(CountDownLatch cdl1,CountDownLatch cdl2){        run(){            cdl1.await();            开始执行自己的操作；            cdl2.countDown();//执行下一个线程        }    }3.FutureTask的get()阻塞4.阻塞队列</code></pre><p>26.ReadWriteLock读写之间互斥吗？</p><pre><code>读写、写读、写写之间都互斥；读读之间不互斥；</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;volatile作用，如何保证可见性和有序性？    &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.xuchunfa.cn/2018/07/24/volatile%E8%AF%AD%E4%B9%89%E5%92%8C
      
    
    </summary>
    
      <category term="面试总结" scheme="http://www.xuchunfa.cn/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
      <category term="Java并发编程" scheme="http://www.xuchunfa.cn/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Socket详解</title>
    <link href="http://www.xuchunfa.cn/2019/06/20/Socket%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.xuchunfa.cn/2019/06/20/Socket详解/</id>
    <published>2019-06-20T11:44:54.000Z</published>
    <updated>2019-06-20T12:44:13.423Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/socket.JPG" alt=""></p><p>Socket服务端：</p><pre><code>public class Server {    private ServerSocket serverSocket = null;    private Socket socket = null;    private DataInputStream input = null;    public Server(int port) {        try {            //绑定端口            serverSocket = new ServerSocket(port);            //获取客户端连接请求            socket = serverSocket.accept();            input = new DataInputStream(new BufferedInputStream(socket.getInputStream()));            String line = &quot;&quot;;            while (!line.equals(&quot;exit&quot;)){                //客户端通过writeUTF()写入数据                line = input.readUTF();                System.out.println(&quot;Server read: &quot;+line);            }            System.out.println(&quot;socket closed.....&quot;);            input.close();            socket.close();        } catch (IOException e) {            e.printStackTrace();        }    }    public static void main(String[] args){        Server server = new Server(6000);    }}</code></pre><p>Client客户端：</p><pre><code>public class Client {    private Socket socket = null;    private DataOutputStream out = null;    private BufferedReader input = null;    public Client(String host,int port) {        try {            //与服务器建立连接            socket = new Socket(host,port);            input = new BufferedReader(new InputStreamReader(System.in));            out = new DataOutputStream(socket.getOutputStream());            String line = &quot;&quot;;            while (!line.equals(&quot;exit&quot;)){                line = input.readLine();                System.out.println(&quot;Client write: &quot;+ line);                out.writeUTF(line);            }        } catch (IOException e) {            e.printStackTrace();        } finally {             try {                    out.close();                    input.close();                    socket.close();                  } catch (Exception e) {                         e.printStackTrace();                  }        }    }    public static void main(String[] args){        Client client = new Client(&quot;localhost&quot;,6000);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/socket.JPG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Socket服务端：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Server {
    private ServerSocket serverSocket = null
      
    
    </summary>
    
      <category term="面试总结" scheme="http://www.xuchunfa.cn/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
      <category term="计算机网络" scheme="http://www.xuchunfa.cn/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>基于Redis的分布式锁</title>
    <link href="http://www.xuchunfa.cn/2019/06/18/%E5%9F%BA%E4%BA%8ERedis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://www.xuchunfa.cn/2019/06/18/基于Redis的分布式锁/</id>
    <published>2019-06-18T06:36:47.000Z</published>
    <updated>2019-06-24T12:06:16.038Z</updated>
    
    <content type="html"><![CDATA[<p><strong>分布式锁的实现方式？</strong></p><pre><code>1.Memcached分布式锁2.Redis分布式锁3.Zookeeper分布式锁4.Chubby</code></pre><p><strong>基于Redis分布式锁的实现方式？</strong></p><p><a href="https://juejin.im/post/5b16148a518825136137c8db" target="_blank" rel="noopener">小灰详解</a></p><p>使用setnx + expire指令</p><pre><code>问题1：    1.setnx指令和expire指令之间的操作是非原子性的，在执行完setnx指令之后，expire指令之前，如果宕机将会产生死锁；解决办法：    使用set命令将setnx和expire命令合并成一个命令；    例如:jedis.set(key,value,&quot;NX&quot;,&quot;EX&quot;,seconds);成功则返回OK;问题2：    1.可能会发生del(key)的误删，假如线程1在还未执行完代码时，锁就已经过期释放锁了，线程2获取到锁开始执行，      执行中线程1执行完开始del(key),此时如果不加处理的话会释放掉线程2的锁；解决办法：    实现LUA脚本比较: 释放锁的线程Id和此时占有锁的线程Id是否相等;问题3：即在问题2中出现了同一时间两个线程访问代码块的情况；解决办法：    让获取到锁的线程开启一个守护线程，当锁要过期但代码还没执行完的时候，守护线程将会延长锁过期的时间，执行完任务后关闭守护线程；</code></pre><p><strong>分布式锁的标准格式？</strong></p><pre><code>boolean isLocked = jedisPoolManager.tryLock(key,seconds)//获取锁if(!isLocked){    return;}try{    //业务逻辑}catch{    //异常处理}finally{    jedisPoolManager.del(key)}</code></pre><p><strong>Bitmap算法？</strong></p><p><img src="/images/bitmap.JPG" alt=""></p><p><a href="https://juejin.im/post/5c4fd2af51882525da267385" target="_blank" rel="noopener">小灰讲解BitMap</a></p><pre><code>Bitmap就是用一个bit位来映射某个元素的value值，key是该元素值；应用：(内存有限)1.40亿个不重复的整数，未排序，给出一个数，快速判断是否存在该群数字中？2.对10亿个不重复的整数进行排序？3.10亿个数字中查找/去除重复的数字？</code></pre><p>思路：</p><pre><code>//N为数据个数bit.length = N/32 + 1;//设置数字bit[]中为1int row = num &gt;&gt; 5bit[row] |= 1 &lt;&lt; (num &amp; 0x1F)//查找数字是否存在，不存在bit置为1，存在则bit保持不变实现去重int row = num &gt;&gt; 5bit[row] &amp; 1 &lt;&lt; (num &amp; 0x1F)//排序for(int i = 0;i &lt; N;i++)    if(isExist(i))        system.out.print(i)</code></pre><p><strong>布隆过滤器？</strong></p><pre><code>用来告诉你某样东西一定不存在或者可能存在；仅仅存储指纹空间(l/n)1.k个hash函数计算出来的hash值，取模位数组，对应下标的值有一个为0，元素不存在；2.如果全为1，可能存在，这些值可能是其他key带来的；</code></pre><p>优点：</p><pre><code>占用空间小，查询效率越高；</code></pre><p>缺点：</p><pre><code>存在误判，删除困难；</code></pre><p>1.基本用法：</p><pre><code>不怎么精确的set结构。bf.add : 添加元素；bf.exist : 查询元素是否存在；</code></pre><p>2.应用场景</p><pre><code>爬虫系统中URL的去重、去除数据库中不存在row的请求来降低数据库磁盘IO请求数量、垃圾邮件的过滤功能、缓存穿透；</code></pre><p>3.基本原理</p><p><img src="/images/bloom.JPG" alt=""></p><p>参数的计算方式;</p><p><img src="/images/bloom1.JPG" alt=""></p><p>其中的参数：</p><pre><code>l : 位数组的长度；n : 添加的元素个数；k : Hash函数的个数；f : 错误率；</code></pre><p><strong>缓存问题？</strong></p><p>1.缓存穿透</p><pre><code>1.1 什么是缓存穿透？    指查询一个一定不存在的数据，后果是直接访问数据库，恶意攻击将使数据库瘫痪；1.2 解决办法？    1.缓存空对象        返回key的null对象到缓存，并设置过期时间。        存在问题：        1.1 key的数量太多影响缓存内存空间，        1.2 设置过期时间会导致Cache层和Storage层数据短期不一致；            例如：Cache层保存了某个key为null之后，Storage层新增了这个key,但是从缓存得到的还是null;    2.Bloom过滤器         将所有可能存在的key放在一个足够大的bitmap中，不存在的key将会被拦截；</code></pre><p>2.缓存雪崩</p><pre><code>2.1 什么是缓存雪崩？    指所有key的缓存时间相同，在同一时间失效，或者缓存服务器宕机，导致所有请求同时访问数据库，从而使系统崩溃；2.2 解决办法？    1.交错失效时间。进行缓存失效时间设置时，在某个基础时间值上加上两秒内的随机数；    2.增加互斥锁。集群环境下使用分布式锁(setnx + expire)，对于每个key，让一个线程构建缓存，其他线程等待，    之后重新从缓存中获取数据；    3.提高缓存的HA。</code></pre><p>3.缓存击穿</p><pre><code>3.1 什么是缓存击穿？    缓存雪崩的一个特例，缓存雪崩是对于全部数据，而缓存击穿是针对热点数据。3.2 解决办法？    1.对于热点数据进行二级缓存，并对于不同级别的缓存设置不同的失效时间。    2.本地缓存（集群不可用时） + 限流（限制请求量）</code></pre><p>4.热点数据集中失效</p><pre><code>4.1 解决办法？    1.设置不同失效时间；    2.互斥锁；</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;分布式锁的实现方式？&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.Memcached分布式锁

2.Redis分布式锁

3.Zookeeper分布式锁

4.Chubby
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;基于Redis分布式锁的实现
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.xuchunfa.cn/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>命令模式</title>
    <link href="http://www.xuchunfa.cn/2019/05/27/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuchunfa.cn/2019/05/27/命令模式/</id>
    <published>2019-05-27T10:19:10.000Z</published>
    <updated>2019-05-29T02:10:13.819Z</updated>
    
    <content type="html"><![CDATA[<p>UML图：</p><p><img src="/images/command.PNG" alt=""></p><p>Command角色：</p><pre><code>public abstract class Command {    protected Receiver receiver;    public Command(Receiver receiver) {        this.receiver = receiver;    }    public void setReceiver(Receiver receiver) {        this.receiver = receiver;    }    abstract void execute();}</code></pre><p>ConcreteCommand角色：</p><pre><code>public class ConcreteCommand extends Command {    public ConcreteCommand(Receiver receiver) {        super(receiver);    }    @Override    public void execute() {        receiver.action();    }}</code></pre><p>Receiver角色：</p><pre><code>public interface Receiver {    void action();}</code></pre><p>ConcreteReceiver角色：</p><pre><code>public class ConcreteReceiver implements Receiver {    @Override    public void action() {        System.out.println(&quot;executing one kind command&quot;);    }}</code></pre><p>Invoker角色：封装命令请求</p><pre><code>public class Invoker {    private Command command;    public Invoker(Command command) {        this.command = command;    }    public void setCommand(Command command) {        this.command = command;    }    public void call(){        command.execute();    }}</code></pre><p>Client角色：</p><pre><code>public static void main(String[] args){    Receiver receiver = new ConcreteReceiver();    Command command = new ConcreteCommand(receiver);    //command.execute();    Invoker invoker = new Invoker(command);    invoker.call();}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;UML图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/command.PNG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Command角色：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public abstract class Command {
    protected Receiv
      
    
    </summary>
    
      <category term="Java设计模式" scheme="http://www.xuchunfa.cn/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>中介者模式</title>
    <link href="http://www.xuchunfa.cn/2019/05/27/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuchunfa.cn/2019/05/27/中介者模式/</id>
    <published>2019-05-27T06:56:22.000Z</published>
    <updated>2019-05-29T02:12:35.210Z</updated>
    
    <content type="html"><![CDATA[<p>UML图：</p><p><img src="/images/mediator.PNG" alt=""></p><p><strong>中介者模式</strong></p><pre><code> 使用一个中介对象来封装一系列的对象交互，使得各对象间不需要显示地相互引用，中介者模式的本质是：封装交互；</code></pre><p>Colleague角色：抽象交互对象</p><pre><code>//持有中介者的引用public abstract class AbstractDatabase {    protected AbstractMediator mediator;    public static final String REDIS = &quot;redis&quot;;    public static final String MYSQL = &quot;mysql&quot;;    public static final String HDFS = &quot;hdfs&quot;;    public AbstractDatabase(AbstractMediator mediator) {        this.mediator = mediator;    }    abstract void addData(String data);}</code></pre><p>ConcreteColleague角色:具体交互对象</p><pre><code>public class RedisDatabase extends AbstractDatabase {    private List&lt;String&gt; redisSet = new ArrayList&lt;&gt;();    public RedisDatabase(AbstractMediator mediator) {        super(mediator);    }    public void synInfo(String data){        System.out.println(&quot;redis data is synchronizing......&quot;);        //交由中介者实现数据同步        mediator.sync(AbstractDatabase.REDIS,data);        System.out.println(&quot;redis data finished synchronize&quot;);    }    @Override    void addData(String data) {        System.out.println(&quot;add data to Redis&quot;);        redisSet.add(data);        synInfo(data);    }    public void redisInfo(){        System.out.println(&quot;stored REDIS data number: &quot;+redisSet.size() + &quot; Info : &quot;+redisSet.toString());    }}MysqlDatabase......HdfsDatabase......</code></pre><p>Mediator角色：抽象中介者</p><pre><code>public abstract class AbstractMediator {    protected RedisDatabase redisDatabase;    protected MysqlDatabase mysqlDatabase;    protected HdfsDatabase hdfsDatabase;    abstract void sync(String database,String data);    public void setRedisDatabase(RedisDatabase redisDatabase) {        this.redisDatabase = redisDatabase;    }    public void setMysqlDatabase(MysqlDatabase mysqlDatabase) {        this.mysqlDatabase = mysqlDatabase;    }    public void setHdfsDatabase(HdfsDatabase hdfsDatabase) {        this.hdfsDatabase = hdfsDatabase;    }}</code></pre><p>ConcreteMediator角色:具体中介者</p><pre><code>//实现 redis 和 mysql 的数据同步到 hdfspublic class SyncMediator extends AbstractMediator {    @Override    void sync(String database, String data) {        if (database.equals(AbstractDatabase.REDIS)) {            hdfsDatabase.addData(data);        } else if (database.equals(AbstractDatabase.MYSQL)) {            hdfsDatabase.addData(data);        }    }}</code></pre><p>Client角色：</p><pre><code> public static void main(String[] args){    AbstractMediator mediator = new SyncMediator();    RedisDatabase redis = new RedisDatabase(mediator);    MysqlDatabase mysql = new MysqlDatabase(mediator);    HdfsDatabase hdfs = new HdfsDatabase(mediator)；    mediator.setRedisDatabase(redis);    mediator.setMysqlDatabase(mysql);    mediator.setMysqlDatabase(hdfs);    redis.addData(&quot;1&quot;);    redis.redisInfo();    mysql.mysqlInfo();    hdfs.hdfsInfo();}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;UML图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/mediator.PNG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中介者模式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 使用一个中介对象来封装一系列的对象交互，使得各对象间不需要显示地相互引用，

      
    
    </summary>
    
      <category term="Java设计模式" scheme="http://www.xuchunfa.cn/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>访问者模式</title>
    <link href="http://www.xuchunfa.cn/2019/05/26/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuchunfa.cn/2019/05/26/访问者模式/</id>
    <published>2019-05-26T08:20:16.000Z</published>
    <updated>2019-05-29T02:07:59.801Z</updated>
    
    <content type="html"><![CDATA[<p>UML图：</p><p><img src="/images/visitor.PNG" alt=""></p><p><strong>访问者模式</strong></p><pre><code>封装一些作用于某种数据结构中的各元素的操作，可以在不改变这个数据结构的前提下定义作用于这些元素的新操作。</code></pre><p>Visitor角色：</p><pre><code>public interface Visitor {    //Engine 和 Wheel 类指那些不易发生变化的数据结构    void visit(Engine engine);    void visit(Wheel wheel);}</code></pre><p>具体访问的行为角色：</p><pre><code>//修理零件public class RepairVisitor implements Visitor {    @Override    public void visit(Engine engine) {        System.out.println(&quot;repairing engine......&quot;);    }    @Override    public void visit(Wheel wheel) {        System.out.println(&quot;repairing wheel......&quot;);    }}</code></pre><p>被访问的角色：</p><pre><code>//通常是那些稳定的数据结构public interface Visitable {    void accept(Visitor visitor);}</code></pre><p>具体被访问的角色：</p><pre><code>public class Engine implements Visitable {    @Override    public void accept(Visitor visitor) {        visitor.visit(this);    }}public class Wheel implements Visitable {    @Override    public void accept(Visitor visitor) {        visitor.visit(this);    }}</code></pre><p>整个对象结构角色：</p><pre><code>public class Car {    private List&lt;Visitable&gt; components = new ArrayList&lt;&gt;();    private Visitor visitor;    public void addComponent(Visitable visitable){        components.add(visitable);    }    public void setVisitor(Visitor visitor) {        this.visitor = visitor;    }    //visitor方式一一访问visitable角色    public void startVisit(){        for(Visitable v : components){            v.accept(visitor);        }    }}</code></pre><p>客户端：</p><pre><code>public static void main(String[] args){    Car car = new Car();    Visitable engine = new Engine();    Visitable wheel = new Wheel();    car.addComponent(engine);//添加被访问的结构    car.addComponent(wheel);    Visitor repair = new RepairVisitor();    car.setVisitor(repair);//设置访问行为    car.startVisit();}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;UML图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/visitor.PNG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;访问者模式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;封装一些作用于某种数据结构中的各元素的操作，可以在不改变这个数据结构的前提下定义
      
    
    </summary>
    
      <category term="Java设计模式" scheme="http://www.xuchunfa.cn/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>责任链模式</title>
    <link href="http://www.xuchunfa.cn/2019/05/26/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuchunfa.cn/2019/05/26/责任链模式/</id>
    <published>2019-05-26T02:53:11.000Z</published>
    <updated>2019-05-29T02:00:40.514Z</updated>
    
    <content type="html"><![CDATA[<p>UML图：</p><p><img src="/images/chain.PNG" alt=""></p><p>特点：</p><pre><code>把请求的传递从子类中剥夺出来了，子类可以专心处理业务逻辑，子类不再需要进行传递的判断；</code></pre><p>问题角色：</p><pre><code>public enum Problem {    STRUCTURE(1), ARCHITECTURE(2);    private int level;    Problem(int  level) {        this.level = level;    }    public int getLevel() {        return level;    }}</code></pre><p>Handler角色：</p><pre><code>public abstract class Handler {    protected int level;//表示问题的级别    private Handler next;    public Handler(int level) {        this.level = level;    }    //责任链的入口    public final void transfer(Problem problem){        if(level == problem.getLevel()){            this.report();        }else if(this.next != null){            this.next.transfer(problem);        }else{            System.out.println(&quot;Final boss can&apos;t resolve the problem&quot;);        }    }    public void setNext(Handler next) {        this.next = next;    }    abstract void report();}</code></pre><p>项目经理角色：</p><pre><code>public class Manager extends Handler {    //项目经理解决structure问题    public Manager() {        super(1);    }    @Override    void report() {        System.out.println(&quot;项目经理解决软件结构布局&quot;);    }}</code></pre><p>架构师角色：</p><pre><code>public class Architect extends Handler {    //架构师解决architecture问题    public Architect() {        super(2);    }    @Override    void report() {        System.out.println(&quot;架构师解决软件架构设计&quot;);    }}</code></pre><p>客户端：</p><pre><code>public static void main(String[] args){    Manager manager = new Manager();    Architect architect = new Architect();    manager.setNext(architect);    manager.transfer(Problem.STRUCTURE);    manager.transfer(Problem.ARCHITECTURE);}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;UML图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/chain.PNG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;把请求的传递从子类中剥夺出来了，子类可以专心处理业务逻辑，子类不再需要进行传递的判断；
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;问
      
    
    </summary>
    
      <category term="Java设计模式" scheme="http://www.xuchunfa.cn/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="http://www.xuchunfa.cn/2019/05/25/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuchunfa.cn/2019/05/25/策略模式/</id>
    <published>2019-05-25T11:24:25.000Z</published>
    <updated>2019-05-29T01:56:41.545Z</updated>
    
    <content type="html"><![CDATA[<p>UML图：</p><p><img src="/images/strategy.PNG" alt=""></p><p>枚举方法实现的策略模式：</p><pre><code>public enum StrategyEnum {    ADD{        @Override        public int calculate(int a, int b) {            return a + b;        }    },    SUBTRACT{        @Override        public int calculate(int a, int b) {            return a - b;        }    };    //抽象方法放后面    public abstract int calculate(int a, int b);}</code></pre><p>Client:</p><pre><code>public static void main(String[] args){    StrategyEnum.ADD.calculate(1,1);    StrategyEnum.SUBTRACT.calculate(1,1);}</code></pre><p>实际应用：</p><pre><code>利用策略模式解决if else 分支过多的情况，项目中使用到了反射和策略模式的方法；</code></pre><p>隶属度计算接口：</p><pre><code>public interface MembershipMath {    double calculate(double attr);}</code></pre><p>不同隶属度计算函数类：</p><pre><code>public class MaxNormal implements MembershipMath {    private double middle;    public MaxNormal() {    }    @Override    public double calculate(double attr) {        DecimalFormat df = new DecimalFormat(&quot;#0.00&quot;);        if(Double.compare(attr,middle) &lt; 0){            return 0;        }else{            return Double.parseDouble(df.format(1 - Math.exp(-Math.pow(attr-middle,2))));        }    }    public double getMiddle() {        return middle;    }    public void setMiddle(double middle) {        this.middle = middle;    }}</code></pre><p>客户端：</p><pre><code>public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException {    String classPath = &quot;neu.cloud.functionpackage.membershipes.impl.MinTrapezoid&quot;;    String minName = &quot;min&quot;;    double min = 1;    String maxName = &quot;max&quot;;    double max = 1;    //获取隶属函数的参数    HashMap&lt;String,Double&gt; fieldMap = new HashMap&lt;&gt;();    fieldMap.put(minName,min);    fieldMap.put(maxName,max);    //全限域名获取隶属函数实例    Class&lt;?&gt; clazz = Class.forName(classPath);    MembershipMath membershipMath = (MembershipMath) clazz.newInstance();    //反射调用真正实例的setMin、setMax、setMiddle方法，来设置参数    invokeSetParams(membershipMath,fieldMap);    System.out.println(membershipMath.calculate(3));}private static void invokeSetParams(MembershipMath membershipMath, HashMap&lt;String, Double&gt; fieldMap) {    Iterator&lt;Map.Entry&lt;String,Double&gt;&gt; params = fieldMap.entrySet().iterator();    while (params.hasNext()){        StringBuilder sb = new StringBuilder();        Map.Entry&lt;String,Double&gt; entry = params.next();        String method = entry.getKey();        String methodName = sb.append(&quot;set&quot;).append(Character.toUpperCase(method.charAt(0))).                append(method.substring(1,method.length())).toString();        double methodValue = entry.getValue();        Method[] methods = membershipMath.getClass().getMethods();        for(Method method1 : methods){            if(method1.getName().equals(methodName)){                try {                    method1.invoke(membershipMath,methodValue);                } catch (IllegalAccessException e) {                    e.printStackTrace();                } catch (InvocationTargetException e) {                    e.printStackTrace();                }            }        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;UML图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/strategy.PNG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;枚举方法实现的策略模式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public enum StrategyEnum {
    ADD{
        @Over
      
    
    </summary>
    
      <category term="Java设计模式" scheme="http://www.xuchunfa.cn/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>享元模式</title>
    <link href="http://www.xuchunfa.cn/2019/05/24/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuchunfa.cn/2019/05/24/享元模式/</id>
    <published>2019-05-24T06:31:10.000Z</published>
    <updated>2019-05-29T01:54:33.199Z</updated>
    
    <content type="html"><![CDATA[<p>UML图：</p><p><img src="/images/flyWeight.PNG" alt=""></p><p><strong>享元模式</strong></p><pre><code>通过共享实现细粒度对象的复用，一般结合单例模式/工厂方法模式获取FlyweightFactory实例；设计享元类时要将内部状态和外部状态分开，通常内部状态作为享元类的成员变量，外部状态通过注入的方式添加到享元类中；</code></pre><p>同名书共享订单实例：</p><pre><code>//抽象享元public interface FlyWeight {    void sell();}//具体享元类public class BookOrder implements FlyWeight {    private String name;    public BookOrder(String name) {        this.name = name;    }    @Override    public void sell() {        System.out.println(&quot;sell a book named by: &quot; + name);    }}//public class FlyWeightFactory {    //饿汉模式线程安全    private static final FlyWeightFactory factory = new FlyWeightFactory();    //享元池    private HashMap&lt;String,FlyWeight&gt; pool = new HashMap&lt;&gt;();    private FlyWeightFactory(){    }    public static FlyWeightFactory getInstance(){        return factory;    }    public FlyWeight addOrder(String bookName){        FlyWeight order = null;        if(pool.containsKey(bookName)){            order = pool.get(bookName);        }else {            order = new BookOrder(bookName);            pool.put(bookName,order);        }        return order;    }    public int getAllOrder(){        return pool.size();    }}</code></pre><p>Client:</p><pre><code>public static void main(String[] args){    List&lt;FlyWeight&gt; orders = new ArrayList&lt;&gt;();    FlyWeightFactory factory = FlyWeightFactory.getInstance();    //一本书生成一个订单对象(同名书共享一个订单对象)    orders.add(factory.addOrder(&quot;红楼梦&quot;));    orders.add(factory.addOrder(&quot;水浒传&quot;));    orders.add(factory.addOrder(&quot;红楼梦&quot;));    //调用享元类接口    for(FlyWeight order : orders){        order.sell();    }    System.out.println(&quot;num of book sold: &quot;+orders.size());    System.out.println(&quot;num of book order: &quot;+factory.getAllOrder());}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;UML图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/flyWeight.PNG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;享元模式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;通过共享实现细粒度对象的复用，一般结合单例模式/工厂方法模式获取Flyweig
      
    
    </summary>
    
      <category term="Java设计模式" scheme="http://www.xuchunfa.cn/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>组合模式</title>
    <link href="http://www.xuchunfa.cn/2019/05/24/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuchunfa.cn/2019/05/24/组合模式/</id>
    <published>2019-05-24T03:41:09.000Z</published>
    <updated>2019-05-29T01:52:47.373Z</updated>
    
    <content type="html"><![CDATA[<p>组合模式安全模式-UML图：</p><p><img src="/images/safeComponent.PNG" alt=""></p><p>组合模式透明模式-UML图：</p><p><img src="/images/transparentComponent.PNG" alt=""></p><p><strong>组合模式</strong></p><pre><code>也叫合成模式，用来描述整体-部分的关系，将对象组合成树形结构，使得用户对单个对象和组合对象的使用具有一致性；</code></pre><p>安全式组合模式实例：</p><pre><code>//叶子和非叶子抽象出来的模板方法public abstract class Component {    protected String name;    abstract void display();}//叶子public class Leaf extends Component {    public Leaf(String name) {        this.name = name;    }    @Override    void display() {        System.out.println(&quot;Name of leaf: &quot; + name);    }}//分支public class Branch extends Component {    public Branch(String name) {        this.name = name;    }    private List&lt;Component&gt; children = new ArrayList&lt;&gt;();    public Component add(Component node){        children.add(node);        return node;    }    public Component remove(Component node){        children.remove(node);        return node;    }    public List&lt;Component&gt; getChildren() {        return children;    }    @Override    void display() {        System.out.println(&quot;Name of branch: &quot; + name);    }}</code></pre><p>Client:</p><pre><code>public static void main(String[] args){    Branch root = new Branch(&quot;root&quot;);    Branch branch = new Branch(&quot;branch1&quot;);    Component leaf1 = new Leaf(&quot;leaf1&quot;);    Component leaf2 = new Leaf(&quot;leaf2&quot;);    root.add(branch);    branch.add(leaf1);    branch.add(leaf2);    root.display();    show(root);}private static void show(Branch root) {    for(Component node : root.getChildren()){        if(node instanceof Leaf){            node.display();        }else {            show((Branch) node);            //或者树枝节点的其他方法            node.display();        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;组合模式安全模式-UML图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/safeComponent.PNG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;组合模式透明模式-UML图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/transparentComponent.PN
      
    
    </summary>
    
      <category term="Java设计模式" scheme="http://www.xuchunfa.cn/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>桥接模式</title>
    <link href="http://www.xuchunfa.cn/2019/05/23/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuchunfa.cn/2019/05/23/桥接模式/</id>
    <published>2019-05-23T13:13:01.000Z</published>
    <updated>2019-05-29T01:47:53.755Z</updated>
    
    <content type="html"><![CDATA[<p>UML图：</p><p><img src="/images/bridge.PNG" alt=""></p><p><strong>桥接模式</strong></p><pre><code>将抽象部分与它的实现部分分离，使它们都可以独立的变化；好处就是减少类的爆炸增长；</code></pre><p>抽象功能角色：</p><pre><code>public abstract class Car {    protected Engine engine;    public void setEngine(Engine engine) {        this.engine = engine;    }    abstract void run();}</code></pre><p>具体功能角色：</p><pre><code>//聚合 Engine public class BenZCar extends Car {    private static final Logger LOG = LoggerFactory.getLogger(BenZCar.class);    @Override    void run() {        engine.gear();        LOG.info(&quot;running by BenZCar......&quot;);    }}</code></pre><p>抽象实现角色：</p><pre><code>public abstract class Engine {    abstract void gear();}</code></pre><p>具体实现角色：</p><pre><code>public class AutoEngine extends Engine {    private static final Logger LOG = LoggerFactory.getLogger(AutoEngine.class);    @Override    void gear() {        LOG.info(&quot;use AutoEngine &quot;);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;UML图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/bridge.PNG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;桥接模式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;将抽象部分与它的实现部分分离，使它们都可以独立的变化；好处就是减少类的爆炸增长；
&lt;
      
    
    </summary>
    
      <category term="Java设计模式" scheme="http://www.xuchunfa.cn/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>外观模式</title>
    <link href="http://www.xuchunfa.cn/2019/05/23/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuchunfa.cn/2019/05/23/外观模式/</id>
    <published>2019-05-23T07:59:06.000Z</published>
    <updated>2019-05-29T01:46:08.288Z</updated>
    
    <content type="html"><![CDATA[<p>UML图：</p><p><img src="/images/facade.PNG" alt=""></p><p><strong>外观模式（门面模式）</strong></p><pre><code>通过外观类将子系统和客户端解耦，为复杂的子系统调用提供一统一的入口；在层次结构中，可以使用外观模式定义系统中每一层的入口，降低层之间的耦合度；</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;UML图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/facade.PNG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;外观模式（门面模式）&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;通过外观类将子系统和客户端解耦，为复杂的子系统调用提供一统一的入口；
在
      
    
    </summary>
    
      <category term="Java设计模式" scheme="http://www.xuchunfa.cn/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>原型模式</title>
    <link href="http://www.xuchunfa.cn/2019/05/21/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuchunfa.cn/2019/05/21/原型模式/</id>
    <published>2019-05-21T12:36:57.000Z</published>
    <updated>2019-05-29T01:29:52.275Z</updated>
    
    <content type="html"><![CDATA[<p>UML图：</p><p><img src="/images/prototype.PNG" alt=""></p><p><strong>原型模式：</strong></p><pre><code>复制原对象，克隆出与原型对象一模一样的对象；</code></pre><p>原型接口：</p><pre><code>public interface Product extends Cloneable{    Object cloneProduct();}</code></pre><p>具体原型：</p><pre><code>public class ProductA implements Product {    @Override    public Object cloneProduct() {        try {            return clone();        } catch (CloneNotSupportedException e) {            e.printStackTrace();        }        return null;    }}</code></pre><p>使用者：</p><pre><code>public class Manager {    private Product product;    public Manager(Product product) {        this.product = product;    }    public Product create(){        return (Product) product.cloneProduct();    }    public static void main(String[] args){        ProductA productA = new ProductA();        Manager manager = new Manager(productA);        Product clonedProductA = manager.create();        System.out.println(productA == clonedProductA);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;UML图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/prototype.PNG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原型模式：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;复制原对象，克隆出与原型对象一模一样的对象；
&lt;/code&gt;&lt;/pre&gt;&lt;p
      
    
    </summary>
    
      <category term="Java设计模式" scheme="http://www.xuchunfa.cn/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>建造者模式</title>
    <link href="http://www.xuchunfa.cn/2019/05/15/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuchunfa.cn/2019/05/15/建造者模式/</id>
    <published>2019-05-15T12:44:57.000Z</published>
    <updated>2019-05-29T01:28:03.500Z</updated>
    
    <content type="html"><![CDATA[<p>UML图：</p><p><img src="/images/builder.PNG" alt=""></p><p><strong>建造者模式</strong></p><pre><code>用户不必知道对象的构建过程和具体实现细节就能创建出复杂的对象，将建造复杂对象的过程和组成对象的部件解耦。</code></pre><p>Builder:</p><pre><code>//构建部件的抽象类或接口public abstract class Builder {    protected HomeStruct struct = new HomeStruct();    abstract void bulidFoundation();    abstract void buildArchitecture();    public HomeStruct finishConstruct(){        return struct;    }}</code></pre><p>ConcreteBuiler:</p><pre><code>//具体部件构建的实现（木屋材料）public class WoodenBuilder extends Builder {    private String material = &quot;wood&quot;;    @Override    public void bulidFoundation() {        System.out.println(&quot;地基使用：&quot; + material);        struct.setFoundation(material);    }    @Override    public void buildArchitecture() {        System.out.println(&quot;架构使用：&quot; + material);        struct.setArchitecture(material);    }    public HomeStruct finishContruct(){        return struct;    }}//水泥材料public class CementBuilder extends Builder {    private String material = &quot;cement&quot;;    @Override    public void bulidFoundation() {        System.out.println(&quot;地基使用：&quot; + material);        struct.setFoundation(material);    }    @Override    public void buildArchitecture() {        System.out.println(&quot;架构使用：&quot; + material);        struct.setArchitecture(material);    }    public HomeStruct finishContruct(){        return struct;    }}</code></pre><p>Director:</p><pre><code>//使用不同材料可以构造不同建筑物public class Director {    private Builder builder;    public Director(Builder builder) {        this.builder = builder;    }    public void construct(){        builder.bulidFoundation();        builder.buildArchitecture();    }}</code></pre><p>测试:</p><pre><code>public class Construction {    @Test    public void test(){        Builder woodenBuilder = new WoodenBuilder();        Director director = new Director(woodenBuilder);        director.construct();        HomeStruct homeStruct = woodenBuilder.finishConstruct();        System.out.println(homeStruct.getFoundation());        System.out.println(homeStruct.getArchitecture());    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;UML图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/builder.PNG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;建造者模式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;用户不必知道对象的构建过程和具体实现细节就能创建出复杂的对象，将建造复杂对象的过
      
    
    </summary>
    
      <category term="Java设计模式" scheme="http://www.xuchunfa.cn/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>抽象工厂模式</title>
    <link href="http://www.xuchunfa.cn/2019/05/13/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuchunfa.cn/2019/05/13/抽象工厂模式/</id>
    <published>2019-05-13T11:51:32.000Z</published>
    <updated>2019-05-27T13:54:13.675Z</updated>
    
    <content type="html"><![CDATA[<p>UML图：</p><p><img src="/images/AbstractFactory.PNG" alt=""></p><p><strong>抽象工厂模式</strong></p><pre><code>工厂类不单单是创建一个对象，而是创建一组对象；</code></pre><p>抽象工厂类：</p><pre><code>public interface PhoneFactory {    HUAWEI produceHW();    XIAOMI produceXM();}</code></pre><p>具体工厂类：</p><pre><code>//生产一代手机的具体工厂public class Phone1Factory implements PhoneFactory {    @Override    public HUAWEI produceHW() {        return new HUAWEI1();    }    @Override    public XIAOMI produceXM() {        return new XIAOMI1();    }}//生产二代手机的具体工厂public class Phone2Factory implements PhoneFactory {    @Override    public HUAWEI produceHW() {        return new HUAWEI2();    }    @Override    public XIAOMI produceXM() {        return new XIAOMI2();    }}</code></pre><p>抽象产品类：</p><pre><code>//产品Apublic interface HUAWEI {    void huaweiInfo();}//产品Bpublic interface XIAOMI {    void xiaomiInfo();}</code></pre><p>具体产品类：</p><pre><code>//产品A1public class HUAWEI1 implements HUAWEI {    @Override    public void huaweiInfo() {        System.out.println(&quot;华为1代&quot;);    }}//产品A2public class HUAWEI2 implements HUAWEI {    @Override    public void huaweiInfo() {        System.out.println(&quot;华为2代&quot;);    }}//产品B1public class XIAOMI1 implements XIAOMI {    @Override    public void xiaomiInfo() {        System.out.println(&quot;小米1代&quot;);    }}//产品B2public class XIAOMI2 implements XIAOMI {    @Override    public void xiaomiInfo() {        System.out.println(&quot;小米2代&quot;);    }}</code></pre><p>测试用例：</p><pre><code>PhoneFactory pf1 = new Phone1Factory();HUAWEI huawei = pf1.produceHW();XIAOMI xiaomi = pf1.produceXM();huawei.huaweiInfo();//华为1代xiaomi.xiaomiInfo();//小米1代</code></pre><p><a href="https://blog.51cto.com/zero01/2070033" target="_blank" rel="noopener">理解工厂方法模式和抽象工厂模式</a></p><h4 id="抽象工厂模式和工厂方法模式的不同处？"><a href="#抽象工厂模式和工厂方法模式的不同处？" class="headerlink" title="抽象工厂模式和工厂方法模式的不同处？"></a>抽象工厂模式和工厂方法模式的不同处？</h4><pre><code>1.抽象工厂是可以生产多个产品的，并且这些产品属于同一系列，工厂方法模式只能生产一个产品；</code></pre><h4 id="抽象工厂模式优点"><a href="#抽象工厂模式优点" class="headerlink" title="抽象工厂模式优点"></a>抽象工厂模式优点</h4><pre><code>1.具体实例的创建过程与客户端分离，客户端通过抽象接口操作实例对象；</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;UML图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/AbstractFactory.PNG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抽象工厂模式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;工厂类不单单是创建一个对象，而是创建一组对象；
&lt;/code&gt;
      
    
    </summary>
    
      <category term="Java设计模式" scheme="http://www.xuchunfa.cn/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式分类与原则</title>
    <link href="http://www.xuchunfa.cn/2019/05/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB%E4%B8%8E%E5%8E%9F%E5%88%99/"/>
    <id>http://www.xuchunfa.cn/2019/05/12/设计模式分类与原则/</id>
    <published>2019-05-12T11:46:55.000Z</published>
    <updated>2019-05-27T12:11:36.518Z</updated>
    
    <content type="html"><![CDATA[<p><strong>设计模式分类</strong></p><ul><li>创建型模式(5种)：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</li></ul><ul><li><p>结构型模式（7种）：适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p></li><li><p>行为模式（11种）：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p></li></ul><p><strong>设计模式功能分类</strong></p><ul><li><p>适应设计模式</p><pre><code>迭代器模式、适配器模式。</code></pre></li><li><p>交给子类</p><pre><code>模板方法模式、工厂方法模式</code></pre></li><li><p>生成实例</p><pre><code>单例模式、原型模式、建造者模式、抽象工厂模式</code></pre></li><li><p>分开考虑</p><pre><code>桥接模式、策略模式</code></pre></li><li><p>一致性（继承某类又持有该类的引用）</p><pre><code>组合模式（持有一组引用）、装饰者模式</code></pre></li><li><p>访问数据结构</p><pre><code>访问者模式、责任链模式</code></pre></li><li><p>简单化</p><pre><code>外观模式、中介者模式（封装交互）</code></pre></li><li><p>管理状态</p><pre><code>观察者模式、备忘录模式、状态模式</code></pre></li><li><p>避免浪费</p><pre><code>享元模式、代理模式</code></pre></li><li><p>用类来表现</p><pre><code>命令模式、解释器模式</code></pre></li></ul><p><strong>设计模式原则</strong></p><ul><li><p>开闭原则：对拓展开放，对修改关闭，多使用接口和抽象类。</p></li><li><p>里氏替换原则</p></li><li><p>依赖倒转原则</p></li><li><p>接口隔离原则：多使用多个隔离的接口，比使用单个接口要好，降低了类与类的耦合性。</p></li><li><p>迪米特原则</p></li><li><p>合成复用原则：尽量多使用合成/聚合方式，而不是继承。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;设计模式分类&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建型模式(5种)：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;结构型模式（7种）：适配器模式、装饰者模式、代理模式、外观模式、桥接模式
      
    
    </summary>
    
      <category term="Java设计模式" scheme="http://www.xuchunfa.cn/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>阻塞队列源码详解</title>
    <link href="http://www.xuchunfa.cn/2019/04/19/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.xuchunfa.cn/2019/04/19/阻塞队列源码详解/</id>
    <published>2019-04-19T07:42:02.000Z</published>
    <updated>2019-04-19T12:34:32.213Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.javadoop.com/post/java-concurrent-queue" target="_blank" rel="noopener">阻塞队列详解</a></p><p>总结：</p><pre><code>1.ArrayBlockingQueue:底层数组，有界队列；2.LinkedBlockingQueue：底层链表，可以当作无界和有界队列使用；3.SynchronousQueue：本身不带有空间存储任何元素，有公平和非公平；4.PriorityBlockingQueue：无界队列，基于数组，数据结构为二叉堆，数组第一个是最小值；</code></pre><h4 id="ArrayBlockingQueue详解"><a href="#ArrayBlockingQueue详解" class="headerlink" title="ArrayBlockingQueue详解"></a>ArrayBlockingQueue详解</h4><p>核心成员变量：</p><pre><code>final Object[] items;int takeIndex;int putIndex;int count;final ReentrantLock lock;private final Condition notEmpty;private final Condition notFull;</code></pre><p>带阻塞插入方法：(offer方法不带阻塞)</p><pre><code>public void put(E e) throws InterruptedException {    checkNotNull(e);//插入元素不允许为null    final ReentrantLock lock = this.lock;    lock.lockInterruptibly();    try {        while (count == items.length)            notFull.await();        enqueue(e);//入队    } finally {        lock.unlock();    }}</code></pre><p>元素入队：</p><pre><code>private void enqueue(E x) {    final Object[] items = this.items;    items[putIndex] = x;    if (++putIndex == items.length)        putIndex = 0;    count++;    notEmpty.signal();//唤醒notEmpty条件队列的头节点}</code></pre><p>带阻塞获取方法：</p><pre><code>public E take() throws InterruptedException {    final ReentrantLock lock = this.lock;    lock.lockInterruptibly();    try {        while (count == 0)            notEmpty.await();        return dequeue();    } finally {        lock.unlock();    }}</code></pre><p>元素出队：</p><pre><code>private E dequeue() {    final Object[] items = this.items;    @SuppressWarnings(&quot;unchecked&quot;)    E x = (E) items[takeIndex];    items[takeIndex] = null;//help GC    if (++takeIndex == items.length)        takeIndex = 0;    count--;    if (itrs != null)        itrs.elementDequeued();    notFull.signal();//唤醒notFull条件队列的头节点    return x;}</code></pre><h4 id="LinkedBlockingQueue详解"><a href="#LinkedBlockingQueue详解" class="headerlink" title="LinkedBlockingQueue详解"></a>LinkedBlockingQueue详解</h4><p>核心变量：</p><pre><code>private final int capacity;//默认Integer.MAXVALUEprivate final AtomicInteger count = new AtomicInteger();//当前队列元素个数transient Node&lt;E&gt; head;private transient Node&lt;E&gt; last;//take、poll方法时加锁private final ReentrantLock takeLock = new ReentrantLock();//offer、offer方法时加锁private final ReentrantLock putLock = new ReentrantLock();private final Condition notEmpty = takeLock.newCondition();private final Condition notFull = putLock.newCondition();</code></pre><p>put方法源码分析：</p><pre><code>public void put(E e) throws InterruptedException {    if (e == null) throw new NullPointerException();    int c = -1;//标识是否成功，-1表示不成功    Node&lt;E&gt; node = new Node&lt;E&gt;(e);    final ReentrantLock putLock = this.putLock;    final AtomicInteger count = this.count;    putLock.lockInterruptibly();    try {        while (count.get() == capacity) {            notFull.await();        }        enqueue(node);        c = count.getAndIncrement();//返回的是旧值        if (c + 1 &lt; capacity)            //还有空间可用，唤醒notFull上的线程，哪些线程            notFull.signal();    } finally {        putLock.unlock();    }    if (c == 0)        signalNotEmpty();//唤醒notEmpty}</code></pre><p>唤醒notEmpty:</p><pre><code> private void signalNotEmpty() {    final ReentrantLock takeLock = this.takeLock;    takeLock.lock();    try {        notEmpty.signal();    } finally {        takeLock.unlock();    }}</code></pre><p>元素入队：</p><pre><code>private void enqueue(Node&lt;E&gt; node) {    last = last.next = node;//初始化时last就不会为空了}</code></pre><p>take方法源码详解：</p><pre><code>public E take() throws InterruptedException {    E x;    int c = -1;    final AtomicInteger count = this.count;    final ReentrantLock takeLock = this.takeLock;    takeLock.lockInterruptibly();    try {        while (count.get() == 0) {            notEmpty.await();        }        x = dequeue();        c = count.getAndDecrement();        if (c &gt; 1)            notEmpty.signal();    } finally {        takeLock.unlock();    }    if (c == capacity)        signalNotFull();//唤醒notFull    return x;}</code></pre><p>元素出队：</p><pre><code>private E dequeue() {    Node&lt;E&gt; h = head;//头节点内容为空    Node&lt;E&gt; first = h.next;    h.next = h; // help GC    head = first;    E x = first.item;    first.item = null;    return x;}</code></pre><h4 id="SynchronousQueue源码解析"><a href="#SynchronousQueue源码解析" class="headerlink" title="SynchronousQueue源码解析"></a>SynchronousQueue源码解析</h4><p>有公平和非公平两种队列：默认非公平</p><pre><code>public SynchronousQueue(boolean fair) {    transferer = fair ? new TransferQueue&lt;E&gt;() : new TransferStack&lt;E&gt;();}</code></pre><p>先看一下TransferQueue的put源码：</p><pre><code>public void put(E e) throws InterruptedException {    if (e == null) throw new NullPointerException();    if (transferer.transfer(e, false, 0) == null) {        Thread.interrupted();        throw new InterruptedException();    }    }</code></pre><p>核心代码：</p><pre><code>E transfer(E e, boolean timed, long nanos) {    QNode s = null;    boolean isData = (e != null);//e != null代表将元素从生产者转移到消费者    for (;;) {        QNode t = tail;        QNode h = head;        if (t == null || h == null)                      continue;                               //队列为空或者当前线程类型和队列中的一致        if (h == t || t.isData == isData) {             QNode tn = t.next;            if (t != tail)                                  continue;            if (tn != null) {                               advanceTail(t, tn);//CAS设置tn为尾节点                continue;            }            if (timed &amp;&amp; nanos &lt;= 0)                        return null;            if (s == null)                s = new QNode(e, isData);            if (!t.casNext(null, s))//节点插入到尾节点                        continue;            advanceTail(t, s);                          Object x = awaitFulfill(s, e, timed, nanos);            if (x == s) {                                   clean(t, s);                return null;            }            if (!s.isOffList()) {                           advanceHead(t, s);                          if (x != null)                                  s.item = s;                s.waiter = null;            }            return (x != null) ? (E)x : e;        } else {//当前线程类型与队列中类型不匹配，读或写相匹配                                       QNode m = h.next;                           if (t != tail || m == null || h != head)                continue;                               Object x = m.item;            if (isData == (x != null) ||                   x == m ||                                   !m.casItem(x, e)) {                         advanceHead(h, m);                         continue;            }            advanceHead(h, m);                          LockSupport.unpark(m.waiter);            return (x != null) ? (E)x : e;        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.javadoop.com/post/java-concurrent-queue&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阻塞队列详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.Array
      
    
    </summary>
    
      <category term="面试总结" scheme="http://www.xuchunfa.cn/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
      <category term="Java并发编程" scheme="http://www.xuchunfa.cn/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
</feed>
