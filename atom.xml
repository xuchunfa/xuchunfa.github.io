<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Flying in the ocean of knowledge</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xuchunfa.cn/"/>
  <updated>2018-08-14T12:42:42.197Z</updated>
  <id>http://www.xuchunfa.cn/</id>
  
  <author>
    <name>Xu chunfa</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java内存区域</title>
    <link href="http://www.xuchunfa.cn/2018/08/14/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <id>http://www.xuchunfa.cn/2018/08/14/java内存区域/</id>
    <published>2018-08-14T08:35:17.000Z</published>
    <updated>2018-08-14T12:42:42.197Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对象创建过程</p></blockquote><p>1.检查类是否已经加载</p><p>2.虚拟机为对象分配内存</p><p>3.将分配到的内存区域初始化</p><blockquote><p>虚拟机常见参数</p></blockquote><p>1.-Xms20M:虚拟机堆内存的最小值</p><p>2.-Xmx20M:虚拟机堆内存的最大值</p><p>3.-Xss1M:每个线程的栈的大小为1M</p><p>4.-Xmn10M:Java Heap Young区的大小为10M</p><p>5.MaxPermSize:方法区最大内存</p><p>6.-XX:PermSize=10M：虚拟机方法区内存最小值</p><p>7.-XX：MaxPermSize=100M:虚拟机方法区内存最大值</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;对象创建过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.检查类是否已经加载&lt;/p&gt;
&lt;p&gt;2.虚拟机为对象分配内存&lt;/p&gt;
&lt;p&gt;3.将分配到的内存区域初始化&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;虚拟机常见参数&lt;/p&gt;
&lt;/blockquo
      
    
    </summary>
    
      <category term="java虚拟机" scheme="http://www.xuchunfa.cn/categories/java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="http://www.xuchunfa.cn/2018/08/14/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://www.xuchunfa.cn/2018/08/14/红黑树/</id>
    <published>2018-08-14T06:14:00.000Z</published>
    <updated>2018-08-14T07:39:04.394Z</updated>
    
    <content type="html"><![CDATA[<h4 id="红黑树的定义？"><a href="#红黑树的定义？" class="headerlink" title="红黑树的定义？"></a>红黑树的定义？</h4><p><img src="https://i.imgur.com/y7nMfe8.jpg" alt=""></p><p>红黑树的特点：</p><p> 1.每个节点不是红色就是黑色的；</p><p> 2.根节点总是黑色的；</p><p> 3.如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</p><p> 4.从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。 </p><p> 5.每个叶子结点(nil)为黑色。</p><h4 id="插入结点后的红黑树调整？"><a href="#插入结点后的红黑树调整？" class="headerlink" title="插入结点后的红黑树调整？"></a>插入结点后的红黑树调整？</h4><p>分以下三种情况：</p><p>1.插入节点的父节点和其叔叔节点（祖父节点的另一个子节点）均为红色的。</p><p>插入结点4：</p><p><img src="https://i.imgur.com/Z864C7i.png" alt=""></p><p><strong>调整：</strong>将当前节点(4)的父节点(5)和叔叔节点(8)涂黑，将祖父节点(7)涂红，变成下图所示的情况。再将当前节点指向其祖父节点(7)。</p><p><img src="https://i.imgur.com/4he7MLS.png" alt=""></p><p>2.插入节点的父节点是红色，叔叔节点是黑色，且插入节点是其父节点的右子节点。</p><p>情况2的示意图为第一步操作的结果。相当于插入当前结点7.</p><p><strong>调整：</strong>将当前节点(7)的父节点(2)作为新的节点，以(2)为支点做左旋(LR)操作.</p><p><img src="https://i.imgur.com/yoP1mMb.png" alt=""></p><p>3.插入节点的父节点是红色，叔叔节点是黑色，且插入节点是其父节点的左子节点。</p><p>情况3的示意图为第二步操作的结果。相当于插入当前结点2.</p><p><strong>调整：</strong>将当前节点的父节点(7)涂黑，将祖父节点(11)涂红，在祖父节点(11)为支点做右旋操作.</p><p><img src="https://i.imgur.com/QYM4k1S.png" alt=""></p><p><strong>总结：</strong>整个完整的流程是从：变色-左旋-右旋。也可能直接从情况2或3开始。</p><p>参考文档一：<a href="https://blog.csdn.net/eson_15/article/details/51144079" target="_blank" rel="noopener">https://blog.csdn.net/eson_15/article/details/51144079</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;红黑树的定义？&quot;&gt;&lt;a href=&quot;#红黑树的定义？&quot; class=&quot;headerlink&quot; title=&quot;红黑树的定义？&quot;&gt;&lt;/a&gt;红黑树的定义？&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/y7nMfe8.jpg&quot; alt=&quot;&quot;&gt;
      
    
    </summary>
    
      <category term="树" scheme="http://www.xuchunfa.cn/categories/%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>平衡二叉树</title>
    <link href="http://www.xuchunfa.cn/2018/08/13/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://www.xuchunfa.cn/2018/08/13/平衡二叉树/</id>
    <published>2018-08-13T13:16:21.000Z</published>
    <updated>2018-08-14T06:06:51.552Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是平衡二叉树（AVL树）？"><a href="#什么是平衡二叉树（AVL树）？" class="headerlink" title="什么是平衡二叉树（AVL树）？"></a>什么是平衡二叉树（AVL树）？</h4><ol><li>可以为空</li><li>任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过1。简单来讲就是任意结点的左右子树的数目基本相同。</li><li>平衡二叉树是二叉查找树的优化，因为二叉查找树适用于无序数据，对于<br>有序数据插入时就是一颗斜树，遍历时的时间复杂度为O(n),已经体现不出了优势了。</li></ol><h4 id="怎么调整平衡二叉树？"><a href="#怎么调整平衡二叉树？" class="headerlink" title="怎么调整平衡二叉树？"></a>怎么调整平衡二叉树？</h4><p>举个LR旋转的例子：</p><p><img src="https://i.imgur.com/jBi58WA.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是平衡二叉树（AVL树）？&quot;&gt;&lt;a href=&quot;#什么是平衡二叉树（AVL树）？&quot; class=&quot;headerlink&quot; title=&quot;什么是平衡二叉树（AVL树）？&quot;&gt;&lt;/a&gt;什么是平衡二叉树（AVL树）？&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;可以为空&lt;/li&gt;
&lt;l
      
    
    </summary>
    
      <category term="树" scheme="http://www.xuchunfa.cn/categories/%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>打印从1到最大的n位数</title>
    <link href="http://www.xuchunfa.cn/2018/08/11/%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/"/>
    <id>http://www.xuchunfa.cn/2018/08/11/打印从1到最大的n位数/</id>
    <published>2018-08-11T12:23:13.000Z</published>
    <updated>2018-08-11T12:36:46.083Z</updated>
    
    <content type="html"><![CDATA[<h4 id="打印从1到最大的n位数？"><a href="#打印从1到最大的n位数？" class="headerlink" title="打印从1到最大的n位数？"></a>打印从1到最大的n位数？</h4><pre><code>public class Print1ToMaxOfNdigits {public static void print1ToMaxOfNdigits(int n){    if(n &lt;= 0){        throw new RuntimeException(&quot;参数非法&quot;);    }    char[] nums = new char[n+1];    nums[n] = &apos;\0&apos;;    for(int i = 0;i&lt;10;i++){        nums[0] = (char) (i + &apos;0&apos;);        everyBigitRecursive(nums,n,0);    }}private static void everyBigitRecursive(char[] nums, int length, int index) {    if(index == length-1){        printNum(nums);        return;    }    for(int i = 0;i&lt;10;i++){        //向个位递进        nums[index + 1] = (char) (i + &apos;0&apos;);        everyBigitRecursive(nums,length,index+1);    }}private static void printNum(char[] nums) {    boolean isBegin0 = true;    for(int i = 0;i &lt; nums.length;i++){        if(isBegin0 &amp;&amp; nums[i] != &apos;0&apos;)            isBegin0 = false;        if(!isBegin0){            System.out.print(nums[i]);        }    }    System.out.println();}public static void main(String[] args){    Print1ToMaxOfNdigits.print1ToMaxOfNdigits(10);}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;打印从1到最大的n位数？&quot;&gt;&lt;a href=&quot;#打印从1到最大的n位数？&quot; class=&quot;headerlink&quot; title=&quot;打印从1到最大的n位数？&quot;&gt;&lt;/a&gt;打印从1到最大的n位数？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public class Print1ToM
      
    
    </summary>
    
      <category term="字符串" scheme="http://www.xuchunfa.cn/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>指数幂运算</title>
    <link href="http://www.xuchunfa.cn/2018/08/11/%E6%8C%87%E6%95%B0%E5%B9%82%E8%BF%90%E7%AE%97/"/>
    <id>http://www.xuchunfa.cn/2018/08/11/指数幂运算/</id>
    <published>2018-08-11T06:58:18.000Z</published>
    <updated>2018-08-11T06:59:54.472Z</updated>
    
    <content type="html"><![CDATA[<h4 id="计算a的n次幂考虑边界情况？"><a href="#计算a的n次幂考虑边界情况？" class="headerlink" title="计算a的n次幂考虑边界情况？"></a>计算a的n次幂考虑边界情况？</h4><pre><code>public class Pow {public static double pow(double base,int exp){    if(Double.doubleToLongBits(base) == Double.doubleToLongBits(0.00) &amp;&amp; exp == 0){        return 0.0;    }    //浮点数的比较    if(Double.doubleToLongBits(base) == Double.doubleToLongBits(0.00) &amp;&amp; exp &lt; 0){        throw new RuntimeException(&quot;参数不合法&quot;);    }    double result;    int absExp;    if(exp &lt; 0){        absExp = -exp;    }else {        absExp = exp;    }    result = calPow(base,absExp);    if(exp &lt; 0){        result = 1.0/result;    }    return result;}private static double calPow(double base, int exp) {    if(exp == 0)        return 1;    if(exp == 1)        return base;    //位移运算代替除法    double result = calPow(base,exp &gt;&gt; 1);    result *= result;    //与运算代替取余    if((exp &amp; 1) == 1){        result *= base;    }    return result;}public static void main(String[] args){    System.out.println(Pow.pow(0,-4));}</code></pre><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;计算a的n次幂考虑边界情况？&quot;&gt;&lt;a href=&quot;#计算a的n次幂考虑边界情况？&quot; class=&quot;headerlink&quot; title=&quot;计算a的n次幂考虑边界情况？&quot;&gt;&lt;/a&gt;计算a的n次幂考虑边界情况？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public class P
      
    
    </summary>
    
      <category term="位运算" scheme="http://www.xuchunfa.cn/categories/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    
  </entry>
  
  <entry>
    <title>背包问题</title>
    <link href="http://www.xuchunfa.cn/2018/08/10/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://www.xuchunfa.cn/2018/08/10/背包问题/</id>
    <published>2018-08-10T08:06:29.000Z</published>
    <updated>2018-08-10T12:38:59.117Z</updated>
    
    <content type="html"><![CDATA[<h4 id="解背包问题？"><a href="#解背包问题？" class="headerlink" title="解背包问题？"></a>解背包问题？</h4><p><img src="http://incdn1.b0.upaiyun.com/2014/09/79f53699ae233c86bd329783ace0a404.png" alt=""></p><p>例如：</p><p>int[] v = {4,2,10,1,2}</p><p>int[] w = {12,1,4,1,2}</p><p>最大价值为：15kg</p><p>c[i][m]:前i个物体放入容量为m的背包的最大价值。</p><p>v[i]:第i个物体的价值。</p><p>w[i]:第i个物体的重量。</p><p>放入第i个物体：<br>c[i][m] = c[i-1][m-w[i]] + v[i]</p><p>不放入第i个物体：<br>c[i][m] = c[i-1][m]</p><blockquote><p>动态规划</p></blockquote><p><img src="https://i.imgur.com/r8NVvQu.png" alt=""></p><pre><code>public class ThiefProblem {static int max(int a, int b) { return (a &gt; b)? a : b; }//基于递归的解法static int knapSack(int W, int wt[], int val[], int n){    if (n == 0 || W == 0)        return 0;    // If weight of the nth item is more than Knapsack capacity W, then    // this item cannot be included in the optimal solution    if (wt[n-1] &gt; W)        return knapSack(W, wt, val, n-1);        // Return the maximum of two cases:        // (1) nth item included        // (2) not included    else return max( val[n-1] + knapSack(W-wt[n-1], wt, val, n-1),            knapSack(W, wt, val, n-1)    );}//基于动态规划的解法static int maxValue(int W, int wt[], int val[], int n){   int[][] itemToValue = new int[n+1][W+1];   for(int i = 0;i&lt;W+1;i++){       itemToValue[0][i] = 0;   }   for(int j = 0;j&lt;n+1;j++){       itemToValue[j][0] = 0;   }   for(int i = 1;i&lt;=n;i++){        for(int j = 1;j&lt;=W;j++){            int weightPlus = j - wt[i-1];            if(weightPlus &lt; 0){                itemToValue[i][j] = itemToValue[i-1][j];            }else {                itemToValue[i][j] = max(itemToValue[i-1][j],itemToValue[i-1][weightPlus]+val[i-1]);            }        }   }   return itemToValue[n][W];}public static void main(String[] args){    int[] value = {6,3,5,4,6};    int[] weight = {2,3,6,5,7};    int maxWeight = 10;    int n = value.length;    //System.out.println(ThiefProblem.maxValue(value,weight,maxWeight));    System.out.println(ThiefProblem.knapSack(maxWeight,weight,value,n));}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;解背包问题？&quot;&gt;&lt;a href=&quot;#解背包问题？&quot; class=&quot;headerlink&quot; title=&quot;解背包问题？&quot;&gt;&lt;/a&gt;解背包问题？&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://incdn1.b0.upaiyun.com/2014/09/79f5369
      
    
    </summary>
    
      <category term="动态规划" scheme="http://www.xuchunfa.cn/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>CAS的理解</title>
    <link href="http://www.xuchunfa.cn/2018/08/09/CAS%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://www.xuchunfa.cn/2018/08/09/CAS的理解/</id>
    <published>2018-08-09T08:01:17.000Z</published>
    <updated>2018-08-09T08:27:18.059Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原子操作类</p></blockquote><ol><li>原子更新基本类型</li><li>原子更新数组类型</li><li>原子更新引用</li><li>原子更新属性</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原子操作类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;原子更新基本类型&lt;/li&gt;
&lt;li&gt;原子更新数组类型&lt;/li&gt;
&lt;li&gt;原子更新引用&lt;/li&gt;
&lt;li&gt;原子更新属性&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
      <category term="Java并发编程" scheme="http://www.xuchunfa.cn/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap的理解</title>
    <link href="http://www.xuchunfa.cn/2018/08/08/ConcurrentHashMap%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://www.xuchunfa.cn/2018/08/08/ConcurrentHashMap的理解/</id>
    <published>2018-08-08T11:47:32.000Z</published>
    <updated>2018-08-09T05:51:20.901Z</updated>
    
    <content type="html"><![CDATA[<p><strong>JDK1.7源码的参数</strong></p><ul><li><p>参数</p><p>  1.DEFAULT_CONCURRENCY_LEVEL：简单看成是segment的个数，即并发度。默认值：16。</p><p>  2.MAX_SEGMENTS：segment的最大个数。值为2^16=65536</p><p>  3.segmentMask:默认值15。</p><p>  4.segmentShift:默认值28。</p></li><li><p>初始化操作</p><p>  1.Segment[i] 为每个段桶的数目(必须为2^n)，默认值为2，负载因子是 0.75，得出初始阈值为 1.5，也就是以后插入第一个元素不会触发扩容，插入第二个会进行第一次扩容。</p><p>  2.</p></li><li><p>定位Segment的散列算法</p><p>  1.(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask：即让hash值的高4位与掩码做与运算。</p></li><li><p>定位HashEntry的散列算法</p><p>  int index = (tab.length - 1) &amp; hash;</p></li></ul><ul><li>Put操作流程</li></ul><p>1.定位到Segment</p><p>2.初始化segment的某一段，ensureSegment(int k)。</p><p>3.获取锁，scanAndLockForPut(key, hash, value);</p><p>5.如果需要的话，进行扩容。segment数组是不能扩容的，扩容的对象是HashEntry数组，该方法不需要考虑并发的，因为此时segment分段锁被独占的。</p><blockquote><p>Segment&lt;K,V&gt;的理解</p></blockquote><p>1.HashEntry&lt;K,V&gt;[] table：每个segment有一个HashEntry数组。</p><p>2.count：</p><p>3.HashEntry&lt;K,V&gt;：一个四元组，next被声明成final,所以每次插入元素都只能头插。node&lt;K,V&gt;的next域呢？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;JDK1.7源码的参数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;参数&lt;/p&gt;
&lt;p&gt;  1.DEFAULT_CONCURRENCY_LEVEL：简单看成是segment的个数，即并发度。默认值：16。&lt;/p&gt;
&lt;p&gt;  2.MAX_SEGMENTS
      
    
    </summary>
    
      <category term="Java并发编程" scheme="http://www.xuchunfa.cn/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>HashMap原理解析</title>
    <link href="http://www.xuchunfa.cn/2018/08/07/HashMap%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>http://www.xuchunfa.cn/2018/08/07/HashMap原理解析/</id>
    <published>2018-08-07T08:01:32.000Z</published>
    <updated>2018-08-14T05:52:51.631Z</updated>
    
    <content type="html"><![CDATA[<h4 id="哈希表的长度为什么要为2-n"><a href="#哈希表的长度为什么要为2-n" class="headerlink" title="哈希表的长度为什么要为2^n?"></a>哈希表的长度为什么要为2^n?</h4><pre><code>因为当哈希表的长度为2^n次方时，hash &amp; (length-1) == hash % length</code></pre><h4 id="查找到哈希表中元素的条件？"><a href="#查找到哈希表中元素的条件？" class="headerlink" title="查找到哈希表中元素的条件？"></a>查找到哈希表中元素的条件？</h4><pre><code>for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next){e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))}//键值包括int和String类型</code></pre><h4 id="HashMap怎么处理key为null元素"><a href="#HashMap怎么处理key为null元素" class="headerlink" title="HashMap怎么处理key为null元素"></a>HashMap怎么处理key为null元素</h4><pre><code>所有key为null的元素放在了table[0]的桶里面了。private V putForNullKey(V value) {    for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) {        if (e.key == null) {            V oldValue = e.value;            e.value = value;            e.recordAccess(this);            return oldValue;        }    }    modCount++;    addEntry(0, null, value, 0);    return null;}</code></pre><h4 id="HashTable和HashMap的区别"><a href="#HashTable和HashMap的区别" class="headerlink" title="HashTable和HashMap的区别"></a>HashTable和HashMap的区别</h4><pre><code>1.前者线程安全的,但是效率低。2.前者的键和值都不允许为空，而后者的key和value都允许为空。</code></pre><blockquote><p>JDK1.8的源码注释总结</p></blockquote><p>1.HashMap允许键和值为空，而且是不同步的，非线程安全的，而HashTable不允许键值为空。</p><p>2.HashMap的两个重要参数：</p><ul><li><p>DEFAULT_INITIAL_CAPACITY:默认的初始容量。默认值16。</p></li><li><p>DEFAULT_LOAD_FACTOR:负载因子，用来衡量哈希表满的程度。默认值0.75。</p></li><li><p>threshold:存放元素的阈值。threshold = capacity * load factor.当key-value对的数量大于threshold，将调用resize()方法。</p></li></ul><p>其他参数：</p><ul><li><p>MAXIMUM_CAPACITY：最大容量。为2^30.</p></li><li><p>TREEIFY_THRESHOLD:链表转化成红黑树的临界值。默认值为8。</p></li><li><p>UNTREEIFY_THRESHOLD：当执行resize操作时，当桶中bin的数量少于UNTREEIFY_THRESHOLD时使用链表来代替树。默认值是6。</p></li><li><p>MIN_TREEIFY_CAPACITY：当桶中的bin被树化时最小的hash表容量。默认值64.</p></li></ul><p><strong>3.把Map元素哈希到桶的索引方法</strong></p><p>1.将key.hashcode() 与 哈希值的高16位作异或运算。</p><pre><code>(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</code></pre><p>2.将1步得到的值进行取模运算(取模哈希桶的长度，长度为2^n)，而方法采用的是高效的与运算。咋证明的呢？？？</p><pre><code>i = (table.length - 1) &amp; hash</code></pre><p>3.jdk1.8中的rehash的理解。</p><p>在确定元素在新数组的下标时，我们只需要检测元素的hash值与oldCap作与操作的结果是否为0：</p><p>为0，那么下标还是原来的下标。</p><p>为1，那么下标等于原来下标加上旧数组长度。</p><pre><code>为0的情况由loHead和loTail这组指针维护。为1的情况由hiHead和hiTail这组指针维护。</code></pre><p>如图所示：<br><img src="https://i.imgur.com/8h4npik.png" alt=""></p><h4 id="源码中方法的理解？"><a href="#源码中方法的理解？" class="headerlink" title="源码中方法的理解？"></a>源码中方法的理解？</h4><p>1.get(Object key)方法：</p><pre><code>public V get(Object key) {    Node&lt;K,V&gt; e;    return (e = getNode(hash(key), key)) == null ? null : e.value;}final Node&lt;K,V&gt; getNode(int hash, Object key) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;        (first = tab[(n - 1) &amp; hash]) != null) {        if (first.hash == hash &amp;&amp; // always check first node            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))//第一个结点就是目标结点，其中key有可能为空            return first;        if ((e = first.next) != null) {//第一个结点排除，继续遍历下一个结点            if (first instanceof TreeNode)//红黑树的查找结点方法                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);//从树的根节点开始查找            do {//从链表的第二个结点开始遍历                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    return e;            } while ((e = e.next) != null);        }    }    return null;//没找到}</code></pre><p><strong>4.JDK1.8以下hashMap线程不安全的原因？</strong></p><p>1.因为扩容后可能会出现结点顺序反掉的情况。</p><p>源码：</p><pre><code>void transfer(Entry[] newTable, boolean rehash) {      int newCapacity = newTable.length;      for (Entry&lt;K,V&gt; e : table) {          while(null != e) {              Entry&lt;K,V&gt; next = e.next;                       if (rehash) {                  e.hash = null == e.key ? 0 : hash(e.key);              }              int i = indexFor(e.hash, newCapacity);               e.next = newTable[i];              newTable[i] = e;              e = next;          }     }  }</code></pre><p>在进行哈希表扩容的时候，如果是多线程的话，则会因为transfer()(采用的头插法)原因，会出现循环链表的情况。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;哈希表的长度为什么要为2-n&quot;&gt;&lt;a href=&quot;#哈希表的长度为什么要为2-n&quot; class=&quot;headerlink&quot; title=&quot;哈希表的长度为什么要为2^n?&quot;&gt;&lt;/a&gt;哈希表的长度为什么要为2^n?&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;因为当哈希表的长度为2^
      
    
    </summary>
    
      <category term="Java并发编程" scheme="http://www.xuchunfa.cn/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>二进制中1的个数</title>
    <link href="http://www.xuchunfa.cn/2018/08/07/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://www.xuchunfa.cn/2018/08/07/二进制中1的个数/</id>
    <published>2018-08-07T05:13:50.000Z</published>
    <updated>2018-08-07T05:14:54.006Z</updated>
    
    <content type="html"><![CDATA[<h4 id="计算二进制中的1的个数？"><a href="#计算二进制中的1的个数？" class="headerlink" title="计算二进制中的1的个数？"></a>计算二进制中的1的个数？</h4><pre><code>public class Count1 {//循环次数为num的位数public static int count2(int num){    int count = 0;    int flag = 1;    while (flag != 0){        if((num &amp; flag) != 0){            count++;        }        flag = flag &lt;&lt; 1;    }    return count;}public static int count1(int num){    int count = 0;    while (num != 0){        num = num &amp; num-1;        count++;    }    return count;}public static void main(String[] args){    System.out.println(Count1.count1(0));}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;计算二进制中的1的个数？&quot;&gt;&lt;a href=&quot;#计算二进制中的1的个数？&quot; class=&quot;headerlink&quot; title=&quot;计算二进制中的1的个数？&quot;&gt;&lt;/a&gt;计算二进制中的1的个数？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public class Count1 {

      
    
    </summary>
    
      <category term="位运算" scheme="http://www.xuchunfa.cn/categories/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="http://www.xuchunfa.cn/2018/08/06/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://www.xuchunfa.cn/2018/08/06/位运算/</id>
    <published>2018-08-06T13:21:30.000Z</published>
    <updated>2018-08-11T06:16:00.025Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>移位实现乘除运算</p></blockquote><p>除2 = 右移1位 乘2 = 左移1位 </p><p>除4 = 右移2位 乘4 = 左移2位 </p><p>除8 = 右移3位 乘8 = 左移3位 </p><blockquote><p>取余运算用位运算与来代替</p></blockquote><p>A % B - A &amp; (B - 1)其中满足 A&gt;0 And B = 2^n</p><p><strong>其中&gt;&gt;&gt;表示：</strong>无符号右移，忽略符号位，空位都以0补齐,在hashMap中有用到。</p><blockquote><p>要注意带符号类型的左右移位</p></blockquote><p>将负值向右移位可生成原始值一半的值（向下舍入）。 例如，-253（二进制 11111111 00000011）向右移动 1 位会生成 -127（二进制 11111111 10000001）。 将 + 253 向右移位生成 +126。</p><p><strong>注：</strong></p><p>1.如果数字是有符号正数，右移n位，则在最左边补n个0;</p><p>2.如果数字是有符号负数，右移n位，则在最左边补n个1;</p><p>3.如果一个数字，左移n位，则在最右边补n个0;</p><blockquote><p>一个数减去一后再与原本的自己做位与运算，得到的结果是将原数二进制中最右边的1变为0</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;移位实现乘除运算&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;除2 = 右移1位 乘2 = 左移1位 &lt;/p&gt;
&lt;p&gt;除4 = 右移2位 乘4 = 左移2位 &lt;/p&gt;
&lt;p&gt;除8 = 右移3位 乘8 = 左移3位 &lt;/p&gt;
&lt;blockquote&gt;

      
    
    </summary>
    
      <category term="位运算" scheme="http://www.xuchunfa.cn/categories/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    
  </entry>
  
  <entry>
    <title>动态规划问题集</title>
    <link href="http://www.xuchunfa.cn/2018/08/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E9%9B%86/"/>
    <id>http://www.xuchunfa.cn/2018/08/06/动态规划问题集/</id>
    <published>2018-08-06T07:26:09.000Z</published>
    <updated>2018-08-06T11:55:05.905Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>动态规划问题的特点</p></blockquote><ul><li><p>大问题可以分解成小问题，每个小问题都存在最优解。</p></li><li><p>整体问题最优解依赖子问题的最优解。</p></li><li><p>小问题之间还会存在相互重叠的更小的问题。</p></li><li><p>从上往下分析问题，从下往上求解问题。</p></li></ul><h4 id="剪绳子把长度为-n-的绳子剪成-m-段-n-gt-1-m-gt-1-所有相乘乘积最小？"><a href="#剪绳子把长度为-n-的绳子剪成-m-段-n-gt-1-m-gt-1-所有相乘乘积最小？" class="headerlink" title="剪绳子把长度为 n 的绳子剪成 m 段(n &gt; 1,m &gt; 1)所有相乘乘积最小？"></a>剪绳子把长度为 n 的绳子剪成 m 段(n &gt; 1,m &gt; 1)所有相乘乘积最小？</h4><pre><code>public class CutStrip {public static int cutStrip(int length){    if(length &lt; 2)        return 0;    if(length == 2)        return 1;    if(length == 3)        return 2;    int[] result = new int[length+1];    result[1] = 1;    result[2] = 2;    result[3] = 3;    for (int i = 4;i&lt;=length;i++){        int max = 0;        for(int j = 1;j&lt;=i/2;j++){            int temp = result[j]*result[i-j];            if(temp &gt; max)                max = temp;        }        result[i] = max;    }    return result[length];}public static void main(String[] args){    System.out.println(CutStrip.cutStrip(10));}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;动态规划问题的特点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;大问题可以分解成小问题，每个小问题都存在最优解。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;整体问题最优解依赖子问题的最优解。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;小问题之间还会
      
    
    </summary>
    
      <category term="动态规划" scheme="http://www.xuchunfa.cn/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>矩阵路径</title>
    <link href="http://www.xuchunfa.cn/2018/08/06/%E7%9F%A9%E9%98%B5%E8%B7%AF%E5%BE%84/"/>
    <id>http://www.xuchunfa.cn/2018/08/06/矩阵路径/</id>
    <published>2018-08-06T05:20:10.000Z</published>
    <updated>2018-08-06T07:13:48.247Z</updated>
    
    <content type="html"><![CDATA[<h4 id="回溯和递归的理解？"><a href="#回溯和递归的理解？" class="headerlink" title="回溯和递归的理解？"></a>回溯和递归的理解？</h4><p>1.如果一个问题的子问题和自身类似，只是规模和条件上发生变化，那么一套代码就可以解决二者，这就是递归。</p><p>2.如果一个问题的解存在于一个可以深度遍历的解空间中，通过深度优先遍历找到解的过程就是回溯 。回溯有的时候可以用递归解决。</p><p>3.回溯法可以通过递归方法列出所有的解空间。解空间还可以用迭代的方法实现。</p><ul><li><p>矩阵路径问题？</p><pre><code>public class MatrixPath {public static boolean hasPath(char[][] a,int rows,int cols,String str){    if(a == null || rows &lt; 1 || cols &lt; 1 || str == null)        throw new RuntimeException(&quot;参数非法&quot;);    boolean[][] visited = new boolean[rows][cols];    int pathLength = 0;    for(int row = 0;row &lt; rows;row++){        for(int col = 0;col &lt; cols;col++){            if(hasOnePath(a,row,col,rows,cols,str,pathLength,visited)){                return true;        }    }}    return false;}private static boolean hasOnePath(char[][] a, int row, int col, int rows, int cols, String str,int pathLength,boolean[][] visited) {    boolean result = false;    if(str.length() == pathLength){        return true;    }    if(row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; cols &amp;&amp; a[row][col] == str.charAt(pathLength) &amp;&amp; !visited[row][col]) {        ++pathLength;        visited[row][col] = true;        result = hasOnePath(a, row - 1, col, rows, cols, str, pathLength, visited) ||            hasOnePath(a, row, col - 1, rows, cols, str, pathLength, visited) ||            hasOnePath(a, row + 1, col, rows, cols, str, pathLength, visited) ||            hasOnePath(a, row, col + 1, rows, cols, str, pathLength, visited);        if (!result) {            --pathLength;            visited[row][col] = false;        }    }    return result;}  public static void main(String[] args){/*char[][] a = {{'a','b','t','g'},                    {'c','f','c','s'},                    {'j','d','e','h'}};*/char[][] a = {{'a'},                      {'f'},                      {'g'},                      {'d'}};String str = &quot;gl&quot;;System.out.println(MatrixPath.hasPath(a,4,1,str));}}</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;回溯和递归的理解？&quot;&gt;&lt;a href=&quot;#回溯和递归的理解？&quot; class=&quot;headerlink&quot; title=&quot;回溯和递归的理解？&quot;&gt;&lt;/a&gt;回溯和递归的理解？&lt;/h4&gt;&lt;p&gt;1.如果一个问题的子问题和自身类似，只是规模和条件上发生变化，那么一套代码就可以解决
      
    
    </summary>
    
      <category term="回溯算法" scheme="http://www.xuchunfa.cn/categories/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Executors详解</title>
    <link href="http://www.xuchunfa.cn/2018/08/05/Executors%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.xuchunfa.cn/2018/08/05/Executors详解/</id>
    <published>2018-08-05T07:24:34.000Z</published>
    <updated>2018-08-06T04:54:47.146Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Excutors框架的类与接口"><a href="#Excutors框架的类与接口" class="headerlink" title="Excutors框架的类与接口"></a>Excutors框架的类与接口</h4><p><img src="https://i.imgur.com/F7UbYhu.png" alt=""></p><h4 id="Executors的作用？"><a href="#Executors的作用？" class="headerlink" title="Executors的作用？"></a>Executors的作用？</h4><p>1.Executor框架的工具类，工厂类,用来生成不同类型的线程池。</p><ul><li><p>FixedThreadPool</p></li><li><p>SingleThreadPool</p></li><li><p>CachedThreadPool</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Excutors框架的类与接口&quot;&gt;&lt;a href=&quot;#Excutors框架的类与接口&quot; class=&quot;headerlink&quot; title=&quot;Excutors框架的类与接口&quot;&gt;&lt;/a&gt;Excutors框架的类与接口&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://
      
    
    </summary>
    
      <category term="Java并发编程" scheme="http://www.xuchunfa.cn/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="http://www.xuchunfa.cn/2018/08/04/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://www.xuchunfa.cn/2018/08/04/线程池/</id>
    <published>2018-08-04T12:12:47.000Z</published>
    <updated>2018-08-05T07:23:29.619Z</updated>
    
    <content type="html"><![CDATA[<h4 id="为什么要使用线程池？"><a href="#为什么要使用线程池？" class="headerlink" title="为什么要使用线程池？"></a>为什么要使用线程池？</h4><p>1.降低资源消耗。重复利用已经创建的线程。因为线程的创建和销毁是需要消耗java虚拟机内存的。</p><p>2.提高响应速度。任务不需要等待线程的创建(当然是在线程池中的线程还没完全被消耗完的情况下)</p><p>3.提高线程的可管理性。</p><h4 id="线程池执行流程？"><a href="#线程池执行流程？" class="headerlink" title="线程池执行流程？"></a>线程池执行流程？</h4><p><img src="https://i.imgur.com/U289xRb.png" alt=""></p><pre><code>public static void start(){    ServerSocket serverSocket = new ServerSocket(port);    Socket socket = null;    while ((socket = serverSocket.accept() != null)){        thread.execute(new HttpRequestHandler(socket));    }}分析：提交的任务将会被线程池里面的线程执行，而不是通过创建新的线程来执行。</code></pre><h4 id="线程池的创建？"><a href="#线程池的创建？" class="headerlink" title="线程池的创建？"></a>线程池的创建？</h4><p><strong>参数：</strong></p><p>1.corePoolSize:线程池中线程的基本数量。</p><p>2.maxinumPoolsize：任务队列满了之后，满足条件：当前线程数 &lt; maxinumPoolsize 又会创建线程。且：<br>当前线程数 + 新创建的线程数 &lt;= maxinumPoolsize</p><p>3.workerQueue:用来存放任务的队列。是通过调用方法execute()来实现的。</p><p>4.keepAliveTime:工作线程空闲时的存活时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;为什么要使用线程池？&quot;&gt;&lt;a href=&quot;#为什么要使用线程池？&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用线程池？&quot;&gt;&lt;/a&gt;为什么要使用线程池？&lt;/h4&gt;&lt;p&gt;1.降低资源消耗。重复利用已经创建的线程。因为线程的创建和销毁是需要消耗ja
      
    
    </summary>
    
      <category term="Java并发编程" scheme="http://www.xuchunfa.cn/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>基数排序</title>
    <link href="http://www.xuchunfa.cn/2018/08/04/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.xuchunfa.cn/2018/08/04/基数排序/</id>
    <published>2018-08-04T06:04:16.000Z</published>
    <updated>2018-08-04T06:29:30.225Z</updated>
    
    <content type="html"><![CDATA[<h4 id="桶的思想？"><a href="#桶的思想？" class="headerlink" title="桶的思想？"></a>桶的思想？</h4><p><img src="https://i.imgur.com/5NeTrG5.png" alt=""></p><pre><code>public class RadixSort {public static void radixSort(int[] a,int k){    int[] counter = new int[10];    int[][] container = new int[10][a.length];    int n = 1;    int t = 0;    while (n &lt; k){        for(int num : a){            int radix = (num/n)%10;            container[radix][counter[radix]] = num;            counter[radix]++;        }        for(int i = 0;i &lt; 10;i++){                if(counter[i] != 0){                    for(int j = 0;j&lt;counter[i];j++){                        a[t] = container[i][j];                        t++;                    }                }            counter[i] = 0;        }        t = 0;        n *= 10;    }}public static void main(String[] args){    int[] a = {1,21,32,45,687,89,43,44,95};    RadixSort.radixSort(a,1000);    System.out.println(Arrays.toString(a));}}</code></pre><p><strong>时间复杂度：</strong></p><pre><code>时间复杂度 = [放桶的时间(O(n)) + 取桶里面的元素(O(n))]*位数     = O(d*n) (d为常数)空间复杂度 = O(n * 10 + 10) = O(n)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;桶的思想？&quot;&gt;&lt;a href=&quot;#桶的思想？&quot; class=&quot;headerlink&quot; title=&quot;桶的思想？&quot;&gt;&lt;/a&gt;桶的思想？&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5NeTrG5.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;pr
      
    
    </summary>
    
      <category term="排序" scheme="http://www.xuchunfa.cn/categories/%E6%8E%92%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>计数排序</title>
    <link href="http://www.xuchunfa.cn/2018/08/04/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.xuchunfa.cn/2018/08/04/计数排序/</id>
    <published>2018-08-04T04:32:23.000Z</published>
    <updated>2018-08-04T04:46:07.709Z</updated>
    
    <content type="html"><![CDATA[<p><strong>核心思想：</strong>哈希表的思想，确定元素在整个数组的排第几来确定它在最终排序数组中的位置。</p><pre><code>public class CountSort {//数组数字在0 ~ k之间public static int[] countSort(int[] a,int k){    int[] elementCounter = new int[k+1];    for(int i = 0;i&lt;a.length;i++){        elementCounter[a[i]]++;    }    //构造计数数组(即小于等于该元素的个数)    int preSum = elementCounter[0];    for(int j = 1;j&lt;elementCounter.length;j++){        elementCounter[j] = preSum + elementCounter[j];        preSum = elementCounter[j];    }    int[] result = new int[a.length];    //从原数组末尾开始遍历    for(int i = a.length-1;i&gt;=0;i--){        result[elementCounter[a[i]]-1] = a[i];        elementCounter[a[i]]--;    }    return result;}public static void main(String[] args){    int[] a = {6,5,4,3,2,1};    int[] result = new int[a.length];    result = CountSort.countSort(a,6);    System.out.println(Arrays.toString(result));}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;核心思想：&lt;/strong&gt;哈希表的思想，确定元素在整个数组的排第几来确定它在最终排序数组中的位置。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class CountSort {

//数组数字在0 ~ k之间
public static int[] co
      
    
    </summary>
    
      <category term="排序" scheme="http://www.xuchunfa.cn/categories/%E6%8E%92%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>希尔排序</title>
    <link href="http://www.xuchunfa.cn/2018/08/03/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.xuchunfa.cn/2018/08/03/希尔排序/</id>
    <published>2018-08-03T06:46:38.000Z</published>
    <updated>2018-08-03T06:49:56.265Z</updated>
    
    <content type="html"><![CDATA[<h4 id="希尔排序示意图"><a href="#希尔排序示意图" class="headerlink" title="希尔排序示意图"></a>希尔排序示意图</h4><p><img src="https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161128110416068-1421707828.png" alt=""></p><pre><code>public class ShellSort {public static void shellSort(int[] a){    for(int increment = a.length/2;increment &gt; 0 ;increment /= 2){        for(int i = increment;i&lt;a.length;i++){            int j = i;            while (j - increment &gt;=0  &amp;&amp; a[j-increment] &gt; a[j]){                //交换排序                swap(a,j,j-increment);                j -= increment;        }        }    }}private static void swap(int[] a, int i, int j) {    int temp = a[i];    a[i] = a[j];    a[j] = temp;}public static void shellSort1(int[] a){    for(int increment = a.length/2;increment &gt; 0 ;increment /= 2){        for(int i = increment;i&lt;a.length;i++){            int j = i;            int temp = a[j];            //直接插入            while(j-increment &gt;= 0 &amp;&amp; a[j-increment] &gt; temp){                a[j] = a[j-increment];                j -= increment;            }            a[j] = temp;        }    }}public static void main(String[] args){    int[] a = {9,8,7,6,5,4,3,2,1};    ShellSort.shellSort1(a);    System.out.println(Arrays.toString(a));}}</code></pre><p>参考文档一：<a href="https://www.cnblogs.com/chengxiao/p/6104371.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6104371.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;希尔排序示意图&quot;&gt;&lt;a href=&quot;#希尔排序示意图&quot; class=&quot;headerlink&quot; title=&quot;希尔排序示意图&quot;&gt;&lt;/a&gt;希尔排序示意图&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/1024
      
    
    </summary>
    
      <category term="排序" scheme="http://www.xuchunfa.cn/categories/%E6%8E%92%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="http://www.xuchunfa.cn/2018/08/02/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.xuchunfa.cn/2018/08/02/归并排序/</id>
    <published>2018-08-02T06:40:42.000Z</published>
    <updated>2018-08-02T08:25:38.669Z</updated>
    
    <content type="html"><![CDATA[<p><strong>什么叫分治思想？</strong></p><p>分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218163120151-452283750.png" alt=""></p><pre><code>public class MergeSort {//临时数组public static void sort(int[] a){    int[] temp = new int[a.length];    mergeSort(a,0,a.length-1,temp);}//治的思想public static void merge(int[] a,int left,int mid,int right,int[] temp){    int i = left;    int j = mid + 1;    int k = 0;    while(i &lt;= mid &amp;&amp; j &lt;= right){        if(a[i] &lt; a[j]){            temp[k++] = a[i++];        }else{            temp[k++] = a[j++];        }    }    while (i &lt;= mid){        temp[k++] = a[i++];    }    while (j &lt;= right){        temp[k++] = a[j++];    }    k = 0;    while (left &lt;= right){        a[left++] = temp[k++];    }}//归并排序public static void mergeSort(int[] a,int left,int right,int[] temp){    if(a == null){        throw new RuntimeException(&quot;输入数组&quot;);    }    if(left &lt; 0 || left &gt;= a.length || right &lt; 0 || right &gt;= a.length ){        throw new RuntimeException(&quot;越界&quot;);    }    if(left &gt;= right)        return;    int mid = (left + right)/2;    //分    mergeSort(a,left,mid,temp);    mergeSort(a,mid+1,right,temp);    //治    merge(a,left,mid,right,temp);}public static void main(String[] args){    int[] a = {6,5,4,4,4,3,2,1};    sort(a);    System.out.println(Arrays.toString(a));}}</code></pre><p>参考文档一：<a href="https://www.cnblogs.com/chengxiao/p/6194356.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6194356.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;什么叫分治思想？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015
      
    
    </summary>
    
      <category term="排序" scheme="http://www.xuchunfa.cn/categories/%E6%8E%92%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>进程和线程分析</title>
    <link href="http://www.xuchunfa.cn/2018/08/02/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.xuchunfa.cn/2018/08/02/进程和线程的区别/</id>
    <published>2018-08-02T05:36:27.000Z</published>
    <updated>2018-08-03T12:40:25.886Z</updated>
    
    <content type="html"><![CDATA[<h4 id="线程中Blocked-和-Waiting-状态的区别？"><a href="#线程中Blocked-和-Waiting-状态的区别？" class="headerlink" title="线程中Blocked 和 Waiting 状态的区别？"></a>线程中Blocked 和 Waiting 状态的区别？</h4><p><strong>Blocked:</strong>线程在等待监视器锁(例如synchronized方法或者块)或者线程在调用过对象的wait()方法后，重新被唤醒时(例如：notify()),此时会进入Blocked状态,试图获得调用对象的锁。</p><p><strong>Waiting:</strong><br>由于主动调用了以下方法而进入的状态：<br>1.Object.wait()<br>2.Thread.join()<br>3.LockSupport.park()</p><p><strong>Time_waiting:</strong><br>调用了以下方法：<br>1.Thread.sleep<br>2.Object.wait(long)<br>3.Thread.join(long)<br>4.LockSupport.parkNanos<br>5.LockSupport.parkUntil</p><h4 id="同步队列和等待队列的区别？"><a href="#同步队列和等待队列的区别？" class="headerlink" title="同步队列和等待队列的区别？"></a>同步队列和等待队列的区别？</h4><p><strong>同步队列：</strong>存放竞争同步资源的线程的引用。</p><p><strong>等待队列：</strong>存放着等待被唤醒的线程的引用。</p><pre><code>等待/通知的经典范式如下：等待方synchronized(对象){    while(条件不满足){        对象.wait()    }    处理逻辑}通知方synchronized(对象){    改变条件    对象.notifyAll()}</code></pre><hr><pre><code>等待超时模式如下：public synchronized Object get(long mills) throw InterruptedException{if(mills &lt;= 0){    while(result == null){        wait();    }     return result;}else{    long future = System.currentTimeMillis() + mills;    long remaining = mills;    while(result == null &amp;&amp; remaining &gt; 0){        wait(remaining);        remaining = future - System.currentTimeMillis();    }    result == null;    if(result != null){        return result;    }    return result;}</code></pre><h4 id="进程和线程的区别？"><a href="#进程和线程的区别？" class="headerlink" title="进程和线程的区别？"></a>进程和线程的区别？</h4><p><strong>进程：</strong>可以看成是每个运行中的程序。它可以拥有自己独立的资源。</p><p><strong>线程：</strong>操作系统调度的最小单元。线程是进程的一个实体，它们可以访问共享的内存变量。</p><p><strong>进程和线程的联系：</strong>一个进程里面可以创建多个线程，每个线程都拥有各自的计数器、堆栈和局部变量等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;线程中Blocked-和-Waiting-状态的区别？&quot;&gt;&lt;a href=&quot;#线程中Blocked-和-Waiting-状态的区别？&quot; class=&quot;headerlink&quot; title=&quot;线程中Blocked 和 Waiting 状态的区别？&quot;&gt;&lt;/a&gt;线程中Bl
      
    
    </summary>
    
      <category term="Java并发编程" scheme="http://www.xuchunfa.cn/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
</feed>
