<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Flying in the ocean of knowledge</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xuchunfa.cn/"/>
  <updated>2018-08-07T05:14:54.006Z</updated>
  <id>http://www.xuchunfa.cn/</id>
  
  <author>
    <name>Xu chunfa</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二进制中1的个数</title>
    <link href="http://www.xuchunfa.cn/2018/08/07/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://www.xuchunfa.cn/2018/08/07/二进制中1的个数/</id>
    <published>2018-08-07T05:13:50.000Z</published>
    <updated>2018-08-07T05:14:54.006Z</updated>
    
    <content type="html"><![CDATA[<h4 id="计算二进制中的1的个数？"><a href="#计算二进制中的1的个数？" class="headerlink" title="计算二进制中的1的个数？"></a>计算二进制中的1的个数？</h4><pre><code>public class Count1 {//循环次数为num的位数public static int count2(int num){    int count = 0;    int flag = 1;    while (flag != 0){        if((num &amp; flag) != 0){            count++;        }        flag = flag &lt;&lt; 1;    }    return count;}public static int count1(int num){    int count = 0;    while (num != 0){        num = num &amp; num-1;        count++;    }    return count;}public static void main(String[] args){    System.out.println(Count1.count1(0));}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;计算二进制中的1的个数？&quot;&gt;&lt;a href=&quot;#计算二进制中的1的个数？&quot; class=&quot;headerlink&quot; title=&quot;计算二进制中的1的个数？&quot;&gt;&lt;/a&gt;计算二进制中的1的个数？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public class Count1 {

      
    
    </summary>
    
      <category term="位运算" scheme="http://www.xuchunfa.cn/categories/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="http://www.xuchunfa.cn/2018/08/06/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://www.xuchunfa.cn/2018/08/06/位运算/</id>
    <published>2018-08-06T13:21:30.000Z</published>
    <updated>2018-08-07T06:19:33.326Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>移位实现乘除运算</p></blockquote><p>除2 = 右移1位 乘2 = 左移1位 </p><p>除4 = 右移2位 乘4 = 左移2位 </p><p>除8 = 右移3位 乘8 = 左移3位 </p><blockquote><p>要注意带符号类型的左右移位</p></blockquote><p>将负值向右移位可生成原始值一半的值（向下舍入）。 例如，-253（二进制 11111111 00000011）向右移动 1 位会生成 -127（二进制 11111111 10000001）。 将 + 253 向右移位生成 +126。</p><p><strong>注：</strong></p><p>1.如果数字是有符号正数，右移n位，则在最左边补n个0;</p><p>2.如果数字是有符号负数，右移n位，则在最左边补n个1;</p><p>3.如果一个数字，左移n位，则在最右边补n个0;</p><blockquote><p>一个数减去一后再与原本的自己做位与运算，得到的结果是将原数二进制中最右边的1变为0</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;移位实现乘除运算&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;除2 = 右移1位 乘2 = 左移1位 &lt;/p&gt;
&lt;p&gt;除4 = 右移2位 乘4 = 左移2位 &lt;/p&gt;
&lt;p&gt;除8 = 右移3位 乘8 = 左移3位 &lt;/p&gt;
&lt;blockquote&gt;

      
    
    </summary>
    
      <category term="位运算" scheme="http://www.xuchunfa.cn/categories/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    
  </entry>
  
  <entry>
    <title>动态规划问题集</title>
    <link href="http://www.xuchunfa.cn/2018/08/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E9%9B%86/"/>
    <id>http://www.xuchunfa.cn/2018/08/06/动态规划问题集/</id>
    <published>2018-08-06T07:26:09.000Z</published>
    <updated>2018-08-06T11:55:05.905Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>动态规划问题的特点</p></blockquote><ul><li><p>大问题可以分解成小问题，每个小问题都存在最优解。</p></li><li><p>整体问题最优解依赖子问题的最优解。</p></li><li><p>小问题之间还会存在相互重叠的更小的问题。</p></li><li><p>从上往下分析问题，从下往上求解问题。</p></li></ul><h4 id="剪绳子把长度为-n-的绳子剪成-m-段-n-gt-1-m-gt-1-所有相乘乘积最小？"><a href="#剪绳子把长度为-n-的绳子剪成-m-段-n-gt-1-m-gt-1-所有相乘乘积最小？" class="headerlink" title="剪绳子把长度为 n 的绳子剪成 m 段(n &gt; 1,m &gt; 1)所有相乘乘积最小？"></a>剪绳子把长度为 n 的绳子剪成 m 段(n &gt; 1,m &gt; 1)所有相乘乘积最小？</h4><pre><code>public class CutStrip {public static int cutStrip(int length){    if(length &lt; 2)        return 0;    if(length == 2)        return 1;    if(length == 3)        return 2;    int[] result = new int[length+1];    result[1] = 1;    result[2] = 2;    result[3] = 3;    for (int i = 4;i&lt;=length;i++){        int max = 0;        for(int j = 1;j&lt;=i/2;j++){            int temp = result[j]*result[i-j];            if(temp &gt; max)                max = temp;        }        result[i] = max;    }    return result[length];}public static void main(String[] args){    System.out.println(CutStrip.cutStrip(10));}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;动态规划问题的特点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;大问题可以分解成小问题，每个小问题都存在最优解。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;整体问题最优解依赖子问题的最优解。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;小问题之间还会
      
    
    </summary>
    
      <category term="动态规划" scheme="http://www.xuchunfa.cn/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>矩阵路径</title>
    <link href="http://www.xuchunfa.cn/2018/08/06/%E7%9F%A9%E9%98%B5%E8%B7%AF%E5%BE%84/"/>
    <id>http://www.xuchunfa.cn/2018/08/06/矩阵路径/</id>
    <published>2018-08-06T05:20:10.000Z</published>
    <updated>2018-08-06T07:13:48.247Z</updated>
    
    <content type="html"><![CDATA[<h4 id="回溯和递归的理解？"><a href="#回溯和递归的理解？" class="headerlink" title="回溯和递归的理解？"></a>回溯和递归的理解？</h4><p>1.如果一个问题的子问题和自身类似，只是规模和条件上发生变化，那么一套代码就可以解决二者，这就是递归。</p><p>2.如果一个问题的解存在于一个可以深度遍历的解空间中，通过深度优先遍历找到解的过程就是回溯 。回溯有的时候可以用递归解决。</p><p>3.回溯法可以通过递归方法列出所有的解空间。解空间还可以用迭代的方法实现。</p><ul><li><p>矩阵路径问题？</p><pre><code>public class MatrixPath {public static boolean hasPath(char[][] a,int rows,int cols,String str){    if(a == null || rows &lt; 1 || cols &lt; 1 || str == null)        throw new RuntimeException(&quot;参数非法&quot;);    boolean[][] visited = new boolean[rows][cols];    int pathLength = 0;    for(int row = 0;row &lt; rows;row++){        for(int col = 0;col &lt; cols;col++){            if(hasOnePath(a,row,col,rows,cols,str,pathLength,visited)){                return true;        }    }}    return false;}private static boolean hasOnePath(char[][] a, int row, int col, int rows, int cols, String str,int pathLength,boolean[][] visited) {    boolean result = false;    if(str.length() == pathLength){        return true;    }    if(row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; cols &amp;&amp; a[row][col] == str.charAt(pathLength) &amp;&amp; !visited[row][col]) {        ++pathLength;        visited[row][col] = true;        result = hasOnePath(a, row - 1, col, rows, cols, str, pathLength, visited) ||            hasOnePath(a, row, col - 1, rows, cols, str, pathLength, visited) ||            hasOnePath(a, row + 1, col, rows, cols, str, pathLength, visited) ||            hasOnePath(a, row, col + 1, rows, cols, str, pathLength, visited);        if (!result) {            --pathLength;            visited[row][col] = false;        }    }    return result;}  public static void main(String[] args){/*char[][] a = {{'a','b','t','g'},                    {'c','f','c','s'},                    {'j','d','e','h'}};*/char[][] a = {{'a'},                      {'f'},                      {'g'},                      {'d'}};String str = &quot;gl&quot;;System.out.println(MatrixPath.hasPath(a,4,1,str));}}</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;回溯和递归的理解？&quot;&gt;&lt;a href=&quot;#回溯和递归的理解？&quot; class=&quot;headerlink&quot; title=&quot;回溯和递归的理解？&quot;&gt;&lt;/a&gt;回溯和递归的理解？&lt;/h4&gt;&lt;p&gt;1.如果一个问题的子问题和自身类似，只是规模和条件上发生变化，那么一套代码就可以解决
      
    
    </summary>
    
      <category term="回溯算法" scheme="http://www.xuchunfa.cn/categories/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Executors详解</title>
    <link href="http://www.xuchunfa.cn/2018/08/05/Executors%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.xuchunfa.cn/2018/08/05/Executors详解/</id>
    <published>2018-08-05T07:24:34.000Z</published>
    <updated>2018-08-06T04:54:47.146Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Excutors框架的类与接口"><a href="#Excutors框架的类与接口" class="headerlink" title="Excutors框架的类与接口"></a>Excutors框架的类与接口</h4><p><img src="https://i.imgur.com/F7UbYhu.png" alt=""></p><h4 id="Executors的作用？"><a href="#Executors的作用？" class="headerlink" title="Executors的作用？"></a>Executors的作用？</h4><p>1.Executor框架的工具类，工厂类,用来生成不同类型的线程池。</p><ul><li><p>FixedThreadPool</p></li><li><p>SingleThreadPool</p></li><li><p>CachedThreadPool</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Excutors框架的类与接口&quot;&gt;&lt;a href=&quot;#Excutors框架的类与接口&quot; class=&quot;headerlink&quot; title=&quot;Excutors框架的类与接口&quot;&gt;&lt;/a&gt;Excutors框架的类与接口&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://
      
    
    </summary>
    
      <category term="Java并发编程" scheme="http://www.xuchunfa.cn/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="http://www.xuchunfa.cn/2018/08/04/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://www.xuchunfa.cn/2018/08/04/线程池/</id>
    <published>2018-08-04T12:12:47.000Z</published>
    <updated>2018-08-05T07:23:29.619Z</updated>
    
    <content type="html"><![CDATA[<h4 id="为什么要使用线程池？"><a href="#为什么要使用线程池？" class="headerlink" title="为什么要使用线程池？"></a>为什么要使用线程池？</h4><p>1.降低资源消耗。重复利用已经创建的线程。因为线程的创建和销毁是需要消耗java虚拟机内存的。</p><p>2.提高响应速度。任务不需要等待线程的创建(当然是在线程池中的线程还没完全被消耗完的情况下)</p><p>3.提高线程的可管理性。</p><h4 id="线程池执行流程？"><a href="#线程池执行流程？" class="headerlink" title="线程池执行流程？"></a>线程池执行流程？</h4><p><img src="https://i.imgur.com/U289xRb.png" alt=""></p><pre><code>public static void start(){    ServerSocket serverSocket = new ServerSocket(port);    Socket socket = null;    while ((socket = serverSocket.accept() != null)){        thread.execute(new HttpRequestHandler(socket));    }}分析：提交的任务将会被线程池里面的线程执行，而不是通过创建新的线程来执行。</code></pre><h4 id="线程池的创建？"><a href="#线程池的创建？" class="headerlink" title="线程池的创建？"></a>线程池的创建？</h4><p><strong>参数：</strong></p><p>1.corePoolSize:线程池中线程的基本数量。</p><p>2.maxinumPoolsize：任务队列满了之后，满足条件：当前线程数 &lt; maxinumPoolsize 又会创建线程。且：<br>当前线程数 + 新创建的线程数 &lt;= maxinumPoolsize</p><p>3.workerQueue:用来存放任务的队列。是通过调用方法execute()来实现的。</p><p>4.keepAliveTime:工作线程空闲时的存活时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;为什么要使用线程池？&quot;&gt;&lt;a href=&quot;#为什么要使用线程池？&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用线程池？&quot;&gt;&lt;/a&gt;为什么要使用线程池？&lt;/h4&gt;&lt;p&gt;1.降低资源消耗。重复利用已经创建的线程。因为线程的创建和销毁是需要消耗ja
      
    
    </summary>
    
      <category term="Java并发编程" scheme="http://www.xuchunfa.cn/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>基数排序</title>
    <link href="http://www.xuchunfa.cn/2018/08/04/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.xuchunfa.cn/2018/08/04/基数排序/</id>
    <published>2018-08-04T06:04:16.000Z</published>
    <updated>2018-08-04T06:29:30.225Z</updated>
    
    <content type="html"><![CDATA[<h4 id="桶的思想？"><a href="#桶的思想？" class="headerlink" title="桶的思想？"></a>桶的思想？</h4><p><img src="https://i.imgur.com/5NeTrG5.png" alt=""></p><pre><code>public class RadixSort {public static void radixSort(int[] a,int k){    int[] counter = new int[10];    int[][] container = new int[10][a.length];    int n = 1;    int t = 0;    while (n &lt; k){        for(int num : a){            int radix = (num/n)%10;            container[radix][counter[radix]] = num;            counter[radix]++;        }        for(int i = 0;i &lt; 10;i++){                if(counter[i] != 0){                    for(int j = 0;j&lt;counter[i];j++){                        a[t] = container[i][j];                        t++;                    }                }            counter[i] = 0;        }        t = 0;        n *= 10;    }}public static void main(String[] args){    int[] a = {1,21,32,45,687,89,43,44,95};    RadixSort.radixSort(a,1000);    System.out.println(Arrays.toString(a));}}</code></pre><p><strong>时间复杂度：</strong></p><pre><code>时间复杂度 = [放桶的时间(O(n)) + 取桶里面的元素(O(n))]*位数     = O(d*n) (d为常数)空间复杂度 = O(n * 10 + 10) = O(n)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;桶的思想？&quot;&gt;&lt;a href=&quot;#桶的思想？&quot; class=&quot;headerlink&quot; title=&quot;桶的思想？&quot;&gt;&lt;/a&gt;桶的思想？&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5NeTrG5.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;pr
      
    
    </summary>
    
      <category term="排序" scheme="http://www.xuchunfa.cn/categories/%E6%8E%92%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>计数排序</title>
    <link href="http://www.xuchunfa.cn/2018/08/04/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.xuchunfa.cn/2018/08/04/计数排序/</id>
    <published>2018-08-04T04:32:23.000Z</published>
    <updated>2018-08-04T04:46:07.709Z</updated>
    
    <content type="html"><![CDATA[<p><strong>核心思想：</strong>哈希表的思想，确定元素在整个数组的排第几来确定它在最终排序数组中的位置。</p><pre><code>public class CountSort {//数组数字在0 ~ k之间public static int[] countSort(int[] a,int k){    int[] elementCounter = new int[k+1];    for(int i = 0;i&lt;a.length;i++){        elementCounter[a[i]]++;    }    //构造计数数组(即小于等于该元素的个数)    int preSum = elementCounter[0];    for(int j = 1;j&lt;elementCounter.length;j++){        elementCounter[j] = preSum + elementCounter[j];        preSum = elementCounter[j];    }    int[] result = new int[a.length];    //从原数组末尾开始遍历    for(int i = a.length-1;i&gt;=0;i--){        result[elementCounter[a[i]]-1] = a[i];        elementCounter[a[i]]--;    }    return result;}public static void main(String[] args){    int[] a = {6,5,4,3,2,1};    int[] result = new int[a.length];    result = CountSort.countSort(a,6);    System.out.println(Arrays.toString(result));}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;核心思想：&lt;/strong&gt;哈希表的思想，确定元素在整个数组的排第几来确定它在最终排序数组中的位置。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class CountSort {

//数组数字在0 ~ k之间
public static int[] co
      
    
    </summary>
    
      <category term="排序" scheme="http://www.xuchunfa.cn/categories/%E6%8E%92%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>希尔排序</title>
    <link href="http://www.xuchunfa.cn/2018/08/03/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.xuchunfa.cn/2018/08/03/希尔排序/</id>
    <published>2018-08-03T06:46:38.000Z</published>
    <updated>2018-08-03T06:49:56.265Z</updated>
    
    <content type="html"><![CDATA[<h4 id="希尔排序示意图"><a href="#希尔排序示意图" class="headerlink" title="希尔排序示意图"></a>希尔排序示意图</h4><p><img src="https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161128110416068-1421707828.png" alt=""></p><pre><code>public class ShellSort {public static void shellSort(int[] a){    for(int increment = a.length/2;increment &gt; 0 ;increment /= 2){        for(int i = increment;i&lt;a.length;i++){            int j = i;            while (j - increment &gt;=0  &amp;&amp; a[j-increment] &gt; a[j]){                //交换排序                swap(a,j,j-increment);                j -= increment;        }        }    }}private static void swap(int[] a, int i, int j) {    int temp = a[i];    a[i] = a[j];    a[j] = temp;}public static void shellSort1(int[] a){    for(int increment = a.length/2;increment &gt; 0 ;increment /= 2){        for(int i = increment;i&lt;a.length;i++){            int j = i;            int temp = a[j];            //直接插入            while(j-increment &gt;= 0 &amp;&amp; a[j-increment] &gt; temp){                a[j] = a[j-increment];                j -= increment;            }            a[j] = temp;        }    }}public static void main(String[] args){    int[] a = {9,8,7,6,5,4,3,2,1};    ShellSort.shellSort1(a);    System.out.println(Arrays.toString(a));}}</code></pre><p>参考文档一：<a href="https://www.cnblogs.com/chengxiao/p/6104371.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6104371.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;希尔排序示意图&quot;&gt;&lt;a href=&quot;#希尔排序示意图&quot; class=&quot;headerlink&quot; title=&quot;希尔排序示意图&quot;&gt;&lt;/a&gt;希尔排序示意图&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/1024
      
    
    </summary>
    
      <category term="排序" scheme="http://www.xuchunfa.cn/categories/%E6%8E%92%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="http://www.xuchunfa.cn/2018/08/02/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.xuchunfa.cn/2018/08/02/归并排序/</id>
    <published>2018-08-02T06:40:42.000Z</published>
    <updated>2018-08-02T08:25:38.669Z</updated>
    
    <content type="html"><![CDATA[<p><strong>什么叫分治思想？</strong></p><p>分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218163120151-452283750.png" alt=""></p><pre><code>public class MergeSort {//临时数组public static void sort(int[] a){    int[] temp = new int[a.length];    mergeSort(a,0,a.length-1,temp);}//治的思想public static void merge(int[] a,int left,int mid,int right,int[] temp){    int i = left;    int j = mid + 1;    int k = 0;    while(i &lt;= mid &amp;&amp; j &lt;= right){        if(a[i] &lt; a[j]){            temp[k++] = a[i++];        }else{            temp[k++] = a[j++];        }    }    while (i &lt;= mid){        temp[k++] = a[i++];    }    while (j &lt;= right){        temp[k++] = a[j++];    }    k = 0;    while (left &lt;= right){        a[left++] = temp[k++];    }}//归并排序public static void mergeSort(int[] a,int left,int right,int[] temp){    if(a == null){        throw new RuntimeException(&quot;输入数组&quot;);    }    if(left &lt; 0 || left &gt;= a.length || right &lt; 0 || right &gt;= a.length ){        throw new RuntimeException(&quot;越界&quot;);    }    if(left &gt;= right)        return;    int mid = (left + right)/2;    //分    mergeSort(a,left,mid,temp);    mergeSort(a,mid+1,right,temp);    //治    merge(a,left,mid,right,temp);}public static void main(String[] args){    int[] a = {6,5,4,4,4,3,2,1};    sort(a);    System.out.println(Arrays.toString(a));}}</code></pre><p>参考文档一：<a href="https://www.cnblogs.com/chengxiao/p/6194356.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6194356.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;什么叫分治思想？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015
      
    
    </summary>
    
      <category term="排序" scheme="http://www.xuchunfa.cn/categories/%E6%8E%92%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>进程和线程分析</title>
    <link href="http://www.xuchunfa.cn/2018/08/02/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.xuchunfa.cn/2018/08/02/进程和线程的区别/</id>
    <published>2018-08-02T05:36:27.000Z</published>
    <updated>2018-08-03T12:40:25.886Z</updated>
    
    <content type="html"><![CDATA[<h4 id="线程中Blocked-和-Waiting-状态的区别？"><a href="#线程中Blocked-和-Waiting-状态的区别？" class="headerlink" title="线程中Blocked 和 Waiting 状态的区别？"></a>线程中Blocked 和 Waiting 状态的区别？</h4><p><strong>Blocked:</strong>线程在等待监视器锁(例如synchronized方法或者块)或者线程在调用过对象的wait()方法后，重新被唤醒时(例如：notify()),此时会进入Blocked状态,试图获得调用对象的锁。</p><p><strong>Waiting:</strong><br>由于主动调用了以下方法而进入的状态：<br>1.Object.wait()<br>2.Thread.join()<br>3.LockSupport.park()</p><p><strong>Time_waiting:</strong><br>调用了以下方法：<br>1.Thread.sleep<br>2.Object.wait(long)<br>3.Thread.join(long)<br>4.LockSupport.parkNanos<br>5.LockSupport.parkUntil</p><h4 id="同步队列和等待队列的区别？"><a href="#同步队列和等待队列的区别？" class="headerlink" title="同步队列和等待队列的区别？"></a>同步队列和等待队列的区别？</h4><p><strong>同步队列：</strong>存放竞争同步资源的线程的引用。</p><p><strong>等待队列：</strong>存放着等待被唤醒的线程的引用。</p><pre><code>等待/通知的经典范式如下：等待方synchronized(对象){    while(条件不满足){        对象.wait()    }    处理逻辑}通知方synchronized(对象){    改变条件    对象.notifyAll()}</code></pre><hr><pre><code>等待超时模式如下：public synchronized Object get(long mills) throw InterruptedException{if(mills &lt;= 0){    while(result == null){        wait();    }     return result;}else{    long future = System.currentTimeMillis() + mills;    long remaining = mills;    while(result == null &amp;&amp; remaining &gt; 0){        wait(remaining);        remaining = future - System.currentTimeMillis();    }    result == null;    if(result != null){        return result;    }    return result;}</code></pre><h4 id="进程和线程的区别？"><a href="#进程和线程的区别？" class="headerlink" title="进程和线程的区别？"></a>进程和线程的区别？</h4><p><strong>进程：</strong>可以看成是每个运行中的程序。它可以拥有自己独立的资源。</p><p><strong>线程：</strong>操作系统调度的最小单元。线程是进程的一个实体，它们可以访问共享的内存变量。</p><p><strong>进程和线程的联系：</strong>一个进程里面可以创建多个线程，每个线程都拥有各自的计数器、堆栈和局部变量等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;线程中Blocked-和-Waiting-状态的区别？&quot;&gt;&lt;a href=&quot;#线程中Blocked-和-Waiting-状态的区别？&quot; class=&quot;headerlink&quot; title=&quot;线程中Blocked 和 Waiting 状态的区别？&quot;&gt;&lt;/a&gt;线程中Bl
      
    
    </summary>
    
      <category term="Java并发编程" scheme="http://www.xuchunfa.cn/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="http://www.xuchunfa.cn/2018/07/29/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.xuchunfa.cn/2018/07/29/堆排序/</id>
    <published>2018-07-29T10:33:19.000Z</published>
    <updated>2018-07-29T15:14:08.962Z</updated>
    
    <content type="html"><![CDATA[<h4 id="堆排序？"><a href="#堆排序？" class="headerlink" title="堆排序？"></a>堆排序？</h4><pre><code>public class HeapSort {public static void heapSort(int[] a){    if(a == null){        throw new RuntimeException(&quot;输入数组&quot;);    }    int len = a.length;    //构建大顶堆    for(int i = len/2-1;i&gt;=0;i--){        createHeap(a,i,len);    }    for(int j = a.length-1;j&gt;0;j--){        swap(a,0,j);        createHeap(a,0,j);    }}private static void swap(int[] a, int i, int j) {    int temp = a[i];    a[i] = a[j];    a[j] = temp;}private static void createHeap(int[] a,int i,int len) {    int father = a[i];    int j;//j代表子结点坐标 i代表父结点坐标    while(2*i + 1 &lt; len){        j = 2*i + 1;        if(j + 1 &lt; len &amp;&amp; a[j] &lt; a[j+1] )            j++;        if(a[j] &gt; father){            a[i] = a[j];            i = j;        }else {            break;        }    }    //找到最终位置    a[i] = father;}public static void main(String[] args){    int[] a = {1,1,1};    HeapSort.heapSort(a);    System.out.println(Arrays.toString(a));}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;堆排序？&quot;&gt;&lt;a href=&quot;#堆排序？&quot; class=&quot;headerlink&quot; title=&quot;堆排序？&quot;&gt;&lt;/a&gt;堆排序？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public class HeapSort {

public static void heapSort(i
      
    
    </summary>
    
      <category term="排序" scheme="http://www.xuchunfa.cn/categories/%E6%8E%92%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>直接插入排序</title>
    <link href="http://www.xuchunfa.cn/2018/07/29/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.xuchunfa.cn/2018/07/29/直接插入排序/</id>
    <published>2018-07-29T10:30:34.000Z</published>
    <updated>2018-07-29T10:33:02.808Z</updated>
    
    <content type="html"><![CDATA[<h4 id="直接插入排序？"><a href="#直接插入排序？" class="headerlink" title="直接插入排序？"></a>直接插入排序？</h4><pre><code>public class InsertSort {public static void insert(int[] a){    if(a == null){        throw new RuntimeException(&quot;输入数组&quot;);    }    if(a.length &lt;= 1){        return;    }    for(int j = 1;j&lt;a.length;j++){        int temp = a[j];        int i;        for(i = j-1;i&gt;=0 &amp;&amp; a[i]&gt;temp;i--){            a[i+1] = a[i];        }        //不满足上面for循环的话,元素不动        a[i+1] = temp;    }}public static void main(String[] args){    int[] a = {4,2,2,2,1,5,7,6};    InsertSort.insert(a);    System.out.println(Arrays.toString(a));}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;直接插入排序？&quot;&gt;&lt;a href=&quot;#直接插入排序？&quot; class=&quot;headerlink&quot; title=&quot;直接插入排序？&quot;&gt;&lt;/a&gt;直接插入排序？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public class InsertSort {

public static v
      
    
    </summary>
    
      <category term="排序" scheme="http://www.xuchunfa.cn/categories/%E6%8E%92%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>旋转数组中的最小值</title>
    <link href="http://www.xuchunfa.cn/2018/07/28/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
    <id>http://www.xuchunfa.cn/2018/07/28/旋转数组中的最小值/</id>
    <published>2018-07-28T13:37:21.000Z</published>
    <updated>2018-07-28T13:40:56.221Z</updated>
    
    <content type="html"><![CDATA[<h4 id="找出递增数组旋转后的最小值？"><a href="#找出递增数组旋转后的最小值？" class="headerlink" title="找出递增数组旋转后的最小值？"></a>找出递增数组旋转后的最小值？</h4><pre><code>public class RotateArray {//如果把排序数组的前0个元素搬到最后面,算法得不到正确结果public static int minElement2(int[] a){    if(a == null){        throw new RuntimeException(&quot;输入数组&quot;);    }    if(a.length == 0){        throw new RuntimeException(&quot;数组为空&quot;);    }    int low = 0;    int high = a.length-1;    int media;    while (low &lt; high){        if(high == low + 1){            return a[high];        }        media = (low + high)/2;        if(a[media] &gt;= a[low]){            low = media;        }else if(a[media] &lt;= a[high]){            high = media;        }    }    return a[high];}//解决了a = {1,2,3} 的问题public static int minElement1(int[] a){    if(a == null){        throw new RuntimeException(&quot;输入数组&quot;);    }    if(a.length == 0){        throw new RuntimeException(&quot;数组为空&quot;);    }    int low = 0;    int high = a.length-1;    int media = low;    while (a[low] &gt;= a[high]){        if(high == low + 1){            media = high;            break;        }        media = (low + high)/2;        if(a[media] &gt;= a[low]){            low = media;        }else if(a[media] &lt;= a[high]){            high = media;        }    }    return a[media];}//解决了 a = {0,1,1,1,1} --&gt; {1,0,1,1,1}的情况public static int minElement(int[] a){    if(a == null){        throw new RuntimeException(&quot;输入数组&quot;);    }    if(a.length == 0){        throw new RuntimeException(&quot;数组为空&quot;);    }    int low = 0;    int high = a.length-1;    int media = low;    while (a[low] &gt;= a[high]){        if(high == low + 1){            media = high;            break;        }        media = (low + high)/2;        //顺序查找        if(a[low] == a[high] &amp;&amp; a[low] == a[media]){            return fromBeginToEnd(a,low,high);        }        if(a[media] &gt;= a[low]){            low = media;        }else if(a[media] &lt;= a[high]){            high = media;        }    }    return a[media];}private static int fromBeginToEnd(int[] a,int start,int end) {    int min = a[start];    for(int i = start;i&lt;end;i++){        if(a[i] &lt; min){            min = a[i];        }    }    return min;}public static void main(String[] args){    int[] a = {1,1,1,0,1};    System.out.println(RotateArray.minElement(a));}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;找出递增数组旋转后的最小值？&quot;&gt;&lt;a href=&quot;#找出递增数组旋转后的最小值？&quot; class=&quot;headerlink&quot; title=&quot;找出递增数组旋转后的最小值？&quot;&gt;&lt;/a&gt;找出递增数组旋转后的最小值？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public class R
      
    
    </summary>
    
      <category term="数组" scheme="http://www.xuchunfa.cn/categories/%E6%95%B0%E7%BB%84/"/>
    
    
  </entry>
  
  <entry>
    <title>排序算法比较</title>
    <link href="http://www.xuchunfa.cn/2018/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83/"/>
    <id>http://www.xuchunfa.cn/2018/07/28/排序算法比较/</id>
    <published>2018-07-28T08:13:19.000Z</published>
    <updated>2018-08-04T04:51:34.645Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/big-o.png" alt=""></p><p><strong>学习过程中一点点积累补充</strong></p><h4 id="什么叫做稳定性？"><a href="#什么叫做稳定性？" class="headerlink" title="什么叫做稳定性？"></a>什么叫做稳定性？</h4><p>稳定性是指：表示两个值相同的元素在排序前后是否有位置变化。如果前后位置变化，则排序算法是不稳定的，否则是稳定的。</p><ul><li><p>快排分析</p><p>  <strong>时间复杂度：</strong></p><p>  1.最优情况下：两边元素被划分的很均匀，递归次数等价于一颗二叉树的深度<a href="取下整的意思">logn</a>+1，第一次partition的时候需要和pivot比较n次</p><p>  时间复杂度：nlogn</p><p>  2.最差情况下：划分为了一颗斜着的树，递归次数为n-1,第一次划分还是得比较n次</p><p>  时间复杂度：n^2</p><p>  3.一般情况下：略</p><p>  时间复杂度：nlogn</p><p>  <strong>空间复杂度：</strong></p><p>  1.最优情况：因为递归调用会消耗空间，空间复杂度取决于栈的调用层数。</p><p>  空间复杂度：O(logn)</p><p>  2.最差情况：略</p><p>  空间复杂度：O(n)</p><p>  <strong>补充：</strong>快排是不稳定的。</p></li><li><p>直接插入排序</p><p>  <strong>时间复杂度：</strong></p><p>  1.最优情况：正序时，比较次数O(n),移动次数0次。</p><p>  时间复杂度：O(n)</p><p>  2.最坏情况：反序时，移动次数O(n^2),比较次数也是O(n^2)的。</p><p>  时间复杂度：O(n^2)</p><p>  平均复杂度:O(n^2)</p><p>  <strong>空间复杂度：</strong></p><p>  空间复杂度：O(1)</p><p>  <strong>补充：</strong>插入排序是稳定的。适用于有一定顺序的数据。</p></li><li><p>冒泡排序</p><p>  <strong>时间复杂度：</strong></p><p>  1.最优情况：优化后的冒泡排序，只进行了一轮比较，O(n-1)。</p><p>  时间复杂度：O(n)</p><p>  2.最坏情况：逆序，交换次数O(n^2)。</p><p>  时间复杂度:O(n^2)</p><p>  平均时间复杂度：O(n^2)</p><p>  <strong>空间复杂度：</strong>O(1)</p></li><li><p>简单选择排序</p><p>  <strong>时间复杂度：</strong></p><p>  1.最优情况：有序，交换次数0次，比较次数O(n^2)</p><p>  时间复杂度：O(n^2)</p><p>  2.最坏情况：逆序，交换次数O(n^2)，比较次数O(n^2)</p><p>  时间复杂度:O(n^2)</p><p>  平均时间复杂度：O(n^2)</p><p>  <strong>空间复杂度：</strong>O(1)</p></li><li><p>堆排序</p><p>  <strong>时间复杂度：</strong></p><p>  分析：</p><p>  初始化堆的过程时间：O(n)</p><p>  更改元素后重建时间：O(nlogn) = (n-1)logn = 循环次数*树的深度</p><p>  最好 = 最坏 = 平均时间复杂度 = O(nlogn)</p><p>  <strong>空间复杂度：</strong>O(1)</p></li><li><p>归并排序</p><p>  总时间 = 划分时间 + 合并时间</p><p>  <strong>时间复杂度：</strong></p><p>  最好 = 最坏 = 平均 = O(nlogn)</p><p>  <strong>空间复杂度：</strong></p><p>  O(n) = O(logn) + O(n)</p></li><li><p>希尔排序</p><p>  <strong>时间复杂度：</strong></p><p>  最坏：O(n^2)</p><p>  最好：O(n)</p><p>  平均：O(n^1.5)</p><p>  <strong>空间复杂度：</strong>O(1)</p></li></ul><p>-计数排序</p><pre><code>时间复杂度： O(n+K) = 遍历原数组 + 遍历计数数组 + 元素插入新数组       = O(n) + O(k) + O(n)空间复杂度：O(n+k)</code></pre><p>参考文档一：<a href="https://www.cnblogs.com/fengty90/p/3768827.html" target="_blank" rel="noopener">https://www.cnblogs.com/fengty90/p/3768827.html</a></p><p>参考文档二：<a href="https://blog.csdn.net/YuZhiHui_No1/article/details/44258297" target="_blank" rel="noopener">https://blog.csdn.net/YuZhiHui_No1/article/details/44258297</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://itimetraveler.github.io/gallery/sort-algorithms/big-o.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;学习过程中一点点积累补充&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;什么叫
      
    
    </summary>
    
      <category term="排序" scheme="http://www.xuchunfa.cn/categories/%E6%8E%92%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>斐波拉契数列</title>
    <link href="http://www.xuchunfa.cn/2018/07/27/%E6%96%90%E6%B3%A2%E6%8B%89%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>http://www.xuchunfa.cn/2018/07/27/斐波拉契数列/</id>
    <published>2018-07-27T11:43:48.000Z</published>
    <updated>2018-07-27T13:49:26.110Z</updated>
    
    <content type="html"><![CDATA[<h4 id="斐波拉契数列？"><a href="#斐波拉契数列？" class="headerlink" title="斐波拉契数列？"></a>斐波拉契数列？</h4><pre><code>public class Fibonacci {//效率差public static long fibonacci1(int n){    if(n == 0)        return 0;    if(n == 1)        return 1;    return fibonacci1(n-1) + fibonacci1(n-2);}public static long fibonacci(int n){    if(n == 0)        return 0;    if(n == 1)        return 1;    long one = 0;    long two = 1;    long three = 0;    for(int i = 2;i&lt;=n;i++){        three = one + two;        one = two;        two = three;    }    return three;}public static void main(String[] args){    System.out.println(Fibonacci.fibonacci1(50));}}</code></pre><h4 id="青蛙可以跳一级台阶和二级台阶-跳上-n-级台阶共有多少种跳法？"><a href="#青蛙可以跳一级台阶和二级台阶-跳上-n-级台阶共有多少种跳法？" class="headerlink" title="青蛙可以跳一级台阶和二级台阶,跳上 n 级台阶共有多少种跳法？"></a>青蛙可以跳一级台阶和二级台阶,跳上 n 级台阶共有多少种跳法？</h4><pre><code>public class FrogStep {public static long solution(int n) {    if (n == 0) {        throw new RuntimeException(&quot;输入自然数&quot;);    }    if (n == 1) {        return 1;    }    if (n == 2) {        return 2;    }    long one = 1;    long two = 2;    long three = 0;    for (int i = 3; i &lt;= n; i++) {        three = one + two;        one = two;        two = three;    }    return three;}public static void main(String[] args){    System.out.println(FrogStep.solution(100));}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;斐波拉契数列？&quot;&gt;&lt;a href=&quot;#斐波拉契数列？&quot; class=&quot;headerlink&quot; title=&quot;斐波拉契数列？&quot;&gt;&lt;/a&gt;斐波拉契数列？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public class Fibonacci {

//效率差
public sta
      
    
    </summary>
    
      <category term="策略类" scheme="http://www.xuchunfa.cn/categories/%E7%AD%96%E7%95%A5%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>栈和队列</title>
    <link href="http://www.xuchunfa.cn/2018/07/27/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>http://www.xuchunfa.cn/2018/07/27/栈和队列/</id>
    <published>2018-07-27T11:39:06.000Z</published>
    <updated>2018-07-27T11:43:19.234Z</updated>
    
    <content type="html"><![CDATA[<h4 id="两个栈实现队列？"><a href="#两个栈实现队列？" class="headerlink" title="两个栈实现队列？"></a>两个栈实现队列？</h4><pre><code>public class StackToQueue&lt;T&gt; {private Stack&lt;T&gt; stack1 = new Stack&lt;T&gt;();private Stack&lt;T&gt; stack2 = new Stack&lt;T&gt;();public void appendTail(T element){    stack1.push(element);}public T deleteHead(){    if(stack2.size() &lt;= 0){        while(!stack1.empty()){            T element = stack1.pop();            stack2.push(element);        }    }    //说明stack1 也没元素了    if(stack2.isEmpty()){        throw new RuntimeException(&quot;队列为空&quot;);    }    T head = stack2.pop();    return head;}public static void main(String[] args){    StackToQueue&lt;Integer&gt; queue = new StackToQueue&lt;Integer&gt;();    queue.appendTail(1);    queue.appendTail(2);    queue.appendTail(3);    Integer a = queue.deleteHead();    queue.appendTail(4);    Integer b = queue.deleteHead();    System.out.println(b);}}</code></pre><h4 id="两个队列实现栈？"><a href="#两个队列实现栈？" class="headerlink" title="两个队列实现栈？"></a>两个队列实现栈？</h4><pre><code>public class StackToQueue&lt;T&gt; {private Stack&lt;T&gt; stack1 = new Stack&lt;T&gt;();private Stack&lt;T&gt; stack2 = new Stack&lt;T&gt;();public void appendTail(T element){    stack1.push(element);}public T deleteHead(){    if(stack2.size() &lt;= 0){        while(!stack1.empty()){            T element = stack1.pop();            stack2.push(element);        }    }    //说明stack1 也没元素了    if(stack2.isEmpty()){        throw new RuntimeException(&quot;队列为空&quot;);    }    T head = stack2.pop();    return head;}public static void main(String[] args){    StackToQueue&lt;Integer&gt; queue = new StackToQueue&lt;Integer&gt;();    queue.appendTail(1);    queue.appendTail(2);    queue.appendTail(3);    Integer a = queue.deleteHead();    queue.appendTail(4);    Integer b = queue.deleteHead();    System.out.println(b);}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;两个栈实现队列？&quot;&gt;&lt;a href=&quot;#两个栈实现队列？&quot; class=&quot;headerlink&quot; title=&quot;两个栈实现队列？&quot;&gt;&lt;/a&gt;两个栈实现队列？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public class StackToQueue&amp;lt;T&amp;gt; {


      
    
    </summary>
    
      <category term="栈和队列" scheme="http://www.xuchunfa.cn/categories/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>二叉树的下一个结点</title>
    <link href="http://www.xuchunfa.cn/2018/07/24/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>http://www.xuchunfa.cn/2018/07/24/二叉树的下一个结点/</id>
    <published>2018-07-24T14:16:23.000Z</published>
    <updated>2018-07-24T14:19:19.302Z</updated>
    
    <content type="html"><![CDATA[<h4 id="给定一个结点，找出中序遍历序列的下一个结点？"><a href="#给定一个结点，找出中序遍历序列的下一个结点？" class="headerlink" title="给定一个结点，找出中序遍历序列的下一个结点？"></a>给定一个结点，找出中序遍历序列的下一个结点？</h4><pre><code>public class ParentBinaryTree {ParentBinaryTreeNode root;public void createTree(ParentBinaryTreeNode node,int data){    if(this.root == null){        root = new ParentBinaryTreeNode(data);    }else {        //二叉查找树        if(data &lt; node.data){            if(node.left == null){                ParentBinaryTreeNode temp = new ParentBinaryTreeNode(data);                node.left = temp;                temp.parent = node;            }else {                createTree(node.left,data);            }        }else {            if(node.right == null){                ParentBinaryTreeNode temp = new ParentBinaryTreeNode(data);                node.right = temp;                temp.parent = node;            }else {                createTree(node.right,data);            }        }    }}//中序遍历,递归实现public void inOrder(ParentBinaryTreeNode node){    if(node == null)        return;    inOrder(node.left);    System.out.print(node.data + &quot; &quot;);    inOrder(node.right);}//找出中序遍历中的下一个点public ParentBinaryTreeNode searchNext(ParentBinaryTreeNode node,int data){    if(node == null){        throw new RuntimeException(&quot;空树&quot;);    }    ParentBinaryTreeNode dataNode = searchData(node,data);    ParentBinaryTreeNode next = null;    if(dataNode == null){        throw new RuntimeException(&quot;不存在该值&quot;);    }else{        //有右子树        if(dataNode.right != null){            ParentBinaryTreeNode temp = dataNode.right;            while (temp.left != null){                temp = temp.left;            }            next = temp;        }else if(dataNode.parent != null){//等于null说明是根节点            ParentBinaryTreeNode current =  dataNode;            ParentBinaryTreeNode parent = current.parent;            while (parent != null &amp;&amp; parent.right == current){                current = parent;                parent = parent.parent;            }            next = parent;//parent有可能为null        }    }    return next;}private ParentBinaryTreeNode searchData(ParentBinaryTreeNode node, int data) {    if(node == null){       return null;    }    if(node.data == data){        return node;    }else if(searchData(node.left,data) != null){        return searchData(node.left,data);    }else        return searchData(node.right,data);}public static void main(String[] args){    ParentBinaryTree tree = new ParentBinaryTree();    //for(int i = 2;i&lt;10;i++){    //    tree.createTree(tree.root,i);    //}    tree.createTree(tree.root,9);    tree.createTree(tree.root,5);    tree.createTree(tree.root,3);    tree.createTree(tree.root,7);    tree.createTree(tree.root,6);    tree.createTree(tree.root,8);    tree.createTree(tree.root,12);    tree.createTree(tree.root,10);    tree.createTree(tree.root,14);    tree.inOrder(tree.root);    System.out.println();    ParentBinaryTreeNode node = tree.searchNext(tree.root,5);    if(node != null){        System.out.println(node.data);    }else {        System.out.println(&quot;最后一个结点&quot;);    }}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;给定一个结点，找出中序遍历序列的下一个结点？&quot;&gt;&lt;a href=&quot;#给定一个结点，找出中序遍历序列的下一个结点？&quot; class=&quot;headerlink&quot; title=&quot;给定一个结点，找出中序遍历序列的下一个结点？&quot;&gt;&lt;/a&gt;给定一个结点，找出中序遍历序列的下一个结
      
    
    </summary>
    
      <category term="树" scheme="http://www.xuchunfa.cn/categories/%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>volatile语义理解</title>
    <link href="http://www.xuchunfa.cn/2018/07/24/volatile%E8%AF%AD%E4%B9%89%E7%90%86%E8%A7%A3/"/>
    <id>http://www.xuchunfa.cn/2018/07/24/volatile语义理解/</id>
    <published>2018-07-24T09:05:01.000Z</published>
    <updated>2018-07-25T02:54:46.302Z</updated>
    
    <content type="html"><![CDATA[<p><strong>volatile读：</strong>线程先把本地内存中的变量置为无效,然后直接去主内存中去读（宏观上volatile变量的写对volatile变量的读可见）。</p><p><strong>锁释放和获得：</strong>锁释放的内存语义和volatile的写操作相似，获得锁和volatile读操作相同。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;volatile读：&lt;/strong&gt;线程先把本地内存中的变量置为无效,然后直接去主内存中去读（宏观上volatile变量的写对volatile变量的读可见）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;锁释放和获得：&lt;/strong&gt;锁释放的内存语义和volatile
      
    
    </summary>
    
      <category term="Java并发编程" scheme="http://www.xuchunfa.cn/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>前序中序后序构建二叉树</title>
    <link href="http://www.xuchunfa.cn/2018/07/24/%E5%89%8D%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://www.xuchunfa.cn/2018/07/24/前序中序后序构建二叉树/</id>
    <published>2018-07-24T06:58:22.000Z</published>
    <updated>2018-07-24T08:26:16.443Z</updated>
    
    <content type="html"><![CDATA[<h4 id="根据前序和中序序列构建二叉树？根据中序和后序序列构建二叉树？"><a href="#根据前序和中序序列构建二叉树？根据中序和后序序列构建二叉树？" class="headerlink" title="根据前序和中序序列构建二叉树？根据中序和后序序列构建二叉树？"></a>根据前序和中序序列构建二叉树？根据中序和后序序列构建二叉树？</h4><p><strong>核心思想：</strong>递归创建，更新start和end坐标。</p><pre><code>public class RestructBinaryTree {private BinaryTreeNode root;//根据前序和中序构造二叉树public BinaryTreeNode preAndIn(int[] pre,int preStart,int preEnd,int[] in,int inStart,int inEnd){    if(pre == null || in == null || pre.length &lt;= 0 || in.length &lt;= 0){        throw new RuntimeException(&quot;序列数组长度需大于0&quot;);    }    if(preEnd &lt; preStart || inEnd &lt; inStart){        return null;    }    //第一个结点    BinaryTreeNode node = new BinaryTreeNode(pre[preStart]);    int i = 0;    for(;i&lt;in.length;i++){        if(node.data == in[i]){            node.left = preAndIn(pre,preStart+1,preStart+i-inStart,in,inStart,i-1);            node.right = preAndIn(pre,preStart+i-inStart+1,preEnd,in,i+1,inEnd);            break;        }    }    if(i == in.length){        throw new RuntimeException(&quot;两组序列不匹配&quot;);    }    return node;}//根据中序和后序构造二叉树public BinaryTreeNode inAndPost(int[] post,int postStart,int postEnd,int[] in,int inStart,int inEnd){    if(post == null || in == null || post.length &lt;= 0 || in.length &lt;= 0){        throw new RuntimeException(&quot;序列数组长度需大于0&quot;);    }    if(postEnd &lt; postStart || inEnd &lt; inStart){        return null;    }    //第一个结点    BinaryTreeNode node = new BinaryTreeNode(post[postEnd]);    int i = 0;    for(;i&lt;in.length;i++){        if(node.data == in[i]){            node.right = inAndPost(post,postEnd-inEnd+i,postEnd-1,in,i+1,inEnd);            node.left = inAndPost(post,postStart,postEnd-inEnd+i-1,in,inStart,i-1);            break;        }    }    if(i == in.length){        throw new RuntimeException(&quot;两组序列不匹配&quot;);    }    return node;}//先序遍历,递归实现public void preOrder(BinaryTreeNode node){    if (node == null)        return;    System.out.print(node.data + &quot; &quot;);    preOrder(node.left);    preOrder(node.right);}//后序遍历public void postOrder(BinaryTreeNode node) {    if (node == null)        return;    postOrder(node.left);    postOrder(node.right);    System.out.print(node.data + &quot; &quot;);}public static void main(String[] args){    RestructBinaryTree tree = new RestructBinaryTree();    int[] pre = {1,2,3,4};    int[] in = {4,3,2,1};    int[] post = {7,4,2,5,8,6,3,1};    //tree.root = tree.inAndPost(post,0,post.length-1,in,0,in.length-1);    tree.root = tree.preAndIn(pre,0,pre.length-1,in,0,in.length-1);    //tree.preOrder(tree.root);    tree.postOrder(tree.root); }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;根据前序和中序序列构建二叉树？根据中序和后序序列构建二叉树？&quot;&gt;&lt;a href=&quot;#根据前序和中序序列构建二叉树？根据中序和后序序列构建二叉树？&quot; class=&quot;headerlink&quot; title=&quot;根据前序和中序序列构建二叉树？根据中序和后序序列构建二叉树？&quot;&gt;
      
    
    </summary>
    
      <category term="树" scheme="http://www.xuchunfa.cn/categories/%E6%A0%91/"/>
    
    
  </entry>
  
</feed>
