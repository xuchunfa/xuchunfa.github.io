<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Flying in the ocean of knowledge</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xuchunfa.cn/"/>
  <updated>2018-08-25T10:27:47.880Z</updated>
  <id>http://www.xuchunfa.cn/</id>
  
  <author>
    <name>Xu chunfa</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>字符串匹配算法</title>
    <link href="http://www.xuchunfa.cn/2018/08/25/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/"/>
    <id>http://www.xuchunfa.cn/2018/08/25/字符串匹配算法/</id>
    <published>2018-08-25T10:26:54.000Z</published>
    <updated>2018-08-25T10:27:47.880Z</updated>
    
    <content type="html"><![CDATA[<ul><li>KMP算法</li></ul><ul><li>BM算法</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;KMP算法&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;BM算法&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
      <category term="字符串" scheme="http://www.xuchunfa.cn/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>虚拟机字节码执行引擎</title>
    <link href="http://www.xuchunfa.cn/2018/08/24/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
    <id>http://www.xuchunfa.cn/2018/08/24/虚拟机字节码执行引擎/</id>
    <published>2018-08-24T12:48:13.000Z</published>
    <updated>2018-08-25T12:25:58.362Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>栈帧</p></blockquote><ul><li><p>局部变量表</p><p>  1.一个局部变量定义了但没有赋初值是不可以使用的.</p></li><li><p>操作数栈</p></li><li><p>动态连接</p></li><li><p>方法返回地址</p><p>  1.方法退出等效于当前栈帧出栈.如返回果有值的话,则将返回值压入调用者栈帧的操作数栈中.</p></li><li><p>附加信息</p></li></ul><p>其中动态连接,方法返回地址,附加信息统称为<strong>栈帧信息</strong>.</p><blockquote><p>方法调用</p></blockquote><p>一切方法调用在Class文件里面存储的都是符号引用,不是方法在实际运行时内存布局中的入口地址.</p><ul><li><p>解析</p><pre><code>方法在程序真正运行之前就有一个可确定的调用版本, 并且这个方法的调用版本在运行期间不可改变.符合以上条件的方法:1.静态方法2.私有方法3.实例构造器4.父类方法它们在类加载的时候就会把符号引用解析成直接引用.</code></pre></li></ul><ul><li>分派</li></ul><p>1.静态分派(方法重载)</p><p>重载：“编译期绑定”，也叫编译期多态。方法重载主要是类内部多态性的一个体现。 </p><p>例如:</p><pre><code>public class O{static class A{}static class B extends A{}static class C extends A{}public void a(A a){    System.out.println(&quot;A method&quot;);}public void a(B b){    System.out.println(&quot;B method&quot;);}public void a(C c){    System.out.println(&quot;C method&quot;);}public static void main(String[] args){    O o = new O();    A b = new B();    A c = new C();    o.a(b);    o.a(c);}}</code></pre><p>上述代码的结果:</p><p>A method</p><p>A method</p><p><strong>虚拟机在重载时是通过参数的静态类型而不是实际类型作为判断依据.</strong></p><p>2.动态分派（方法重写）</p><p>重写：“运行期绑定”，也叫运行期多态。方法重写是父类与子类之间多态性的体现。</p><pre><code>在运行期间根据实际类型确定方法执行版本的分派。</code></pre><p>例如：</p><pre><code>class Dog{public void bark(){    System.out.println(&quot;woof &quot;);}}class Hound extends Dog{public void sniff(){    System.out.println(&quot;sniff &quot;);}public void bark(){    System.out.println(&quot;bowl&quot;);}}public class OverridingTest{public static void main(String [] args){    Dog dog = new Hound();    dog.bark();}}    </code></pre><p>输出：bowl</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;栈帧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;局部变量表&lt;/p&gt;
&lt;p&gt;  1.一个局部变量定义了但没有赋初值是不可以使用的.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;操作数栈&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态连接&lt;/p&gt;
&lt;/
      
    
    </summary>
    
      <category term="java虚拟机" scheme="http://www.xuchunfa.cn/categories/java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>数组中和为m的所有组合</title>
    <link href="http://www.xuchunfa.cn/2018/08/24/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%92%8C%E4%B8%BAm%E7%9A%84%E6%89%80%E6%9C%89%E7%BB%84%E5%90%88/"/>
    <id>http://www.xuchunfa.cn/2018/08/24/数组中和为m的所有组合/</id>
    <published>2018-08-24T10:09:40.000Z</published>
    <updated>2018-08-24T10:09:40.239Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>随机版本的快排</title>
    <link href="http://www.xuchunfa.cn/2018/08/24/%E9%9A%8F%E6%9C%BA%E7%89%88%E6%9C%AC%E7%9A%84%E5%BF%AB%E6%8E%92/"/>
    <id>http://www.xuchunfa.cn/2018/08/24/随机版本的快排/</id>
    <published>2018-08-24T04:24:16.000Z</published>
    <updated>2018-08-24T04:25:37.975Z</updated>
    
    <content type="html"><![CDATA[<pre><code>public class QuickSort {public static void swap(int[] a,int i,int j){    int temp;    temp = a[i];    a[i] = a[j];    a[j] = temp;}public static int partition(int[] a,int start,int end){    if(a == null || start &lt; 0 || end &gt; a.length-1){        throw new RuntimeException(&quot;参数不合法&quot;);    }    //轴值在[start,end]区间内随机生成,然后把轴值交换到数组中第一位    rand_pivot(a,start,end);    int i = start;    int j = end;    int pivot = a[start];    while (i &lt; j){        while (i &lt; j &amp;&amp; a[j] &gt;= pivot){            j--;        }        //a[i] = a[j];//这种写法时条件不能为a[j] &gt; pivot必须要 &gt;=        swap(a,i,j);        while (i &lt; j &amp;&amp; a[i] &lt;= pivot){            i++;        }        //a[j] = a[i];        swap(a,j,i);    }    //a[i] 或者 a[j]    //a[i] = pivot;    return i;}//随机化的选择主元private static void rand_pivot(int[] a, int start, int end) {    Random random = new Random();    int rand = start + random.nextInt(end - start + 1);//随机函数生成的整数区间在[0,length)    //交换第一个数和随机选出来的数    int temp = a[start];    a[start] = a[rand];    a[rand] = temp;}public static void quickSort(int[] a,int start,int end){    if(start &gt;= end)        return;    int index = partition(a,start,end);    quickSort(a,start,index-1);    quickSort(a,index+1,end);    /*int index;    if(start &lt; end){        index = partition(a,start,end);        quickSort(a,start,index-1);        quickSort(a,index+1,end);    }*/}public static void main(String[] args){    int[] a = {2,4,5,1,1,2,7,6,3};    QuickSort.quickSort(a,0,a.length-1);    System.out.println(Arrays.toString(a));}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;public class QuickSort {

public static void swap(int[] a,int i,int j){
    int temp;
    temp = a[i];
    a[i] = a[j];
    a[j] 
      
    
    </summary>
    
      <category term="排序" scheme="http://www.xuchunfa.cn/categories/%E6%8E%92%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>java动态绑定</title>
    <link href="http://www.xuchunfa.cn/2018/08/23/java%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/"/>
    <id>http://www.xuchunfa.cn/2018/08/23/java动态绑定/</id>
    <published>2018-08-23T07:04:48.000Z</published>
    <updated>2018-08-24T13:52:44.349Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>动态绑定(后期绑定)和前期绑定？</p></blockquote><p>1.普通的方法我们看new后面的是什么类型；(后期绑定)</p><p>2.域和静态方法我们看=前面声明的是什么类型。 (前期绑定)</p><p>3.final，static，private和构造方法是前期绑定的。</p><p>4.运行时（动态）绑定针对的范畴只是对象的（普通）方法。</p><pre><code>public class Father {protected String name = &quot;父亲属性&quot;;}public class Son extends Father {    protected String name = &quot;儿子属性&quot;;    public static void main(String[] args) {        Father sample = new Son();        System.out.println(&quot;调用的属性：&quot; + sample.name);}}</code></pre><p>上述代码的运行结果: <strong>父亲属性</strong></p><pre><code>public class Father {protected String name = &quot;父亲属性&quot;;public String getName() {    return name;}}　　public class Son extends Father {protected String name = &quot;儿子属性&quot;;public String getName() {    return name;}public static void main(String[] args) {    Father sample = new Son();    System.out.println(&quot;调用的属性:&quot; + sample.getName());}}</code></pre><p>上述代码的运行结果: <strong>儿子属性</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;动态绑定(后期绑定)和前期绑定？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.普通的方法我们看new后面的是什么类型；(后期绑定)&lt;/p&gt;
&lt;p&gt;2.域和静态方法我们看=前面声明的是什么类型。 (前期绑定)&lt;/p&gt;
&lt;p&gt;3.final，stat
      
    
    </summary>
    
      <category term="java基础" scheme="http://www.xuchunfa.cn/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>关于TopK问题的详解</title>
    <link href="http://www.xuchunfa.cn/2018/08/21/%E5%85%B3%E4%BA%8ETopK%E9%97%AE%E9%A2%98%E7%9A%84%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.xuchunfa.cn/2018/08/21/关于TopK问题的详解/</id>
    <published>2018-08-21T07:21:19.000Z</published>
    <updated>2018-08-24T06:42:24.011Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在O(N)时间内寻找最大(或最小)的K个数？</p></blockquote><ul><li>Random Select:</li></ul><p>本质上是求第K大或第K小的那个数。</p><pre><code>1.如果是求最小的K个数，则找到坐标为 k-1 的Pivot.左边放是比pivot小的值，右边比pivot大。2.如果是求最大的K个数，则找到坐标为 k-1 的Pivot.左边放是比pivot大的值，右边比pivot小。</code></pre><p>如果数组中整数的取值范围不大的话，可以用哈希表的方法解决。</p><p>思路：用一个计数数组来记录每个数字出现的次数。</p><pre><code>时间复杂度：0(n + MAXN)for(sumCount = 0, v = MAXN-1; v &gt;= 0; v--){    sumCount += count[v];    if(sumCount &gt;= K)        break;}return v;</code></pre><ul><li>堆排序解决</li></ul><p>例如：2亿个整数中求最大的100万之和？</p><p>思路：</p><ol><li>首先建立一个容量为100万（Top K）的int数组，从文件读取整数填充。</li><li>利用堆维护该100万条记录（确保堆顶元素为最小值）</li><li>从文件中读取一个整数与堆顶元素比较，如果大于堆顶元素则替换该元素，并调整堆的结构。</li><li>重复步骤3一直到数据读取完</li><li>将数组中的元素全部相加，得到结果</li></ol><p>代码如下：</p><pre><code>public class TopKProblem {//时间复杂度:(n-K)*logK 空间复杂度:O(K)public static int[] createKtopHeap(int[] num,int k){    int length = num.length;    int i = 0;    //通过堆维护Topk元素    int[] KNumberHeap = new int[k];    if(k &gt;= length){        k = length;        return num;    }    //初始化有k个元素的堆    for(; i &lt; k; i++){        KNumberHeap[i] = num[i];    }    //构建小顶堆    for(int j = KNumberHeap.length/2-1;j &gt;= 0;j--){        createMinHeap(KNumberHeap,j,KNumberHeap.length);    }    //从第k+1个元素开始循环,每次都与堆顶元素(K个元素中的最小值)比较,大于就替代然后再调整.    for(;i &lt; length;i++){        if(num[i] &gt; KNumberHeap[0]){            KNumberHeap[0] = num[i];            createMinHeap(KNumberHeap,0,KNumberHeap.length);        }    }    return KNumberHeap;}private static void createMinHeap(int[] a, int i , int len) {    int father = a[i];    int j;//j代表子结点坐标 i代表父结点坐标    while(2*i + 1 &lt; len){//如果i结点在堆顶上的话,需要自顶向下调整        j = 2*i + 1;        if(j + 1 &lt; len &amp;&amp; a[j] &gt; a[j+1] )            j++;        if(a[j] &lt; father){            a[i] = a[j];            i = j;        }else {//不用调整的话就不用再向下循环了,子节点都已经调整好了            break;        }    }    //找到最终位置    a[i] = father;}public static void main(String[] args){    Random random = new Random();    int[] num = new int[15];    for(int i = 0;i &lt; num.length;i++){        num[i] = random.nextInt(50);    }    System.out.println(Arrays.toString(num));    System.out.println(Arrays.toString(createKtopHeap(num,5)));}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在O(N)时间内寻找最大(或最小)的K个数？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Random Select:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本质上是求第K大或第K小的那个数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.如果是求最小的K个数
      
    
    </summary>
    
      <category term="数组" scheme="http://www.xuchunfa.cn/categories/%E6%95%B0%E7%BB%84/"/>
    
    
  </entry>
  
  <entry>
    <title>数组中第k大的数</title>
    <link href="http://www.xuchunfa.cn/2018/08/20/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACk%E5%A4%A7%E7%9A%84%E6%95%B0/"/>
    <id>http://www.xuchunfa.cn/2018/08/20/数组中第k大的数/</id>
    <published>2018-08-20T11:42:39.000Z</published>
    <updated>2018-08-24T07:21:36.776Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>多种解法开拓思路</p></blockquote><p>1.把数组从大到小进行排序，再遍历到第k个元素。</p><pre><code>时间复杂度：O(nlogn+k).</code></pre><p>2.利用选择排序，每一次遍历数组就可以选出一个最大值，遍历k次就得到了第K大的值。</p><pre><code>时间复杂度：O(n*k).所以最坏情况为O(n^2).</code></pre><p>3.基于快排的Quick Select.使用快排中的partition()函数，大的数值放在pivot左边，小的方右边。得到的Position就是第Position+1大的数值。然后再选择其中的一半数据递归。(也可以用循环解决)</p><pre><code>时间复杂度：O(n).详细证明见算法导论</code></pre><p>4.可以建立最大堆,然后pop操作进行k次,就能找到第K大的值。</p><p>5.通过优先队列实现,底层原理基于4方法。</p><pre><code>时间复杂度：O(n)空间复杂度：O(n)</code></pre><h3 id="该题目的变形版本"><a href="#该题目的变形版本" class="headerlink" title="该题目的变形版本?"></a>该题目的变形版本?</h3><blockquote><p>N个数中最大的第K个不同的数？</p></blockquote><p>例如：5，4，4，3 第三大的数是3,而不是4</p><blockquote><p>找第k到第m大的数？</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;多种解法开拓思路&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.把数组从大到小进行排序，再遍历到第k个元素。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;时间复杂度：O(nlogn+k).
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.利用选择排序，每一次遍历数组就可以选
      
    
    </summary>
    
      <category term="数组" scheme="http://www.xuchunfa.cn/categories/%E6%95%B0%E7%BB%84/"/>
    
    
  </entry>
  
  <entry>
    <title>类文件结构和类加载</title>
    <link href="http://www.xuchunfa.cn/2018/08/19/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    <id>http://www.xuchunfa.cn/2018/08/19/类文件结构和类加载/</id>
    <published>2018-08-19T11:55:10.000Z</published>
    <updated>2018-08-25T09:28:27.085Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>类文件结构</p></blockquote><p>1.java方法体中的代码经过javac编译器后，变成字节码存储在方法表的Code属性中。</p><p>2.java虚拟机通过对照指令表，将字节码翻译成了机器能够认识的机器指令。</p><p>对于2操作的规范化说法如下：</p><pre><code>java虚拟机的解释器从字节码流取出操作码，执行操作码所定义的操作。字节码指令集：由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需参数（称为操作数，Operands）而构成。操作码的长度：1字节。操作码的种数不超过256.</code></pre><blockquote><p>类加载机制</p></blockquote><p>定义：把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化,最终形成可以被虚拟机直接使用的java类型。</p><p>1.类加载的时机</p><ul><li><p>遇到下面三种情况</p><p>  1.new实例化对象时</p><p>  2.读取或设置一个类的静态字段时</p><p>  3.调用一个类的静态方法时</p></li><li><p>java.lang.reflect包的方法对类进行反射调用时</p></li><li><p>准备初始化子类时会触发父类的初始化</p></li></ul><blockquote><p>类加载过程</p></blockquote><ul><li>加载</li></ul><p>1.获取类的二进制字节流</p><p>2.转化为方法区的运行时数据结构</p><p>3.内存区生成java.lang.Class对象</p><p>连接阶段包括：验证、准备和解析</p><ul><li>验证</li></ul><p>1.是基于二进制字节流进行的</p><ul><li>准备阶段</li></ul><p>1.为类变量(static变量)分配内存以及初始化。</p><ul><li>解析</li></ul><p>1.虚拟机将符号引用替换为直接引用。</p><pre><code>例如：将静态方法、私有方法、实例构造器、父类方法的符号引用直接解析成直接引用。</code></pre><p>2.针对类或接口、字段、类方法、接口方法、方法类型、方法句柄以及调用点限定符。</p><ul><li>初始化</li></ul><p>1.执行类构造器<clinit>()方法的过程。</clinit></p><p>2.<clinit>()方法由编译器自动收集类中的所有类变量的复制动作和静态语句块。</clinit></p><blockquote><p>类加载器</p></blockquote><p>1.类加载器干啥用的？</p><pre><code>通过一个类的全限定名来获取描述此类的二进制字节流。</code></pre><p>2.类加载器的种类？</p><ul><li><p>启动类加载器</p><pre><code>1.System.class.getClassLoader()结果为null的原因，这并不表示System这个类没有类加载器，而是它的加载器比较特殊，是BootstrapClassLoader.2.加载存放在JAVA_HOME/lib目录中的类库或被-Xbootclasspath参数指定的路径。</code></pre></li></ul><ul><li><p>拓展类加载器</p><pre><code>1.加载JAVA_HOME/lib/ext目录或被java.ext.dirs系统变量指定的类库。</code></pre></li></ul><ul><li><p>应用程序类加载器(系统类加载器)</p><pre><code>1.加载用户类路径（classpath）下的类库。</code></pre></li></ul><h4 id="双亲委派模型？"><a href="#双亲委派模型？" class="headerlink" title="双亲委派模型？"></a>双亲委派模型？</h4><p><img src="https://i.imgur.com/fKQXKAa.jpg" alt=""></p><p>1.检查类是否已经加载。</p><p>2.如果没加载就逐层递归到父类。递归结束的条件是parent==null.</p><p>3.如果最上层Bootstrap都还没找到的话，则出栈，一层层调用自己的findclass方法。</p><p>代码如下：</p><pre><code>protected Class&lt;?&gt; loadClass(String name, boolean resolve)    throws ClassNotFoundException{    synchronized (getClassLoadingLock(name)) {        // First, check if the class has already been loaded        Class&lt;?&gt; c = findLoadedClass(name);        if (c == null) {            long t0 = System.nanoTime();            try {                if (parent != null) {                    c = parent.loadClass(name, false);                } else {                    c = findBootstrapClassOrNull(name);                }            } catch (ClassNotFoundException e) {                // ClassNotFoundException thrown if class not found                // from the non-null parent class loader            }            if (c == null) {                // If still not found, then invoke findClass in order                // to find the class.                long t1 = System.nanoTime();                c = findClass(name);                // this is the defining class loader; record the stats                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                sun.misc.PerfCounter.getFindClasses().increment();            }        }        if (resolve) {            resolveClass(c);        }        return c;    }}</code></pre><h3 id="类加载过程的总结"><a href="#类加载过程的总结" class="headerlink" title="类加载过程的总结"></a>类加载过程的总结</h3><p>当有触发类加载的条件时，会将java字节码以二进制流的形式装载到java虚拟机内存中去，并且把二进制流按字节码规范解析成jvm内部运行时的数据结构。最终解析完成的结果是生成了类访问的入口对象java.lang.Class,通过该对象可以访问类在方法区的内容。</p><p>然后会去验证和校验二进制流的合法性，接着发生“赋零”的初始化，紧接着就是将常量池中类的符号引用替代成直接引用。最后发生的才是程序指定的初始化内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;类文件结构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.java方法体中的代码经过javac编译器后，变成字节码存储在方法表的Code属性中。&lt;/p&gt;
&lt;p&gt;2.java虚拟机通过对照指令表，将字节码翻译成了机器能够认识的机器指令。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="java虚拟机" scheme="http://www.xuchunfa.cn/categories/java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>合并两个有序链表</title>
    <link href="http://www.xuchunfa.cn/2018/08/17/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://www.xuchunfa.cn/2018/08/17/合并两个有序链表/</id>
    <published>2018-08-17T08:17:36.000Z</published>
    <updated>2018-08-17T08:19:20.598Z</updated>
    
    <content type="html"><![CDATA[<pre><code>public class MergeSortedLink {public static ListNode merge(ListNode head1,ListNode head2){    ListNode mergedHead;    if(head1 == null){        return head2;    }    if(head2 == null){        return head1;    }    if(head1.data &lt; head2.data){        mergedHead = head1;        mergedHead.next = merge(head1.next,head2);    }else {        mergedHead = head2;        mergedHead.next = merge(head1,head2.next);    }    return mergedHead;}public static void main(String[] args){    Link link1 = new Link();    Link link2 = new Link();    link1.add(1);    link1.add(3);    link1.add(5);    link2.add(2);    link2.add(4);    link2.add(6);    link2.add(7);    ListNode newHead = MergeSortedLink.merge(link1.head,link2.head);    Link link3 = new Link();    link3.head = newHead;    link3.print();}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;public class MergeSortedLink {

public static ListNode merge(ListNode head1,ListNode head2){
    ListNode mergedHead;

    if(hea
      
    
    </summary>
    
      <category term="链表" scheme="http://www.xuchunfa.cn/categories/%E9%93%BE%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>删除链表中的重复结点</title>
    <link href="http://www.xuchunfa.cn/2018/08/17/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E7%BB%93%E7%82%B9/"/>
    <id>http://www.xuchunfa.cn/2018/08/17/删除链表中的重复结点/</id>
    <published>2018-08-17T07:03:51.000Z</published>
    <updated>2018-08-17T07:05:18.485Z</updated>
    
    <content type="html"><![CDATA[<pre><code>public class DeleteDuplicationNode {//例如(1,2,2,2,3) &gt;&gt; (1,2,3)public static void deleteDuplicationNode(ListNode head){    if(head == null){        throw new RuntimeException(&quot;链表不存在&quot;);    }    //默认是增序的(包含所有结点相等的情况)    boolean ascend = true;    ListNode post,p;    p = head;    while(p.next != null){        if(p.data &gt; p.next.data){            ascend = false;//降序        }        p = p.next;    }    p = head;    if(ascend){//链表递增时        while (p.next != null){            if(p.data == p.next.data){                post = p.next;                while(post.next != null){                    if(post.data &lt; post.next.data){                        p.next = post.next;                        break;//结束                    }                    post = post.next;                }                if(post.next == null){                    p.next = post.next;                    break;                }            }            p = p.next;        }    }else {//链表递减        while (p.next != null){            if(p.data == p.next.data){                post = p.next;                while(post.next != null){                    if(post.data &gt; post.next.data){                        p.next = post.next;                        break;                    }                    post = post.next;                }                if(post.next == null){                    p.next = post.next;                    break;                }            }            //break跳到这里,继续遍历            p = p.next;        }    }}//例如(1,2,3,3,4,4,5) &gt;&gt; (1,2,5)public static void DeleteDuplication(ListNode head){    if(head == null){        throw new RuntimeException(&quot;链表不存在&quot;);    }    ListNode pre = null;    ListNode p = head;    ListNode post;    while (p != null){        post = p.next;        boolean needDeleted = false;        if(post != null &amp;&amp; p.data == post.data){            needDeleted = true;        }        if(!needDeleted){            pre = p;            p = p.next;        }else {            int value = p.data;            ListNode toDelete = p;            while (toDelete != null &amp;&amp; toDelete.data == value){                post = toDelete.next;                toDelete = post;            }            if(pre == null){//删除头节点.可能所有结点相等 head = null                Link.head = post;            }else {                pre.next = post;            }            p = post;        }    }}public static void main(String[] args){    Link link = new Link();    link.add(1);    DeleteDuplicationNode.DeleteDuplication(link.head);    link.print();}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;public class DeleteDuplicationNode {

//例如(1,2,2,2,3) &amp;gt;&amp;gt; (1,2,3)
public static void deleteDuplicationNode(ListNode head){


      
    
    </summary>
    
      <category term="链表" scheme="http://www.xuchunfa.cn/categories/%E9%93%BE%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>字符串匹配</title>
    <link href="http://www.xuchunfa.cn/2018/08/17/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    <id>http://www.xuchunfa.cn/2018/08/17/字符串匹配/</id>
    <published>2018-08-17T07:00:19.000Z</published>
    <updated>2018-08-17T07:02:23.654Z</updated>
    
    <content type="html"><![CDATA[<h4 id="匹配匹配模式为-和-的字符串？"><a href="#匹配匹配模式为-和-的字符串？" class="headerlink" title="匹配匹配模式为. 和 * 的字符串？"></a>匹配匹配模式为. 和 * 的字符串？</h4><pre><code>public class RegularExpression {public static boolean match(String str,String pattern,int strLen,int patternLen,int strIndex,int patternIndex){    if(str == null || pattern == null){        return false;    }    return matchCore(str,pattern,strLen,patternLen,strIndex,patternIndex);}private static boolean matchCore(String str, String pattern,int strLen,int patternLen,int strIndex,int patternIndex) {    if(strIndex == strLen &amp;&amp; patternIndex == patternLen){        return true;    }    //模式匹配完了字符串没匹配完    if(strIndex &lt; strLen &amp;&amp; patternIndex == patternLen){        return  false;    }    //模式的第二个字符为&apos;*&apos;的情况    if(patternIndex+1 &lt; patternLen &amp;&amp; pattern.charAt(patternIndex + 1) == &apos;*&apos;){//注意边界条件最后一个字符,需要判断条件        if(strIndex &lt; strLen &amp;&amp; str.charAt(strIndex) == pattern.charAt(patternIndex) || strIndex &lt; strLen &amp;&amp; pattern.charAt(patternIndex) == &apos;.&apos;){            return matchCore(str,pattern,strLen,patternLen,strIndex+1,patternIndex+2) ||                    matchCore(str,pattern,strLen,patternLen,strIndex+1,patternIndex) ||                    matchCore(str,pattern,strLen,patternLen,strIndex,patternIndex+2);        }else {//字符串匹配完了模式还没匹配完            return matchCore(str,pattern,strLen,patternLen,strIndex,patternIndex+2);        }    }    //模式的第二个字符不为&apos;*&apos;的情况(注意条件 strIndex &lt; strLen )    if(strIndex &lt; strLen &amp;&amp; str.charAt(strIndex) == pattern.charAt(patternIndex) || (strIndex &lt; strLen &amp;&amp; pattern.charAt(patternIndex) == &apos;.&apos;)){        return matchCore(str,pattern,strLen,patternLen,++strIndex,++patternIndex);    }    //包含了str=&quot;ab&quot; pattern=&quot;....&quot;的情况了    return false;}public static void main(String[] args){    String str = &quot;ab&quot;;    String pattern = &quot;....&quot;;    int strLen = str.length();    int patternLen = pattern.length();    System.out.println(RegularExpression.match(str,pattern,strLen,patternLen,0,0));}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;匹配匹配模式为-和-的字符串？&quot;&gt;&lt;a href=&quot;#匹配匹配模式为-和-的字符串？&quot; class=&quot;headerlink&quot; title=&quot;匹配匹配模式为. 和 * 的字符串？&quot;&gt;&lt;/a&gt;匹配匹配模式为. 和 * 的字符串？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;publ
      
    
    </summary>
    
      <category term="字符串" scheme="http://www.xuchunfa.cn/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>删除链表结点-时间复杂度为常数</title>
    <link href="http://www.xuchunfa.cn/2018/08/17/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BA%E5%B8%B8%E6%95%B0/"/>
    <id>http://www.xuchunfa.cn/2018/08/17/删除链表结点-时间复杂度为常数/</id>
    <published>2018-08-17T06:58:10.000Z</published>
    <updated>2018-08-17T06:58:36.786Z</updated>
    
    <content type="html"><![CDATA[<pre><code>public class DeleteListNode {public static void deleteListNode(ListNode head,ListNode toDelete){    if(head == null || toDelete == null){        throw new RuntimeException(&quot;没有目标节点删除&quot;);    }    //只有一个头节点,删完后置空    if(head.next == null &amp;&amp; toDelete.next == null){        Link.head = null;//head = null 相当于值传递,无法改变head        toDelete = null;    }else if(head.next != null &amp;&amp; toDelete.next == null){//删除尾结点        ListNode pre = head;        while (pre.next != toDelete){            pre = pre.next;        }        pre.next = null;    }else {//head.next != null &amp;&amp; toDelete.next != null 删除中间结点        toDelete.data = toDelete.next.data;        toDelete.next = toDelete.next.next;    }}public static void main(String[] args){    Link link = new Link();    link.add(1);    ListNode toDelete = link.head;    DeleteListNode.deleteListNode(link.head,toDelete);    link.print();}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;public class DeleteListNode {

public static void deleteListNode(ListNode head,ListNode toDelete){

    if(head == null || toDele
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>链表中环的入口结点</title>
    <link href="http://www.xuchunfa.cn/2018/08/17/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9/"/>
    <id>http://www.xuchunfa.cn/2018/08/17/链表中环的入口结点/</id>
    <published>2018-08-17T06:53:31.000Z</published>
    <updated>2018-08-17T06:54:47.389Z</updated>
    
    <content type="html"><![CDATA[<pre><code>public class EnterCycleNode {public static ListNode meetNode(ListNode head){    if(head == null){        throw new RuntimeException(&quot;链表不能为空&quot;);    }    ListNode pre,post;    pre = head;    post = head;    int cycleNodeNum = calcycleNodeNum(head);    if(cycleNodeNum != 0){//有环        for(int i = 0;i&lt;cycleNodeNum;i++){//post先走cycleNodeNum步            pre = pre.next;        }        while(post != pre){//然后两个指针依次先前走一步            pre = pre.next;            post = post.next;        }        return post;    }    return null;}//判断链表是否有环,有的话计算环中一共有多少结点private static int calcycleNodeNum(ListNode head) {    ListNode p,pre;    p = head;    pre = head;    int numOfCycleNode = 0;    while (pre.next != null){        pre = pre.next;//走第一步时判断一下        if (pre != p &amp;&amp; pre.next != null){            p = p.next;            pre = pre.next;//pre先走了两步        }        //走完第二步再判断一下        if(pre == p){//第一个指针追上了第二个指针            numOfCycleNode++;            pre = pre.next;            while (pre != p){//计算环内结点                numOfCycleNode++;                pre = pre.next;            }            break;//跳出循环        }    }    return numOfCycleNode;}public static void main(String[] args){    Link link = new Link();    link.add(1);    link.add(2);    link.add(3);    link.add(4);    ListNode tail = Link.head;    while (tail.next != null){        tail = tail.next;    }    //tail.next = Link.head;    if(EnterCycleNode.meetNode(Link.head) != null){        System.out.println(EnterCycleNode.meetNode(Link.head).data);    }else {        throw new RuntimeException(&quot;不存在环入口节点&quot;);    }}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;public class EnterCycleNode {

public static ListNode meetNode(ListNode head){

    if(head == null){
        throw new RuntimeEx
      
    
    </summary>
    
      <category term="链表" scheme="http://www.xuchunfa.cn/categories/%E9%93%BE%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>反转链表</title>
    <link href="http://www.xuchunfa.cn/2018/08/17/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-1/"/>
    <id>http://www.xuchunfa.cn/2018/08/17/反转链表-1/</id>
    <published>2018-08-17T06:50:36.000Z</published>
    <updated>2018-08-17T06:52:27.623Z</updated>
    
    <content type="html"><![CDATA[<h4 id="就地反转和递归反转？"><a href="#就地反转和递归反转？" class="headerlink" title="就地反转和递归反转？"></a>就地反转和递归反转？</h4><pre><code>public class VerseLink {//直接遍历一遍public static void verseLink(ListNode head){    ListNode previous,current,post;    previous = null;    current = head;    while (current != null){        post = current.next;        if(post == null)            Link.head = current;        current.next = previous;        previous = current;        current = post;    }}//递归反转public static ListNode recursiveVerseLink(ListNode head){    if(head  == null || head.next == null){        return head;    }    ListNode newHead = recursiveVerseLink(head.next);//原链表的最后一个结点    head.next.next = head;//从倒数第二个结点开始回溯,指针发生转向    head.next = null;//断开原来指针    return newHead;}public static void main(String[] args){    Link link = new Link();    link.add(1);    link.add(2);    link.add(3);    link.add(4);    Link.head = VerseLink.recursiveVerseLink(Link.head);    link.print();}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;就地反转和递归反转？&quot;&gt;&lt;a href=&quot;#就地反转和递归反转？&quot; class=&quot;headerlink&quot; title=&quot;就地反转和递归反转？&quot;&gt;&lt;/a&gt;就地反转和递归反转？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public class VerseLink {

//直接
      
    
    </summary>
    
      <category term="链表" scheme="http://www.xuchunfa.cn/categories/%E9%93%BE%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>并行和并发的区别</title>
    <link href="http://www.xuchunfa.cn/2018/08/16/%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.xuchunfa.cn/2018/08/16/并行和并发的区别/</id>
    <published>2018-08-16T05:10:53.000Z</published>
    <updated>2018-08-16T05:47:39.185Z</updated>
    
    <content type="html"><![CDATA[<p><strong>举个例子：</strong></p><p>桌子上放着一本书，桌子旁坐着四个人，书就相当于cpu资源，并行可以比喻成这四个人打开书同时阅读；而并发可以看成是则这四个人轮流看这本书。</p><blockquote><p>并行（parallelism）</p></blockquote><p>1.物理上同时发生的。</p><p>2.某一时刻能处理多个任务。</p><blockquote><p>并发（concurrency）</p></blockquote><p>1.逻辑上同时发生的。</p><p>2.某一时间间隔内能同时处理多个任务，但是某一时刻就只处理一个任务。</p><p>直观点的示意图：两核CPU创建四个线程的情况</p><p><img src="https://i.imgur.com/MV4eOd9.png" alt=""></p><p>操作1,2,3,4并发执行。</p><p>操作1,5以及2,6都是并行的。</p><p>可以理解现在大多数CPU都是多核的，在执行大量请求时，并行并发一般都是一起发生的。</p><p>参考文档：<a href="https://www.jianshu.com/p/b11e251d3dc7" target="_blank" rel="noopener">https://www.jianshu.com/p/b11e251d3dc7</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;举个例子：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;桌子上放着一本书，桌子旁坐着四个人，书就相当于cpu资源，并行可以比喻成这四个人打开书同时阅读；而并发可以看成是则这四个人轮流看这本书。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;并行（parallelism）&lt;/p
      
    
    </summary>
    
      <category term="Java并发编程" scheme="http://www.xuchunfa.cn/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>java虚拟机垃圾收集器</title>
    <link href="http://www.xuchunfa.cn/2018/08/15/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>http://www.xuchunfa.cn/2018/08/15/java虚拟机垃圾收集器/</id>
    <published>2018-08-15T12:13:35.000Z</published>
    <updated>2018-08-17T05:25:43.963Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>垃圾回收前先标记,标记的方法？</p></blockquote><p>1.引用计数</p><p>给对象添加一个引用计数器，每一个地方引用它时，计数器值就加1.</p><p>2.可达性分析</p><p>不在”GC Roots”引用链上的对象会被标记为将要收集的对象。</p><p><strong>可作为GC Roots的对象：</strong></p><ul><li><p>虚拟机栈（栈中的本地变量表）中引用的对象</p></li><li><p>方法区中类静态属性引用的对象</p></li><li><p>方法区中常量引用的对象</p></li><li><p>本地方法栈（native方法）引用的对象、</p></li></ul><blockquote><p>垃圾收集算法</p></blockquote><ul><li><p>标记-清除算法</p></li><li><p>复制算法</p><p>  1.需要额外的内存空间进行分配担保。不适用于对象存活率较高的老年代。</p><p>  2.额外空间可以向老年代借。老年代空间都还不够用的话，”Stop the world”发生Full GC。Full GC的作用是为了让老年代腾出空间来。</p></li><li><p>标记-整理算法</p><p>  1.让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p><p>  2.适用于老年代垃圾的回收。</p></li><li><p>分代回收算法</p><p>  1.将内存划分为新生代和老年代，新生代由于“朝生夕死”的特点，即对象的存活率低，可采用复制算法；老年代对象存活率高，没有额外内存空间担保，所以采用标记-清除算法和标记-整理算法较好。</p></li></ul><blockquote><p>垃圾收集器</p></blockquote><p>默认的垃圾收集器：Serial收集器 / Serial Old 收集器</p><ul><li><p>Serial收集器</p><p>  1.在收集垃圾时，必须暂停其它所有工作的线程，直到它收集结束。</p><p>  2.没有线程交互的开销，效率最高的单线程垃圾收集器。</p><p>  3.适用于运行在Client端的虚拟机</p></li><li><p>ParNew收集器</p><p>  1.多线程。</p><p>  2.适用于运行在Server端的虚拟机。</p><p>  3.唯一一个能与CMS收集器（老年代的收集器）配合使用。</p></li><li><p>Parallel Scavenge 收集器</p><p>  1.吞吐量优先的收集器。</p></li><li><p>Serial Old 收集器</p></li><li><p>Parallel Old 收集器</p><p>  1.在吞吐量和CPU资源敏感的环境下，与Parallel Scavenge配合使用。</p></li><li><p>CMS收集器</p><p>  1.过程：</p><pre><code>a.初始标记b.并发标记c.初始标记d.并发清除</code></pre></li></ul><pre><code>2.初始标记和初始标记依然需要停顿。3.缺点：    a.应用程序变慢,吞吐量变低    b.无法处理浮点动垃圾    c.会产生太多空间碎片</code></pre><ul><li><p>G1 收集器</p><p>  1.使用Region划分内存空间以及有优先级的区域回收。</p><p>  特点：</p><pre><code>a.并行和并发。b.分代收集。c.空间整合。d.可预测的停顿。</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;垃圾回收前先标记,标记的方法？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.引用计数&lt;/p&gt;
&lt;p&gt;给对象添加一个引用计数器，每一个地方引用它时，计数器值就加1.&lt;/p&gt;
&lt;p&gt;2.可达性分析&lt;/p&gt;
&lt;p&gt;不在”GC Roots”引用链上的对象
      
    
    </summary>
    
      <category term="java虚拟机" scheme="http://www.xuchunfa.cn/categories/java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>找到链表中的中间结点</title>
    <link href="http://www.xuchunfa.cn/2018/08/15/%E6%89%BE%E5%88%B0%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/"/>
    <id>http://www.xuchunfa.cn/2018/08/15/找到链表中的中间结点/</id>
    <published>2018-08-15T11:46:51.000Z</published>
    <updated>2018-08-15T11:46:52.005Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java虚拟机内存区域</title>
    <link href="http://www.xuchunfa.cn/2018/08/14/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <id>http://www.xuchunfa.cn/2018/08/14/java虚拟机内存区域/</id>
    <published>2018-08-14T08:35:17.000Z</published>
    <updated>2018-08-17T05:31:28.922Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对象创建过程</p></blockquote><p>1.检查类是否已经加载</p><p>2.虚拟机为对象分配内存</p><p>3.将分配到的内存区域初始化</p><blockquote><p>虚拟机常见参数</p></blockquote><p>1.-Xms20M:虚拟机堆内存的最小值</p><p>2.-Xmx20M:虚拟机堆内存的最大值</p><p>3.-Xss1M:每个线程的栈的大小为1M</p><p>4.-Xmn10M:Java Heap Young 新生代的大小为10M</p><p>5.MaxPermSize:方法区最大内存</p><p>6.-XX:PermSize=10M：虚拟机方法区内存最小值</p><p>7.-XX：MaxPermSize=100M:虚拟机方法区内存最大值</p><blockquote><p>内存分配</p></blockquote><p>1.对象主要分配在新生代的Eden区上，新生代包括1个Eden区和两个Survivor区，其中一个Survivor用于分配担保，内存大小默认比例为Eden:Survivor = 8 : 1.</p><p>2.</p><pre><code>2.1  新生代GC(Minor GC):发生在新生代，速度快。什么时候发生呢？只要老年代的连续空间大于新生代对象的总大小或者历次晋升的平均大小。2.2  老年代GC(Major GC / Full GC):发生在老年代，一般比前者慢10倍。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;对象创建过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.检查类是否已经加载&lt;/p&gt;
&lt;p&gt;2.虚拟机为对象分配内存&lt;/p&gt;
&lt;p&gt;3.将分配到的内存区域初始化&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;虚拟机常见参数&lt;/p&gt;
&lt;/blockquo
      
    
    </summary>
    
      <category term="java虚拟机" scheme="http://www.xuchunfa.cn/categories/java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="http://www.xuchunfa.cn/2018/08/14/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://www.xuchunfa.cn/2018/08/14/红黑树/</id>
    <published>2018-08-14T06:14:00.000Z</published>
    <updated>2018-08-14T07:39:04.394Z</updated>
    
    <content type="html"><![CDATA[<h4 id="红黑树的定义？"><a href="#红黑树的定义？" class="headerlink" title="红黑树的定义？"></a>红黑树的定义？</h4><p><img src="https://i.imgur.com/y7nMfe8.jpg" alt=""></p><p>红黑树的特点：</p><p> 1.每个节点不是红色就是黑色的；</p><p> 2.根节点总是黑色的；</p><p> 3.如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</p><p> 4.从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。 </p><p> 5.每个叶子结点(nil)为黑色。</p><h4 id="插入结点后的红黑树调整？"><a href="#插入结点后的红黑树调整？" class="headerlink" title="插入结点后的红黑树调整？"></a>插入结点后的红黑树调整？</h4><p>分以下三种情况：</p><p>1.插入节点的父节点和其叔叔节点（祖父节点的另一个子节点）均为红色的。</p><p>插入结点4：</p><p><img src="https://i.imgur.com/Z864C7i.png" alt=""></p><p><strong>调整：</strong>将当前节点(4)的父节点(5)和叔叔节点(8)涂黑，将祖父节点(7)涂红，变成下图所示的情况。再将当前节点指向其祖父节点(7)。</p><p><img src="https://i.imgur.com/4he7MLS.png" alt=""></p><p>2.插入节点的父节点是红色，叔叔节点是黑色，且插入节点是其父节点的右子节点。</p><p>情况2的示意图为第一步操作的结果。相当于插入当前结点7.</p><p><strong>调整：</strong>将当前节点(7)的父节点(2)作为新的节点，以(2)为支点做左旋(LR)操作.</p><p><img src="https://i.imgur.com/yoP1mMb.png" alt=""></p><p>3.插入节点的父节点是红色，叔叔节点是黑色，且插入节点是其父节点的左子节点。</p><p>情况3的示意图为第二步操作的结果。相当于插入当前结点2.</p><p><strong>调整：</strong>将当前节点的父节点(7)涂黑，将祖父节点(11)涂红，在祖父节点(11)为支点做右旋操作.</p><p><img src="https://i.imgur.com/QYM4k1S.png" alt=""></p><p><strong>总结：</strong>整个完整的流程是从：变色-左旋-右旋。也可能直接从情况2或3开始。</p><p>参考文档一：<a href="https://blog.csdn.net/eson_15/article/details/51144079" target="_blank" rel="noopener">https://blog.csdn.net/eson_15/article/details/51144079</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;红黑树的定义？&quot;&gt;&lt;a href=&quot;#红黑树的定义？&quot; class=&quot;headerlink&quot; title=&quot;红黑树的定义？&quot;&gt;&lt;/a&gt;红黑树的定义？&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/y7nMfe8.jpg&quot; alt=&quot;&quot;&gt;
      
    
    </summary>
    
      <category term="树" scheme="http://www.xuchunfa.cn/categories/%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>平衡二叉树</title>
    <link href="http://www.xuchunfa.cn/2018/08/13/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://www.xuchunfa.cn/2018/08/13/平衡二叉树/</id>
    <published>2018-08-13T13:16:21.000Z</published>
    <updated>2018-08-14T06:06:51.552Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是平衡二叉树（AVL树）？"><a href="#什么是平衡二叉树（AVL树）？" class="headerlink" title="什么是平衡二叉树（AVL树）？"></a>什么是平衡二叉树（AVL树）？</h4><ol><li>可以为空</li><li>任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过1。简单来讲就是任意结点的左右子树的数目基本相同。</li><li>平衡二叉树是二叉查找树的优化，因为二叉查找树适用于无序数据，对于<br>有序数据插入时就是一颗斜树，遍历时的时间复杂度为O(n),已经体现不出了优势了。</li></ol><h4 id="怎么调整平衡二叉树？"><a href="#怎么调整平衡二叉树？" class="headerlink" title="怎么调整平衡二叉树？"></a>怎么调整平衡二叉树？</h4><p>举个LR旋转的例子：</p><p><img src="https://i.imgur.com/jBi58WA.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是平衡二叉树（AVL树）？&quot;&gt;&lt;a href=&quot;#什么是平衡二叉树（AVL树）？&quot; class=&quot;headerlink&quot; title=&quot;什么是平衡二叉树（AVL树）？&quot;&gt;&lt;/a&gt;什么是平衡二叉树（AVL树）？&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;可以为空&lt;/li&gt;
&lt;l
      
    
    </summary>
    
      <category term="树" scheme="http://www.xuchunfa.cn/categories/%E6%A0%91/"/>
    
    
  </entry>
  
</feed>
