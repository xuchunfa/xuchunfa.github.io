<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Flying in the ocean of knowledge</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xuchunfa.cn/"/>
  <updated>2018-08-17T08:19:20.598Z</updated>
  <id>http://www.xuchunfa.cn/</id>
  
  <author>
    <name>Xu chunfa</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>合并两个有序链表</title>
    <link href="http://www.xuchunfa.cn/2018/08/17/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://www.xuchunfa.cn/2018/08/17/合并两个有序链表/</id>
    <published>2018-08-17T08:17:36.000Z</published>
    <updated>2018-08-17T08:19:20.598Z</updated>
    
    <content type="html"><![CDATA[<pre><code>public class MergeSortedLink {public static ListNode merge(ListNode head1,ListNode head2){    ListNode mergedHead;    if(head1 == null){        return head2;    }    if(head2 == null){        return head1;    }    if(head1.data &lt; head2.data){        mergedHead = head1;        mergedHead.next = merge(head1.next,head2);    }else {        mergedHead = head2;        mergedHead.next = merge(head1,head2.next);    }    return mergedHead;}public static void main(String[] args){    Link link1 = new Link();    Link link2 = new Link();    link1.add(1);    link1.add(3);    link1.add(5);    link2.add(2);    link2.add(4);    link2.add(6);    link2.add(7);    ListNode newHead = MergeSortedLink.merge(link1.head,link2.head);    Link link3 = new Link();    link3.head = newHead;    link3.print();}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;public class MergeSortedLink {

public static ListNode merge(ListNode head1,ListNode head2){
    ListNode mergedHead;

    if(hea
      
    
    </summary>
    
      <category term="链表" scheme="http://www.xuchunfa.cn/categories/%E9%93%BE%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>删除链表中的重复结点</title>
    <link href="http://www.xuchunfa.cn/2018/08/17/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E7%BB%93%E7%82%B9/"/>
    <id>http://www.xuchunfa.cn/2018/08/17/删除链表中的重复结点/</id>
    <published>2018-08-17T07:03:51.000Z</published>
    <updated>2018-08-17T07:05:18.485Z</updated>
    
    <content type="html"><![CDATA[<pre><code>public class DeleteDuplicationNode {//例如(1,2,2,2,3) &gt;&gt; (1,2,3)public static void deleteDuplicationNode(ListNode head){    if(head == null){        throw new RuntimeException(&quot;链表不存在&quot;);    }    //默认是增序的(包含所有结点相等的情况)    boolean ascend = true;    ListNode post,p;    p = head;    while(p.next != null){        if(p.data &gt; p.next.data){            ascend = false;//降序        }        p = p.next;    }    p = head;    if(ascend){//链表递增时        while (p.next != null){            if(p.data == p.next.data){                post = p.next;                while(post.next != null){                    if(post.data &lt; post.next.data){                        p.next = post.next;                        break;//结束                    }                    post = post.next;                }                if(post.next == null){                    p.next = post.next;                    break;                }            }            p = p.next;        }    }else {//链表递减        while (p.next != null){            if(p.data == p.next.data){                post = p.next;                while(post.next != null){                    if(post.data &gt; post.next.data){                        p.next = post.next;                        break;                    }                    post = post.next;                }                if(post.next == null){                    p.next = post.next;                    break;                }            }            //break跳到这里,继续遍历            p = p.next;        }    }}//例如(1,2,3,3,4,4,5) &gt;&gt; (1,2,5)public static void DeleteDuplication(ListNode head){    if(head == null){        throw new RuntimeException(&quot;链表不存在&quot;);    }    ListNode pre = null;    ListNode p = head;    ListNode post;    while (p != null){        post = p.next;        boolean needDeleted = false;        if(post != null &amp;&amp; p.data == post.data){            needDeleted = true;        }        if(!needDeleted){            pre = p;            p = p.next;        }else {            int value = p.data;            ListNode toDelete = p;            while (toDelete != null &amp;&amp; toDelete.data == value){                post = toDelete.next;                toDelete = post;            }            if(pre == null){//删除头节点.可能所有结点相等 head = null                Link.head = post;            }else {                pre.next = post;            }            p = post;        }    }}public static void main(String[] args){    Link link = new Link();    link.add(1);    DeleteDuplicationNode.DeleteDuplication(link.head);    link.print();}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;public class DeleteDuplicationNode {

//例如(1,2,2,2,3) &amp;gt;&amp;gt; (1,2,3)
public static void deleteDuplicationNode(ListNode head){


      
    
    </summary>
    
      <category term="链表" scheme="http://www.xuchunfa.cn/categories/%E9%93%BE%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>字符串匹配</title>
    <link href="http://www.xuchunfa.cn/2018/08/17/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    <id>http://www.xuchunfa.cn/2018/08/17/字符串匹配/</id>
    <published>2018-08-17T07:00:19.000Z</published>
    <updated>2018-08-17T07:02:23.654Z</updated>
    
    <content type="html"><![CDATA[<h4 id="匹配匹配模式为-和-的字符串？"><a href="#匹配匹配模式为-和-的字符串？" class="headerlink" title="匹配匹配模式为. 和 * 的字符串？"></a>匹配匹配模式为. 和 * 的字符串？</h4><pre><code>public class RegularExpression {public static boolean match(String str,String pattern,int strLen,int patternLen,int strIndex,int patternIndex){    if(str == null || pattern == null){        return false;    }    return matchCore(str,pattern,strLen,patternLen,strIndex,patternIndex);}private static boolean matchCore(String str, String pattern,int strLen,int patternLen,int strIndex,int patternIndex) {    if(strIndex == strLen &amp;&amp; patternIndex == patternLen){        return true;    }    //模式匹配完了字符串没匹配完    if(strIndex &lt; strLen &amp;&amp; patternIndex == patternLen){        return  false;    }    //模式的第二个字符为&apos;*&apos;的情况    if(patternIndex+1 &lt; patternLen &amp;&amp; pattern.charAt(patternIndex + 1) == &apos;*&apos;){//注意边界条件最后一个字符,需要判断条件        if(strIndex &lt; strLen &amp;&amp; str.charAt(strIndex) == pattern.charAt(patternIndex) || strIndex &lt; strLen &amp;&amp; pattern.charAt(patternIndex) == &apos;.&apos;){            return matchCore(str,pattern,strLen,patternLen,strIndex+1,patternIndex+2) ||                    matchCore(str,pattern,strLen,patternLen,strIndex+1,patternIndex) ||                    matchCore(str,pattern,strLen,patternLen,strIndex,patternIndex+2);        }else {//字符串匹配完了模式还没匹配完            return matchCore(str,pattern,strLen,patternLen,strIndex,patternIndex+2);        }    }    //模式的第二个字符不为&apos;*&apos;的情况(注意条件 strIndex &lt; strLen )    if(strIndex &lt; strLen &amp;&amp; str.charAt(strIndex) == pattern.charAt(patternIndex) || (strIndex &lt; strLen &amp;&amp; pattern.charAt(patternIndex) == &apos;.&apos;)){        return matchCore(str,pattern,strLen,patternLen,++strIndex,++patternIndex);    }    //包含了str=&quot;ab&quot; pattern=&quot;....&quot;的情况了    return false;}public static void main(String[] args){    String str = &quot;ab&quot;;    String pattern = &quot;....&quot;;    int strLen = str.length();    int patternLen = pattern.length();    System.out.println(RegularExpression.match(str,pattern,strLen,patternLen,0,0));}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;匹配匹配模式为-和-的字符串？&quot;&gt;&lt;a href=&quot;#匹配匹配模式为-和-的字符串？&quot; class=&quot;headerlink&quot; title=&quot;匹配匹配模式为. 和 * 的字符串？&quot;&gt;&lt;/a&gt;匹配匹配模式为. 和 * 的字符串？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;publ
      
    
    </summary>
    
      <category term="字符串" scheme="http://www.xuchunfa.cn/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>删除链表结点-时间复杂度为常数</title>
    <link href="http://www.xuchunfa.cn/2018/08/17/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BA%E5%B8%B8%E6%95%B0/"/>
    <id>http://www.xuchunfa.cn/2018/08/17/删除链表结点-时间复杂度为常数/</id>
    <published>2018-08-17T06:58:10.000Z</published>
    <updated>2018-08-17T06:58:36.786Z</updated>
    
    <content type="html"><![CDATA[<pre><code>public class DeleteListNode {public static void deleteListNode(ListNode head,ListNode toDelete){    if(head == null || toDelete == null){        throw new RuntimeException(&quot;没有目标节点删除&quot;);    }    //只有一个头节点,删完后置空    if(head.next == null &amp;&amp; toDelete.next == null){        Link.head = null;//head = null 相当于值传递,无法改变head        toDelete = null;    }else if(head.next != null &amp;&amp; toDelete.next == null){//删除尾结点        ListNode pre = head;        while (pre.next != toDelete){            pre = pre.next;        }        pre.next = null;    }else {//head.next != null &amp;&amp; toDelete.next != null 删除中间结点        toDelete.data = toDelete.next.data;        toDelete.next = toDelete.next.next;    }}public static void main(String[] args){    Link link = new Link();    link.add(1);    ListNode toDelete = link.head;    DeleteListNode.deleteListNode(link.head,toDelete);    link.print();}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;public class DeleteListNode {

public static void deleteListNode(ListNode head,ListNode toDelete){

    if(head == null || toDele
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>链表中环的入口结点</title>
    <link href="http://www.xuchunfa.cn/2018/08/17/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9/"/>
    <id>http://www.xuchunfa.cn/2018/08/17/链表中环的入口结点/</id>
    <published>2018-08-17T06:53:31.000Z</published>
    <updated>2018-08-17T06:54:47.389Z</updated>
    
    <content type="html"><![CDATA[<pre><code>public class EnterCycleNode {public static ListNode meetNode(ListNode head){    if(head == null){        throw new RuntimeException(&quot;链表不能为空&quot;);    }    ListNode pre,post;    pre = head;    post = head;    int cycleNodeNum = calcycleNodeNum(head);    if(cycleNodeNum != 0){//有环        for(int i = 0;i&lt;cycleNodeNum;i++){//post先走cycleNodeNum步            pre = pre.next;        }        while(post != pre){//然后两个指针依次先前走一步            pre = pre.next;            post = post.next;        }        return post;    }    return null;}//判断链表是否有环,有的话计算环中一共有多少结点private static int calcycleNodeNum(ListNode head) {    ListNode p,pre;    p = head;    pre = head;    int numOfCycleNode = 0;    while (pre.next != null){        pre = pre.next;//走第一步时判断一下        if (pre != p &amp;&amp; pre.next != null){            p = p.next;            pre = pre.next;//pre先走了两步        }        //走完第二步再判断一下        if(pre == p){//第一个指针追上了第二个指针            numOfCycleNode++;            pre = pre.next;            while (pre != p){//计算环内结点                numOfCycleNode++;                pre = pre.next;            }            break;//跳出循环        }    }    return numOfCycleNode;}public static void main(String[] args){    Link link = new Link();    link.add(1);    link.add(2);    link.add(3);    link.add(4);    ListNode tail = Link.head;    while (tail.next != null){        tail = tail.next;    }    //tail.next = Link.head;    if(EnterCycleNode.meetNode(Link.head) != null){        System.out.println(EnterCycleNode.meetNode(Link.head).data);    }else {        throw new RuntimeException(&quot;不存在环入口节点&quot;);    }}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;public class EnterCycleNode {

public static ListNode meetNode(ListNode head){

    if(head == null){
        throw new RuntimeEx
      
    
    </summary>
    
      <category term="链表" scheme="http://www.xuchunfa.cn/categories/%E9%93%BE%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>反转链表</title>
    <link href="http://www.xuchunfa.cn/2018/08/17/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-1/"/>
    <id>http://www.xuchunfa.cn/2018/08/17/反转链表-1/</id>
    <published>2018-08-17T06:50:36.000Z</published>
    <updated>2018-08-17T06:52:27.623Z</updated>
    
    <content type="html"><![CDATA[<h4 id="就地反转和递归反转？"><a href="#就地反转和递归反转？" class="headerlink" title="就地反转和递归反转？"></a>就地反转和递归反转？</h4><pre><code>public class VerseLink {//直接遍历一遍public static void verseLink(ListNode head){    ListNode previous,current,post;    previous = null;    current = head;    while (current != null){        post = current.next;        if(post == null)            Link.head = current;        current.next = previous;        previous = current;        current = post;    }}//递归反转public static ListNode recursiveVerseLink(ListNode head){    if(head  == null || head.next == null){        return head;    }    ListNode newHead = recursiveVerseLink(head.next);//原链表的最后一个结点    head.next.next = head;//从倒数第二个结点开始回溯,指针发生转向    head.next = null;//断开原来指针    return newHead;}public static void main(String[] args){    Link link = new Link();    link.add(1);    link.add(2);    link.add(3);    link.add(4);    Link.head = VerseLink.recursiveVerseLink(Link.head);    link.print();}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;就地反转和递归反转？&quot;&gt;&lt;a href=&quot;#就地反转和递归反转？&quot; class=&quot;headerlink&quot; title=&quot;就地反转和递归反转？&quot;&gt;&lt;/a&gt;就地反转和递归反转？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public class VerseLink {

//直接
      
    
    </summary>
    
      <category term="链表" scheme="http://www.xuchunfa.cn/categories/%E9%93%BE%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>并行和并发的区别</title>
    <link href="http://www.xuchunfa.cn/2018/08/16/%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.xuchunfa.cn/2018/08/16/并行和并发的区别/</id>
    <published>2018-08-16T05:10:53.000Z</published>
    <updated>2018-08-16T05:47:39.185Z</updated>
    
    <content type="html"><![CDATA[<p><strong>举个例子：</strong></p><p>桌子上放着一本书，桌子旁坐着四个人，书就相当于cpu资源，并行可以比喻成这四个人打开书同时阅读；而并发可以看成是则这四个人轮流看这本书。</p><blockquote><p>并行（parallelism）</p></blockquote><p>1.物理上同时发生的。</p><p>2.某一时刻能处理多个任务。</p><blockquote><p>并发（concurrency）</p></blockquote><p>1.逻辑上同时发生的。</p><p>2.某一时间间隔内能同时处理多个任务，但是某一时刻就只处理一个任务。</p><p>直观点的示意图：两核CPU创建四个线程的情况</p><p><img src="https://i.imgur.com/MV4eOd9.png" alt=""></p><p>操作1,2,3,4并发执行。</p><p>操作1,5以及2,6都是并行的。</p><p>可以理解现在大多数CPU都是多核的，在执行大量请求时，并行并发一般都是一起发生的。</p><p>参考文档：<a href="https://www.jianshu.com/p/b11e251d3dc7" target="_blank" rel="noopener">https://www.jianshu.com/p/b11e251d3dc7</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;举个例子：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;桌子上放着一本书，桌子旁坐着四个人，书就相当于cpu资源，并行可以比喻成这四个人打开书同时阅读；而并发可以看成是则这四个人轮流看这本书。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;并行（parallelism）&lt;/p
      
    
    </summary>
    
      <category term="Java并发编程" scheme="http://www.xuchunfa.cn/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>java虚拟机垃圾收集器</title>
    <link href="http://www.xuchunfa.cn/2018/08/15/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>http://www.xuchunfa.cn/2018/08/15/java虚拟机垃圾收集器/</id>
    <published>2018-08-15T12:13:35.000Z</published>
    <updated>2018-08-17T05:25:43.963Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>垃圾回收前先标记,标记的方法？</p></blockquote><p>1.引用计数</p><p>给对象添加一个引用计数器，每一个地方引用它时，计数器值就加1.</p><p>2.可达性分析</p><p>不在”GC Roots”引用链上的对象会被标记为将要收集的对象。</p><p><strong>可作为GC Roots的对象：</strong></p><ul><li><p>虚拟机栈（栈中的本地变量表）中引用的对象</p></li><li><p>方法区中类静态属性引用的对象</p></li><li><p>方法区中常量引用的对象</p></li><li><p>本地方法栈（native方法）引用的对象、</p></li></ul><blockquote><p>垃圾收集算法</p></blockquote><ul><li><p>标记-清除算法</p></li><li><p>复制算法</p><p>  1.需要额外的内存空间进行分配担保。不适用于对象存活率较高的老年代。</p><p>  2.额外空间可以向老年代借。老年代空间都还不够用的话，”Stop the world”发生Full GC。Full GC的作用是为了让老年代腾出空间来。</p></li><li><p>标记-整理算法</p><p>  1.让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p><p>  2.适用于老年代垃圾的回收。</p></li><li><p>分代回收算法</p><p>  1.将内存划分为新生代和老年代，新生代由于“朝生夕死”的特点，即对象的存活率低，可采用复制算法；老年代对象存活率高，没有额外内存空间担保，所以采用标记-清除算法和标记-整理算法较好。</p></li></ul><blockquote><p>垃圾收集器</p></blockquote><p>默认的垃圾收集器：Serial收集器 / Serial Old 收集器</p><ul><li><p>Serial收集器</p><p>  1.在收集垃圾时，必须暂停其它所有工作的线程，直到它收集结束。</p><p>  2.没有线程交互的开销，效率最高的单线程垃圾收集器。</p><p>  3.适用于运行在Client端的虚拟机</p></li><li><p>ParNew收集器</p><p>  1.多线程。</p><p>  2.适用于运行在Server端的虚拟机。</p><p>  3.唯一一个能与CMS收集器（老年代的收集器）配合使用。</p></li><li><p>Parallel Scavenge 收集器</p><p>  1.吞吐量优先的收集器。</p></li><li><p>Serial Old 收集器</p></li><li><p>Parallel Old 收集器</p><p>  1.在吞吐量和CPU资源敏感的环境下，与Parallel Scavenge配合使用。</p></li><li><p>CMS收集器</p><p>  1.过程：</p><pre><code>a.初始标记b.并发标记c.初始标记d.并发清除</code></pre></li></ul><pre><code>2.初始标记和初始标记依然需要停顿。3.缺点：    a.应用程序变慢,吞吐量变低    b.无法处理浮点动垃圾    c.会产生太多空间碎片</code></pre><ul><li><p>G1 收集器</p><p>  1.使用Region划分内存空间以及有优先级的区域回收。</p><p>  特点：</p><pre><code>a.并行和并发。b.分代收集。c.空间整合。d.可预测的停顿。</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;垃圾回收前先标记,标记的方法？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.引用计数&lt;/p&gt;
&lt;p&gt;给对象添加一个引用计数器，每一个地方引用它时，计数器值就加1.&lt;/p&gt;
&lt;p&gt;2.可达性分析&lt;/p&gt;
&lt;p&gt;不在”GC Roots”引用链上的对象
      
    
    </summary>
    
      <category term="java虚拟机" scheme="http://www.xuchunfa.cn/categories/java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>找到链表中的中间结点</title>
    <link href="http://www.xuchunfa.cn/2018/08/15/%E6%89%BE%E5%88%B0%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/"/>
    <id>http://www.xuchunfa.cn/2018/08/15/找到链表中的中间结点/</id>
    <published>2018-08-15T11:46:51.000Z</published>
    <updated>2018-08-15T11:46:52.005Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java虚拟机内存区域</title>
    <link href="http://www.xuchunfa.cn/2018/08/14/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <id>http://www.xuchunfa.cn/2018/08/14/java虚拟机内存区域/</id>
    <published>2018-08-14T08:35:17.000Z</published>
    <updated>2018-08-17T05:31:28.922Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对象创建过程</p></blockquote><p>1.检查类是否已经加载</p><p>2.虚拟机为对象分配内存</p><p>3.将分配到的内存区域初始化</p><blockquote><p>虚拟机常见参数</p></blockquote><p>1.-Xms20M:虚拟机堆内存的最小值</p><p>2.-Xmx20M:虚拟机堆内存的最大值</p><p>3.-Xss1M:每个线程的栈的大小为1M</p><p>4.-Xmn10M:Java Heap Young 新生代的大小为10M</p><p>5.MaxPermSize:方法区最大内存</p><p>6.-XX:PermSize=10M：虚拟机方法区内存最小值</p><p>7.-XX：MaxPermSize=100M:虚拟机方法区内存最大值</p><blockquote><p>内存分配</p></blockquote><p>1.对象主要分配在新生代的Eden区上，新生代包括1个Eden区和两个Survivor区，其中一个Survivor用于分配担保，内存大小默认比例为Eden:Survivor = 8 : 1.</p><p>2.</p><pre><code>2.1  新生代GC(Minor GC):发生在新生代，速度快。什么时候发生呢？只要老年代的连续空间大于新生代对象的总大小或者历次晋升的平均大小。2.2  老年代GC(Major GC / Full GC):发生在老年代，一般比前者慢10倍。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;对象创建过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.检查类是否已经加载&lt;/p&gt;
&lt;p&gt;2.虚拟机为对象分配内存&lt;/p&gt;
&lt;p&gt;3.将分配到的内存区域初始化&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;虚拟机常见参数&lt;/p&gt;
&lt;/blockquo
      
    
    </summary>
    
      <category term="java虚拟机" scheme="http://www.xuchunfa.cn/categories/java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="http://www.xuchunfa.cn/2018/08/14/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://www.xuchunfa.cn/2018/08/14/红黑树/</id>
    <published>2018-08-14T06:14:00.000Z</published>
    <updated>2018-08-14T07:39:04.394Z</updated>
    
    <content type="html"><![CDATA[<h4 id="红黑树的定义？"><a href="#红黑树的定义？" class="headerlink" title="红黑树的定义？"></a>红黑树的定义？</h4><p><img src="https://i.imgur.com/y7nMfe8.jpg" alt=""></p><p>红黑树的特点：</p><p> 1.每个节点不是红色就是黑色的；</p><p> 2.根节点总是黑色的；</p><p> 3.如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</p><p> 4.从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。 </p><p> 5.每个叶子结点(nil)为黑色。</p><h4 id="插入结点后的红黑树调整？"><a href="#插入结点后的红黑树调整？" class="headerlink" title="插入结点后的红黑树调整？"></a>插入结点后的红黑树调整？</h4><p>分以下三种情况：</p><p>1.插入节点的父节点和其叔叔节点（祖父节点的另一个子节点）均为红色的。</p><p>插入结点4：</p><p><img src="https://i.imgur.com/Z864C7i.png" alt=""></p><p><strong>调整：</strong>将当前节点(4)的父节点(5)和叔叔节点(8)涂黑，将祖父节点(7)涂红，变成下图所示的情况。再将当前节点指向其祖父节点(7)。</p><p><img src="https://i.imgur.com/4he7MLS.png" alt=""></p><p>2.插入节点的父节点是红色，叔叔节点是黑色，且插入节点是其父节点的右子节点。</p><p>情况2的示意图为第一步操作的结果。相当于插入当前结点7.</p><p><strong>调整：</strong>将当前节点(7)的父节点(2)作为新的节点，以(2)为支点做左旋(LR)操作.</p><p><img src="https://i.imgur.com/yoP1mMb.png" alt=""></p><p>3.插入节点的父节点是红色，叔叔节点是黑色，且插入节点是其父节点的左子节点。</p><p>情况3的示意图为第二步操作的结果。相当于插入当前结点2.</p><p><strong>调整：</strong>将当前节点的父节点(7)涂黑，将祖父节点(11)涂红，在祖父节点(11)为支点做右旋操作.</p><p><img src="https://i.imgur.com/QYM4k1S.png" alt=""></p><p><strong>总结：</strong>整个完整的流程是从：变色-左旋-右旋。也可能直接从情况2或3开始。</p><p>参考文档一：<a href="https://blog.csdn.net/eson_15/article/details/51144079" target="_blank" rel="noopener">https://blog.csdn.net/eson_15/article/details/51144079</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;红黑树的定义？&quot;&gt;&lt;a href=&quot;#红黑树的定义？&quot; class=&quot;headerlink&quot; title=&quot;红黑树的定义？&quot;&gt;&lt;/a&gt;红黑树的定义？&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/y7nMfe8.jpg&quot; alt=&quot;&quot;&gt;
      
    
    </summary>
    
      <category term="树" scheme="http://www.xuchunfa.cn/categories/%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>平衡二叉树</title>
    <link href="http://www.xuchunfa.cn/2018/08/13/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://www.xuchunfa.cn/2018/08/13/平衡二叉树/</id>
    <published>2018-08-13T13:16:21.000Z</published>
    <updated>2018-08-14T06:06:51.552Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是平衡二叉树（AVL树）？"><a href="#什么是平衡二叉树（AVL树）？" class="headerlink" title="什么是平衡二叉树（AVL树）？"></a>什么是平衡二叉树（AVL树）？</h4><ol><li>可以为空</li><li>任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过1。简单来讲就是任意结点的左右子树的数目基本相同。</li><li>平衡二叉树是二叉查找树的优化，因为二叉查找树适用于无序数据，对于<br>有序数据插入时就是一颗斜树，遍历时的时间复杂度为O(n),已经体现不出了优势了。</li></ol><h4 id="怎么调整平衡二叉树？"><a href="#怎么调整平衡二叉树？" class="headerlink" title="怎么调整平衡二叉树？"></a>怎么调整平衡二叉树？</h4><p>举个LR旋转的例子：</p><p><img src="https://i.imgur.com/jBi58WA.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是平衡二叉树（AVL树）？&quot;&gt;&lt;a href=&quot;#什么是平衡二叉树（AVL树）？&quot; class=&quot;headerlink&quot; title=&quot;什么是平衡二叉树（AVL树）？&quot;&gt;&lt;/a&gt;什么是平衡二叉树（AVL树）？&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;可以为空&lt;/li&gt;
&lt;l
      
    
    </summary>
    
      <category term="树" scheme="http://www.xuchunfa.cn/categories/%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>打印从1到最大的n位数</title>
    <link href="http://www.xuchunfa.cn/2018/08/11/%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/"/>
    <id>http://www.xuchunfa.cn/2018/08/11/打印从1到最大的n位数/</id>
    <published>2018-08-11T12:23:13.000Z</published>
    <updated>2018-08-11T12:36:46.083Z</updated>
    
    <content type="html"><![CDATA[<h4 id="打印从1到最大的n位数？"><a href="#打印从1到最大的n位数？" class="headerlink" title="打印从1到最大的n位数？"></a>打印从1到最大的n位数？</h4><pre><code>public class Print1ToMaxOfNdigits {public static void print1ToMaxOfNdigits(int n){    if(n &lt;= 0){        throw new RuntimeException(&quot;参数非法&quot;);    }    char[] nums = new char[n+1];    nums[n] = &apos;\0&apos;;    for(int i = 0;i&lt;10;i++){        nums[0] = (char) (i + &apos;0&apos;);        everyBigitRecursive(nums,n,0);    }}private static void everyBigitRecursive(char[] nums, int length, int index) {    if(index == length-1){        printNum(nums);        return;    }    for(int i = 0;i&lt;10;i++){        //向个位递进        nums[index + 1] = (char) (i + &apos;0&apos;);        everyBigitRecursive(nums,length,index+1);    }}private static void printNum(char[] nums) {    boolean isBegin0 = true;    for(int i = 0;i &lt; nums.length;i++){        if(isBegin0 &amp;&amp; nums[i] != &apos;0&apos;)            isBegin0 = false;        if(!isBegin0){            System.out.print(nums[i]);        }    }    System.out.println();}public static void main(String[] args){    Print1ToMaxOfNdigits.print1ToMaxOfNdigits(10);}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;打印从1到最大的n位数？&quot;&gt;&lt;a href=&quot;#打印从1到最大的n位数？&quot; class=&quot;headerlink&quot; title=&quot;打印从1到最大的n位数？&quot;&gt;&lt;/a&gt;打印从1到最大的n位数？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public class Print1ToM
      
    
    </summary>
    
      <category term="字符串" scheme="http://www.xuchunfa.cn/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>指数幂运算</title>
    <link href="http://www.xuchunfa.cn/2018/08/11/%E6%8C%87%E6%95%B0%E5%B9%82%E8%BF%90%E7%AE%97/"/>
    <id>http://www.xuchunfa.cn/2018/08/11/指数幂运算/</id>
    <published>2018-08-11T06:58:18.000Z</published>
    <updated>2018-08-11T06:59:54.472Z</updated>
    
    <content type="html"><![CDATA[<h4 id="计算a的n次幂考虑边界情况？"><a href="#计算a的n次幂考虑边界情况？" class="headerlink" title="计算a的n次幂考虑边界情况？"></a>计算a的n次幂考虑边界情况？</h4><pre><code>public class Pow {public static double pow(double base,int exp){    if(Double.doubleToLongBits(base) == Double.doubleToLongBits(0.00) &amp;&amp; exp == 0){        return 0.0;    }    //浮点数的比较    if(Double.doubleToLongBits(base) == Double.doubleToLongBits(0.00) &amp;&amp; exp &lt; 0){        throw new RuntimeException(&quot;参数不合法&quot;);    }    double result;    int absExp;    if(exp &lt; 0){        absExp = -exp;    }else {        absExp = exp;    }    result = calPow(base,absExp);    if(exp &lt; 0){        result = 1.0/result;    }    return result;}private static double calPow(double base, int exp) {    if(exp == 0)        return 1;    if(exp == 1)        return base;    //位移运算代替除法    double result = calPow(base,exp &gt;&gt; 1);    result *= result;    //与运算代替取余    if((exp &amp; 1) == 1){        result *= base;    }    return result;}public static void main(String[] args){    System.out.println(Pow.pow(0,-4));}</code></pre><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;计算a的n次幂考虑边界情况？&quot;&gt;&lt;a href=&quot;#计算a的n次幂考虑边界情况？&quot; class=&quot;headerlink&quot; title=&quot;计算a的n次幂考虑边界情况？&quot;&gt;&lt;/a&gt;计算a的n次幂考虑边界情况？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public class P
      
    
    </summary>
    
      <category term="位运算" scheme="http://www.xuchunfa.cn/categories/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    
  </entry>
  
  <entry>
    <title>背包问题</title>
    <link href="http://www.xuchunfa.cn/2018/08/10/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://www.xuchunfa.cn/2018/08/10/背包问题/</id>
    <published>2018-08-10T08:06:29.000Z</published>
    <updated>2018-08-15T11:53:10.738Z</updated>
    
    <content type="html"><![CDATA[<h4 id="解背包问题？"><a href="#解背包问题？" class="headerlink" title="解背包问题？"></a>解背包问题？</h4><p><img src="https://i.imgur.com/bZL8dQF.png" alt=""></p><p>例如：</p><p>int[] v = {4,2,10,1,2}</p><p>int[] w = {12,1,4,1,2}</p><p>最大价值为：15kg</p><p>c[i][m]:前i个物体放入容量为m的背包的最大价值。</p><p>v[i]:第i个物体的价值。</p><p>w[i]:第i个物体的重量。</p><p>放入第i个物体：<br>c[i][m] = c[i-1][m-w[i]] + v[i]</p><p>不放入第i个物体：<br>c[i][m] = c[i-1][m]</p><blockquote><p>动态规划</p></blockquote><p><img src="https://i.imgur.com/r8NVvQu.png" alt=""></p><pre><code>public class ThiefProblem {static int max(int a, int b) { return (a &gt; b)? a : b; }//基于递归的解法static int knapSack(int W, int wt[], int val[], int n){    if (n == 0 || W == 0)        return 0;    // If weight of the nth item is more than Knapsack capacity W, then    // this item cannot be included in the optimal solution    if (wt[n-1] &gt; W)        return knapSack(W, wt, val, n-1);        // Return the maximum of two cases:        // (1) nth item included        // (2) not included    else return max( val[n-1] + knapSack(W-wt[n-1], wt, val, n-1),            knapSack(W, wt, val, n-1)    );}//基于动态规划的解法static int maxValue(int W, int wt[], int val[], int n){   int[][] itemToValue = new int[n+1][W+1];   for(int i = 0;i&lt;W+1;i++){       itemToValue[0][i] = 0;   }   for(int j = 0;j&lt;n+1;j++){       itemToValue[j][0] = 0;   }   for(int i = 1;i&lt;=n;i++){        for(int j = 1;j&lt;=W;j++){            int weightPlus = j - wt[i-1];            if(weightPlus &lt; 0){                itemToValue[i][j] = itemToValue[i-1][j];            }else {                itemToValue[i][j] = max(itemToValue[i-1][j],itemToValue[i-1][weightPlus]+val[i-1]);            }        }   }   return itemToValue[n][W];}public static void main(String[] args){    int[] value = {6,3,5,4,6};    int[] weight = {2,3,6,5,7};    int maxWeight = 10;    int n = value.length;    //System.out.println(ThiefProblem.maxValue(value,weight,maxWeight));    System.out.println(ThiefProblem.knapSack(maxWeight,weight,value,n));}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;解背包问题？&quot;&gt;&lt;a href=&quot;#解背包问题？&quot; class=&quot;headerlink&quot; title=&quot;解背包问题？&quot;&gt;&lt;/a&gt;解背包问题？&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/bZL8dQF.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
      
    
    </summary>
    
      <category term="动态规划" scheme="http://www.xuchunfa.cn/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>CAS的理解</title>
    <link href="http://www.xuchunfa.cn/2018/08/09/CAS%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://www.xuchunfa.cn/2018/08/09/CAS的理解/</id>
    <published>2018-08-09T08:01:17.000Z</published>
    <updated>2018-08-09T08:27:18.059Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原子操作类</p></blockquote><ol><li>原子更新基本类型</li><li>原子更新数组类型</li><li>原子更新引用</li><li>原子更新属性</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原子操作类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;原子更新基本类型&lt;/li&gt;
&lt;li&gt;原子更新数组类型&lt;/li&gt;
&lt;li&gt;原子更新引用&lt;/li&gt;
&lt;li&gt;原子更新属性&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
      <category term="Java并发编程" scheme="http://www.xuchunfa.cn/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap的理解</title>
    <link href="http://www.xuchunfa.cn/2018/08/08/ConcurrentHashMap%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://www.xuchunfa.cn/2018/08/08/ConcurrentHashMap的理解/</id>
    <published>2018-08-08T11:47:32.000Z</published>
    <updated>2018-08-09T05:51:20.901Z</updated>
    
    <content type="html"><![CDATA[<p><strong>JDK1.7源码的参数</strong></p><ul><li><p>参数</p><p>  1.DEFAULT_CONCURRENCY_LEVEL：简单看成是segment的个数，即并发度。默认值：16。</p><p>  2.MAX_SEGMENTS：segment的最大个数。值为2^16=65536</p><p>  3.segmentMask:默认值15。</p><p>  4.segmentShift:默认值28。</p></li><li><p>初始化操作</p><p>  1.Segment[i] 为每个段桶的数目(必须为2^n)，默认值为2，负载因子是 0.75，得出初始阈值为 1.5，也就是以后插入第一个元素不会触发扩容，插入第二个会进行第一次扩容。</p><p>  2.</p></li><li><p>定位Segment的散列算法</p><p>  1.(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask：即让hash值的高4位与掩码做与运算。</p></li><li><p>定位HashEntry的散列算法</p><p>  int index = (tab.length - 1) &amp; hash;</p></li></ul><ul><li>Put操作流程</li></ul><p>1.定位到Segment</p><p>2.初始化segment的某一段，ensureSegment(int k)。</p><p>3.获取锁，scanAndLockForPut(key, hash, value);</p><p>5.如果需要的话，进行扩容。segment数组是不能扩容的，扩容的对象是HashEntry数组，该方法不需要考虑并发的，因为此时segment分段锁被独占的。</p><blockquote><p>Segment&lt;K,V&gt;的理解</p></blockquote><p>1.HashEntry&lt;K,V&gt;[] table：每个segment有一个HashEntry数组。</p><p>2.count：</p><p>3.HashEntry&lt;K,V&gt;：一个四元组，next被声明成final,所以每次插入元素都只能头插。node&lt;K,V&gt;的next域呢？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;JDK1.7源码的参数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;参数&lt;/p&gt;
&lt;p&gt;  1.DEFAULT_CONCURRENCY_LEVEL：简单看成是segment的个数，即并发度。默认值：16。&lt;/p&gt;
&lt;p&gt;  2.MAX_SEGMENTS
      
    
    </summary>
    
      <category term="Java并发编程" scheme="http://www.xuchunfa.cn/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>HashMap原理解析</title>
    <link href="http://www.xuchunfa.cn/2018/08/07/HashMap%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>http://www.xuchunfa.cn/2018/08/07/HashMap原理解析/</id>
    <published>2018-08-07T08:01:32.000Z</published>
    <updated>2018-08-18T08:09:07.408Z</updated>
    
    <content type="html"><![CDATA[<h4 id="哈希表的长度为什么要为2-n"><a href="#哈希表的长度为什么要为2-n" class="headerlink" title="哈希表的长度为什么要为2^n?"></a>哈希表的长度为什么要为2^n?</h4><pre><code>因为当哈希表的长度为2^n次方时，hash &amp; (length-1) == hash % length</code></pre><h4 id="查找到哈希表中元素的条件？"><a href="#查找到哈希表中元素的条件？" class="headerlink" title="查找到哈希表中元素的条件？"></a>查找到哈希表中元素的条件？</h4><pre><code>for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next){e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))}//键值包括int和String类型</code></pre><h4 id="HashMap怎么处理key为null元素"><a href="#HashMap怎么处理key为null元素" class="headerlink" title="HashMap怎么处理key为null元素"></a>HashMap怎么处理key为null元素</h4><pre><code>所有key为null的元素放在了table[0]的桶里面了。private V putForNullKey(V value) {    for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) {        if (e.key == null) {            V oldValue = e.value;            e.value = value;            e.recordAccess(this);            return oldValue;        }    }    modCount++;    addEntry(0, null, value, 0);    return null;}</code></pre><h4 id="HashTable和HashMap的区别"><a href="#HashTable和HashMap的区别" class="headerlink" title="HashTable和HashMap的区别"></a>HashTable和HashMap的区别</h4><pre><code>1.前者线程安全的,但是效率低。2.前者的键和值都不允许为空，而后者的key和value都允许为空。</code></pre><blockquote><p>JDK1.8的源码注释总结</p></blockquote><p>1.HashMap允许键和值为空，而且是不同步的，非线程安全的，而HashTable不允许键值为空。</p><p>2.HashMap的两个重要参数：</p><ul><li><p>DEFAULT_INITIAL_CAPACITY:默认的初始容量。默认值16。</p></li><li><p>DEFAULT_LOAD_FACTOR:负载因子，用来衡量哈希表满的程度。默认值0.75。</p></li><li><p>threshold:存放元素的阈值。threshold = capacity * load factor.当key-value对的数量大于threshold，将调用resize()方法。</p></li></ul><p>其他参数：</p><ul><li><p>MAXIMUM_CAPACITY：最大容量。为2^30.</p></li><li><p>TREEIFY_THRESHOLD:链表转化成红黑树的临界值。默认值为8。</p></li><li><p>UNTREEIFY_THRESHOLD：当执行resize操作时，当桶中bin的数量少于UNTREEIFY_THRESHOLD时使用链表来代替树。默认值是6。</p></li><li><p>MIN_TREEIFY_CAPACITY：当桶中的bin被树化时最小的hash表容量。默认值64.</p></li></ul><p><strong>3.把Map元素哈希到桶的索引方法</strong></p><p>1.将key.hashcode() 与 哈希值的高16位作异或运算。</p><pre><code>(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</code></pre><p>2.将1步得到的值进行取模运算(取模哈希桶的长度，长度为2^n)，而方法采用的是高效的与运算。咋证明的呢？？？</p><pre><code>i = (table.length - 1) &amp; hash</code></pre><p>3.jdk1.8中的rehash的理解。</p><p>在确定元素在新数组的下标时，我们只需要检测元素的hash值与oldCap作与操作的结果是否为0：</p><p>为0，那么下标还是原来的下标。</p><p>为1，那么下标等于原来下标加上旧数组长度。</p><pre><code>为0的情况由loHead和loTail这组指针维护。为1的情况由hiHead和hiTail这组指针维护。</code></pre><p>如图所示：<br><img src="https://i.imgur.com/8h4npik.png" alt=""></p><h4 id="JDK1-8-HashMap源码中方法的理解？"><a href="#JDK1-8-HashMap源码中方法的理解？" class="headerlink" title="JDK1.8 HashMap源码中方法的理解？"></a>JDK1.8 HashMap源码中方法的理解？</h4><p>1.get(Object key)方法：</p><pre><code>//获取链表中的结点public V get(Object key) {    Node&lt;K,V&gt; e;    return (e = getNode(hash(key), key)) == null ? null : e.value;}final Node&lt;K,V&gt; getNode(int hash, Object key) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;        (first = tab[(n - 1) &amp; hash]) != null) {        if (first.hash == hash &amp;&amp; // always check first node            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))//第一个结点就是目标结点，其中key有可能为空            return first;        if ((e = first.next) != null) {//第一个结点排除，继续遍历下一个结点            if (first instanceof TreeNode)//红黑树的查找结点方法                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);//从树的根节点开始查找            do {//从链表的第二个结点开始遍历                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    return e;            } while ((e = e.next) != null);        }    }    return null;//没找到}//获取红黑树中的结点final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) {        return ((parent != null) ? root() : this).find(h, k, null);    }//查找红黑树中的结点final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) {    TreeNode&lt;K,V&gt; p = this;    do {        int ph, dir; K pk;        TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;        if ((ph = p.hash) &gt; h)            p = pl;        else if (ph &lt; h)            p = pr;        else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk)))            return p;        else if (pl == null)            p = pr;        else if (pr == null)            p = pl;        else if ((kc != null ||                (kc = comparableClassFor(k)) != null) &amp;&amp;                (dir = compareComparables(kc, k, pk)) != 0)            p = (dir &lt; 0) ? pl : pr;        else if ((q = pr.find(h, k, kc)) != null)//先去右子树中去查找            return q;//找到直接返回        else            p = pl;//去左子树中去查找    } while (p != null);    return null;}</code></pre><p>2.put(K key,V value)方法：</p><pre><code>public V put(K key, V value) {    return putVal(hash(key), key, value, false, true);}//插入key-value对final V putVal(int hash, K key, V value, boolean onlyIfAbsent,               boolean evict) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;    if ((tab = table) == null || (n = tab.length) == 0)        n = (tab = resize()).length;//哈希表为空的话,resize()初始化。默认初始容量16,负载因子0.75    if ((p = tab[i = (n - 1) &amp; hash]) == null)        tab[i] = newNode(hash, key, value, null);//如果哈希表的索引位置还没元素,就直接插入    else {        Node&lt;K,V&gt; e; K k;        if (p.hash == hash &amp;&amp;                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))            e = p;//目标结点直接替代        else if (p instanceof TreeNode)            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);        else {            for (int binCount = 0; ; ++binCount) {                if ((e = p.next) == null) {                    p.next = newNode(hash, key, value, null);                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) //插入第7个结点后将链表转化成树                        treeifyBin(tab, hash);//形成树结点                    break;                }                if (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    break;                p = e;            }        }        if (e != null) { // existing mapping for key            V oldValue = e.value;            if (!onlyIfAbsent || oldValue == null)                e.value = value;            afterNodeAccess(e);            return oldValue;        }    }    ++modCount;    if (++size &gt; threshold)        resize();    afterNodeInsertion(evict);    return null;}</code></pre><p>2.1 往红黑树中插入结点</p><pre><code>//红黑树中通过比较hash值的大小插入树结点final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,                               int h, K k, V v) {    Class&lt;?&gt; kc = null;    boolean searched = false;    TreeNode&lt;K,V&gt; root = (parent != null) ? root() : this;    for (TreeNode&lt;K,V&gt; p = root;;) {        int dir, ph; K pk;        if ((ph = p.hash) &gt; h)//传入结点的hash值小于p结点的hash值的话            dir = -1;//选择左子树        else if (ph &lt; h)            dir = 1;//选择右子树        else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk)))            return p;//返回第一个结点,默认是根结点        else if ((kc == null &amp;&amp;                (kc = comparableClassFor(k)) == null) ||//k所属的类没有实现Comparable接口                (dir = compareComparables(kc, k, pk)) == 0) {//或者类k的大小相等            if (!searched) {                TreeNode&lt;K,V&gt; q, ch;                searched = true;                if (((ch = p.left) != null &amp;&amp;                        (q = ch.find(h, k, kc)) != null) ||//左子树不为空,去左子树查找                        ((ch = p.right) != null &amp;&amp;                                (q = ch.find(h, k, kc)) != null))//右子树不为空,去右子树查找                    return q;            }            dir = tieBreakOrder(k, pk);//其他比较key的方法        }        TreeNode&lt;K,V&gt; xp = p;        if ((p = (dir &lt;= 0) ? p.left : p.right) == null) {//找到要插入x结点的位置            Node&lt;K,V&gt; xpn = xp.next;//树结点仍然有next结点,同时要维护红黑树结点和链表结点,两者可以互相转换            TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);//x结点在xp和xpn之间            if (dir &lt;= 0)                xp.left = x;            else                xp.right = x;            xp.next = x;            x.parent = x.prev = xp;            if (xpn != null)                ((TreeNode&lt;K,V&gt;)xpn).prev = x;            moveRootToFront(tab, balanceInsertion(root, x));//红黑树插入结点后的调整            return null;        }    }}</code></pre><p>2.2 插入树结点后的结点调整</p><pre><code>//插入树结点后的红黑树结点的调整static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root,                                            TreeNode&lt;K,V&gt; x) {    x.red = true;//插入的结点默认红色    for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) {        if ((xp = x.parent) == null) {//插入的结点为根结点,则变为黑色            x.red = false;            return x;        }        else if (!xp.red || (xpp = xp.parent) == null)//xp为黑色            return root;//x为根结点的子结点,为啥要返回根结点???        if (xp == (xppl = xpp.left)) {            if ((xppr = xpp.right) != null &amp;&amp; xppr.red) {//父结点和叔叔结点都为红                xppr.red = false;//叔叔结点涂为黑色                xp.red = false;//父结点涂为黑色                xpp.red = true;//祖父结点涂为红色                x = xpp;//当前结点指向祖父结点            }            else {                if (x == xp.right) {//叔叔结点为黑色,当前结点是父结点的右结点                    root = rotateLeft(root, x = xp);//以父结点为轴左旋                    xpp = (xp = x.parent) == null ? null : xp.parent;                }                if (xp != null) {//叔叔结点为黑色,当前结点是父结点的左结点                    xp.red = false;//父结点涂为黑色                    if (xpp != null) {                        xpp.red = true;//祖父结点涂为红色                        root = rotateRight(root, xpp);//以祖父结点为轴进行右旋                    }                }            }        }        else {//父结点是祖父结点的右结点,与上面相反            if (xppl != null &amp;&amp; xppl.red) {                xppl.red = false;                xp.red = false;                xpp.red = true;                x = xpp;            }            else {                if (x == xp.left) {                    root = rotateRight(root, x = xp);                    xpp = (xp = x.parent) == null ? null : xp.parent;                }                if (xp != null) {                    xp.red = false;                    if (xpp != null) {                        xpp.red = true;                        root = rotateLeft(root, xpp);                    }                }            }        }    }}</code></pre><p>2.3 插入链表的结点数目大于等于7时,转化为树结点，形成红黑树：</p><pre><code>//将链表结点转化为树结点,但仍然维护链表的结构final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {    int n, index; Node&lt;K,V&gt; e;    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)//64        resize();//此时使用默认参数新建哈希表    else if ((e = tab[index = (n - 1) &amp; hash]) != null) {        TreeNode&lt;K,V&gt; hd = null, tl = null;        do {            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);//将e节点变为树结点            if (tl == null)//tl代表树的尾结点                hd = p;//hd代表头结点            else {                p.prev = tl;                tl.next = p;            }            tl = p;//尾结点指向新插入的结点        } while ((e = e.next) != null);        if ((tab[index] = hd) != null)//桶的坐标指向红黑树的头结点            hd.treeify(tab);    }}//真正形成红黑树的结构final void treeify(Node&lt;K,V&gt;[] tab) {    TreeNode&lt;K,V&gt; root = null;    for (TreeNode&lt;K,V&gt; x = this, next; x != null; x = next) {        next = (TreeNode&lt;K,V&gt;)x.next;        x.left = x.right = null;        if (root == null) {//根节点为黑色            x.parent = null;            x.red = false;            root = x;        }        else {            K k = x.key;            int h = x.hash;            Class&lt;?&gt; kc = null;            for (TreeNode&lt;K,V&gt; p = root;;) {                int dir, ph;                K pk = p.key;                if ((ph = p.hash) &gt; h)//插入结点的哈希值小于根节点                    dir = -1;//插入左子树                else if (ph &lt; h)                    dir = 1;                else if ((kc == null &amp;&amp;                        (kc = comparableClassFor(k)) == null) ||                        (dir = compareComparables(kc, k, pk)) == 0)                    dir = tieBreakOrder(k, pk);                TreeNode&lt;K,V&gt; xp = p;                if ((p = (dir &lt;= 0) ? p.left : p.right) == null) {                    x.parent = xp;                    if (dir &lt;= 0)                        xp.left = x;                    else                        xp.right = x;                    root = balanceInsertion(root, x);//调整红黑树的结构                    break;                }            }        }    }    moveRootToFront(tab, root);}</code></pre><p>3.resize()方法：</p><pre><code>//构建默认哈希表和扩容final Node&lt;K,V&gt;[] resize() {    Node&lt;K,V&gt;[] oldTab = table;    int oldCap = (oldTab == null) ? 0 : oldTab.length;    int oldThr = threshold;    int newCap, newThr = 0;    if (oldCap &gt; 0) {        if (oldCap &gt;= MAXIMUM_CAPACITY) {//2^30            threshold = Integer.MAX_VALUE;            return oldTab;        }        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;                oldCap &gt;= DEFAULT_INITIAL_CAPACITY)//扩容两倍后的容量小于2^30 而且原表的容量大于等于默认的16            newThr = oldThr &lt;&lt; 1; // 是 threshold = capacity * load factor 扩容两倍。注意扩容的对象,threshold默认是16    }    else if (oldThr &gt; 0) // initial capacity was placed in threshold        newCap = oldThr;    else {               // zero initial threshold signifies using defaults        newCap = DEFAULT_INITIAL_CAPACITY;//16        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);//16*0.75=12    }    if (newThr == 0) {        float ft = (float)newCap * loadFactor;        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                (int)ft : Integer.MAX_VALUE);    }    threshold = newThr;    @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];    table = newTab;    if (oldTab != null) {        for (int j = 0; j &lt; oldCap; ++j) {            Node&lt;K,V&gt; e;            if ((e = oldTab[j]) != null) {                oldTab[j] = null;                if (e.next == null)                    newTab[e.hash &amp; (newCap - 1)] = e;                else if (e instanceof TreeNode)                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);//还原成链表或修剪树                else { // preserve order                    Node&lt;K,V&gt; loHead = null, loTail = null;                    Node&lt;K,V&gt; hiHead = null, hiTail = null;                    Node&lt;K,V&gt; next;                    do {                        next = e.next;                        if ((e.hash &amp; oldCap) == 0) {//旧表的元素和旧表的长度作与运算,为0时表示元素在新表中的index不变                            if (loTail == null)                                loHead = e;                            else                                loTail.next = e;                            loTail = e;                        }                        else {//为1表示元素在新表中的Index为:oldIndex + oldCap(旧索引+旧表长度)                            if (hiTail == null)                                hiHead = e;                            else                                hiTail.next = e;                            hiTail = e;                        }                    } while ((e = next) != null);                    if (loTail != null) {                        loTail.next = null;                        newTab[j] = loHead;                    }                    if (hiTail != null) {                        hiTail.next = null;                        newTab[j + oldCap] = hiHead;                    }                }            }        }    }    return newTab;}</code></pre><p><strong>4.JDK1.7版本hashMap线程不安全的原因？</strong></p><p>1.因为扩容后可能会出现结点顺序反掉的情况。</p><p>源码：</p><pre><code>void transfer(Entry[] newTable, boolean rehash) {          while(null != e) {              Entry&lt;K,V&gt; next = e.next;                       if (rehash) {                  e.hash = null == e.key ? 0 : hash(e.key);              }              int i = indexFor(e.hash, newCapacity);               e.next = newTable[i];              newTable[i] = e;              e = next;          }     }  }</code></pre><p>在进行哈希表扩容的时候，如果是多线程的话，则会因为transfer()(采用的头插法)原因，会出现循环链表的情况。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;哈希表的长度为什么要为2-n&quot;&gt;&lt;a href=&quot;#哈希表的长度为什么要为2-n&quot; class=&quot;headerlink&quot; title=&quot;哈希表的长度为什么要为2^n?&quot;&gt;&lt;/a&gt;哈希表的长度为什么要为2^n?&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;因为当哈希表的长度为2^
      
    
    </summary>
    
      <category term="Java并发编程" scheme="http://www.xuchunfa.cn/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>二进制中1的个数</title>
    <link href="http://www.xuchunfa.cn/2018/08/07/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://www.xuchunfa.cn/2018/08/07/二进制中1的个数/</id>
    <published>2018-08-07T05:13:50.000Z</published>
    <updated>2018-08-07T05:14:54.006Z</updated>
    
    <content type="html"><![CDATA[<h4 id="计算二进制中的1的个数？"><a href="#计算二进制中的1的个数？" class="headerlink" title="计算二进制中的1的个数？"></a>计算二进制中的1的个数？</h4><pre><code>public class Count1 {//循环次数为num的位数public static int count2(int num){    int count = 0;    int flag = 1;    while (flag != 0){        if((num &amp; flag) != 0){            count++;        }        flag = flag &lt;&lt; 1;    }    return count;}public static int count1(int num){    int count = 0;    while (num != 0){        num = num &amp; num-1;        count++;    }    return count;}public static void main(String[] args){    System.out.println(Count1.count1(0));}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;计算二进制中的1的个数？&quot;&gt;&lt;a href=&quot;#计算二进制中的1的个数？&quot; class=&quot;headerlink&quot; title=&quot;计算二进制中的1的个数？&quot;&gt;&lt;/a&gt;计算二进制中的1的个数？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public class Count1 {

      
    
    </summary>
    
      <category term="位运算" scheme="http://www.xuchunfa.cn/categories/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="http://www.xuchunfa.cn/2018/08/06/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://www.xuchunfa.cn/2018/08/06/位运算/</id>
    <published>2018-08-06T13:21:30.000Z</published>
    <updated>2018-08-11T06:16:00.025Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>移位实现乘除运算</p></blockquote><p>除2 = 右移1位 乘2 = 左移1位 </p><p>除4 = 右移2位 乘4 = 左移2位 </p><p>除8 = 右移3位 乘8 = 左移3位 </p><blockquote><p>取余运算用位运算与来代替</p></blockquote><p>A % B - A &amp; (B - 1)其中满足 A&gt;0 And B = 2^n</p><p><strong>其中&gt;&gt;&gt;表示：</strong>无符号右移，忽略符号位，空位都以0补齐,在hashMap中有用到。</p><blockquote><p>要注意带符号类型的左右移位</p></blockquote><p>将负值向右移位可生成原始值一半的值（向下舍入）。 例如，-253（二进制 11111111 00000011）向右移动 1 位会生成 -127（二进制 11111111 10000001）。 将 + 253 向右移位生成 +126。</p><p><strong>注：</strong></p><p>1.如果数字是有符号正数，右移n位，则在最左边补n个0;</p><p>2.如果数字是有符号负数，右移n位，则在最左边补n个1;</p><p>3.如果一个数字，左移n位，则在最右边补n个0;</p><blockquote><p>一个数减去一后再与原本的自己做位与运算，得到的结果是将原数二进制中最右边的1变为0</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;移位实现乘除运算&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;除2 = 右移1位 乘2 = 左移1位 &lt;/p&gt;
&lt;p&gt;除4 = 右移2位 乘4 = 左移2位 &lt;/p&gt;
&lt;p&gt;除8 = 右移3位 乘8 = 左移3位 &lt;/p&gt;
&lt;blockquote&gt;

      
    
    </summary>
    
      <category term="位运算" scheme="http://www.xuchunfa.cn/categories/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    
  </entry>
  
</feed>
