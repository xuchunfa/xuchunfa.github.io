<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Flying in the ocean of knowledge</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xuchunfa.cn/"/>
  <updated>2018-09-03T11:49:04.504Z</updated>
  <id>http://www.xuchunfa.cn/</id>
  
  <author>
    <name>Xu chunfa</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>结点的最近祖先</title>
    <link href="http://www.xuchunfa.cn/2018/09/03/%E7%BB%93%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E7%A5%96%E5%85%88/"/>
    <id>http://www.xuchunfa.cn/2018/09/03/结点的最近祖先/</id>
    <published>2018-09-03T11:46:51.000Z</published>
    <updated>2018-09-03T11:49:04.504Z</updated>
    
    <content type="html"><![CDATA[<h4 id="两个结点的最近祖先？"><a href="#两个结点的最近祖先？" class="headerlink" title="两个结点的最近祖先？"></a>两个结点的最近祖先？</h4><pre><code>public class CommonAncestor {//树为二叉搜索树的情况，默认node1 node2已经存在树中public BinaryTreeNode findCommonAncestor(BinaryTreeNode pRoot,int node1,int node2){    if(pRoot.data &gt; node1 &amp;&amp; pRoot.data &lt; node2 || pRoot.data &lt; node1 &amp;&amp; pRoot.data &gt; node2)        return pRoot;    if(node1 &lt; pRoot.data &amp;&amp; node2 &lt; pRoot.data){        return findCommonAncestor(pRoot.left,node1,node2);    }else if(node1 &gt; pRoot.data &amp;&amp; node2 &gt; pRoot.data){        return findCommonAncestor(pRoot.right,node1,node2);    }    return null;}//树为普通二叉树递归解法public BinaryTreeNode findCommonAncestor1(BinaryTreeNode pRoot,int node1,int node2){    //判断两个结点在同一条分支上？？？    if(pRoot == null)        return null;    if(pathIsExisted(pRoot.left,node1)){        if(pathIsExisted(pRoot.right,node2)) {            return pRoot;        }else//两个结点都在左子树中继续向下递归            return findCommonAncestor1(pRoot.left,node1,node2);    }else {        if(pathIsExisted(pRoot.left,node2))            return pRoot;        else//两个结点都在右子树中继续向下递归            return findCommonAncestor1(pRoot.right,node1,node2);    }}//判断路径中是否存在指定结点的值public boolean pathIsExisted(BinaryTreeNode pRoot,int node){    if(pRoot == null)        return false;    if(pRoot.data == node)        return true;    boolean flag = pathIsExisted(pRoot.left,node);    //如果找到了就不用继续递归了    if(!flag){        flag = pathIsExisted(pRoot.right,node);    }    return flag;}//树为普通二叉树非递归解法public BinaryTreeNode findCommonAncestor2(BinaryTreeNode pRoot,int node1,int node2){    //list1和list2保存根节点到目标结点的路径    List&lt;BinaryTreeNode&gt; list1 = new ArrayList&lt;BinaryTreeNode&gt;();    boolean path1 = findPath(pRoot,node1,list1);    List&lt;BinaryTreeNode&gt; list2 = new ArrayList&lt;BinaryTreeNode&gt;();    boolean path2 = findPath(pRoot,node2,list2);    BinaryTreeNode ancestor = null;    Iterator list1Iterator = list1.iterator();    Iterator list2Iterator = list2.iterator();    int diffIndex = -1;//默认没有出现两个不同的节点    int i = 0;    //找到两条路径岔开的那个位置结点，那么前一个结点就是最后一个公共路径上的结点，也就是最近的祖先    if(path1 &amp;&amp; path2){        while (list1Iterator.hasNext() &amp;&amp; list2Iterator.hasNext()){            if(list1Iterator.next() != list2Iterator.next()){                diffIndex = --i;                break;            }            i++;        }    }    if(diffIndex &gt;= 0)        ancestor = list1.get(diffIndex);    //diffIndex = -1 表示node1和node2在同一条路径上    return ancestor;}//保存包含指定节点路径结点的方法public boolean findPath(BinaryTreeNode pRoot, int node, List&lt;BinaryTreeNode&gt; list){    if(pRoot ==  null)        return false;    list.add(pRoot);    if(pRoot.data == node)        return true;    boolean isExisted = findPath(pRoot.left,node,list);    if(!isExisted){        isExisted = findPath(pRoot.right,node,list);    }    if(!isExisted)        list.remove(list.size()-1);    return isExisted;}public static void main(String[] args){    BinaryTree tree = new BinaryTree();    tree.createBinaryTree(tree.getRoot(),8);    tree.createBinaryTree(tree.getRoot(),3);    tree.createBinaryTree(tree.getRoot(),2);    tree.createBinaryTree(tree.getRoot(),5);    tree.createBinaryTree(tree.getRoot(),1);    tree.createBinaryTree(tree.getRoot(),12);    tree.createBinaryTree(tree.getRoot(),9);    CommonAncestor test = new CommonAncestor();    System.out.println(test.findCommonAncestor1(tree.getRoot(),3,2).data);}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;两个结点的最近祖先？&quot;&gt;&lt;a href=&quot;#两个结点的最近祖先？&quot; class=&quot;headerlink&quot; title=&quot;两个结点的最近祖先？&quot;&gt;&lt;/a&gt;两个结点的最近祖先？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public class CommonAncestor {

      
    
    </summary>
    
      <category term="树" scheme="http://www.xuchunfa.cn/categories/%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>丑数</title>
    <link href="http://www.xuchunfa.cn/2018/09/03/%E4%B8%91%E6%95%B0/"/>
    <id>http://www.xuchunfa.cn/2018/09/03/丑数/</id>
    <published>2018-09-03T02:30:46.000Z</published>
    <updated>2018-09-03T02:33:02.339Z</updated>
    
    <content type="html"><![CDATA[<h4 id="求解指定索引的丑数？"><a href="#求解指定索引的丑数？" class="headerlink" title="求解指定索引的丑数？"></a>求解指定索引的丑数？</h4><pre><code>public class UglyNumber {public static int resolve(int index){    if(index &lt;= 0){        throw new RuntimeException(&quot;参数非法&quot;);    }    int[] uglyNumber = new int[index];    uglyNumber[0] = 1;    int indexOf2,indexOf3,indexOf5;    indexOf2 = indexOf3 = indexOf5 = 0;    int uglyNumberIndex = 1;    while (uglyNumberIndex &lt; index){        int min = Min(uglyNumber[indexOf2]*2,uglyNumber[indexOf3]*3,uglyNumber[indexOf5]*5);        uglyNumber[uglyNumberIndex] = min;        //uglyNumber[uglyNumberIndex]代表的是目前数组中最大的丑数        while (uglyNumber[indexOf2]*2 &lt;= uglyNumber[uglyNumberIndex]){            indexOf2++;        }        //下次的uglyNumber[indexOf3]肯定就大于Max uglyNumber        while (uglyNumber[indexOf3]*3 &lt;= uglyNumber[uglyNumberIndex]){            indexOf3++;        }        while (uglyNumber[indexOf5]*5 &lt;= uglyNumber[uglyNumberIndex]){            indexOf5++;        }        uglyNumberIndex++;    }    return uglyNumber[index-1];}private static int Min(int i, int j, int k) {    int min;    return (min = i &lt; j ? i : j) &lt; k ? min : k;}public static void main(String[] args){    System.out.println(UglyNumber.resolve(100));}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;求解指定索引的丑数？&quot;&gt;&lt;a href=&quot;#求解指定索引的丑数？&quot; class=&quot;headerlink&quot; title=&quot;求解指定索引的丑数？&quot;&gt;&lt;/a&gt;求解指定索引的丑数？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public class UglyNumber {

pub
      
    
    </summary>
    
      <category term="策略类" scheme="http://www.xuchunfa.cn/categories/%E7%AD%96%E7%95%A5%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>逆序对的个数</title>
    <link href="http://www.xuchunfa.cn/2018/09/03/%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://www.xuchunfa.cn/2018/09/03/逆序对的个数/</id>
    <published>2018-09-03T02:28:22.000Z</published>
    <updated>2018-09-03T02:30:34.090Z</updated>
    
    <content type="html"><![CDATA[<h4 id="逆序对的个数？"><a href="#逆序对的个数？" class="headerlink" title="逆序对的个数？"></a>逆序对的个数？</h4><pre><code>public class InversePairNum {private int count = 0;private int[] temp;//保存排好序的中间结果，再将结果拷贝到原数组public int resolve(int[] num,int length){    temp = new int[length];    divideSort(num,0,length-1);    return count;}private void divideSort(int[] num, int left, int right) {    if(left &lt; right){        int mid = (left + right)/2;        //分成一个一个元素        divideSort(num,left,mid);        divideSort(num,mid+1,right);        mergeSort(num,left,mid,right);    }}private void mergeSort(int[] num, int left, int mid, int right) {    int leftEnd = mid;    int rightEnd = right;    int tempIndex = right;    //指针从后往前移    while (leftEnd &gt;= left &amp;&amp; rightEnd &gt;= mid + 1) {        if (num[leftEnd] &gt; num[rightEnd]) {            temp[tempIndex--] = num[leftEnd--];            //不是 right - mid 右边的指针是往前挪的            count += rightEnd - mid;        } else {            temp[tempIndex--] = num[rightEnd--];        }    }    //剩余元素    while (leftEnd &gt;= left) {        temp[tempIndex--] = num[leftEnd--];    }    while (rightEnd &gt;= mid + 1) {        temp[tempIndex--] = num[rightEnd--];    }    //利用临时数组temp来使得num数组左右两边都是有序的(递增的)    for (int i = left; i &lt;= right; i++) {        num[i] = temp[i];    }}public static void main(String[] args){    InversePairNum test = new InversePairNum();    int[] num = {4,6,3,1,5,7,2};    System.out.println(test.resolve(num,num.length));}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;逆序对的个数？&quot;&gt;&lt;a href=&quot;#逆序对的个数？&quot; class=&quot;headerlink&quot; title=&quot;逆序对的个数？&quot;&gt;&lt;/a&gt;逆序对的个数？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public class InversePairNum {

private int
      
    
    </summary>
    
      <category term="数组" scheme="http://www.xuchunfa.cn/categories/%E6%95%B0%E7%BB%84/"/>
    
    
  </entry>
  
  <entry>
    <title>Java笔记</title>
    <link href="http://www.xuchunfa.cn/2018/09/02/EffectiveJava%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.xuchunfa.cn/2018/09/02/EffectiveJava笔记/</id>
    <published>2018-09-02T07:34:14.000Z</published>
    <updated>2018-09-02T08:31:39.584Z</updated>
    
    <content type="html"><![CDATA[<p>1.有时可以用静态工厂方法来代替构造器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.有时可以用静态工厂方法来代替构造器。&lt;/p&gt;

      
    
    </summary>
    
      <category term="java语言基础" scheme="http://www.xuchunfa.cn/categories/java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Lock详解</title>
    <link href="http://www.xuchunfa.cn/2018/08/30/Lock%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.xuchunfa.cn/2018/08/30/Lock详解/</id>
    <published>2018-08-30T01:19:08.000Z</published>
    <updated>2018-08-31T09:14:28.144Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Lock接口</p></blockquote><p>1.lock()：获取锁。</p><p>2.lockInterruptibly():可中断的获取锁，不同于lock(),在锁的获取中可以中断当前线程。</p><p>3.tryLock()：尝试非阻塞的获取锁。</p><p>4.tryLock(long time, TimeUnit unit)：超时获取锁。</p><p>5.unlock()：释放锁。</p><p>6.newCondition()：获取等待通知组件。</p><h4 id="为什么锁的实现中使用组合同步器而不选择继承呢？"><a href="#为什么锁的实现中使用组合同步器而不选择继承呢？" class="headerlink" title="为什么锁的实现中使用组合同步器而不选择继承呢？"></a>为什么锁的实现中使用组合同步器而不选择继承呢？</h4><blockquote><p>队列同步器</p></blockquote><p>1.同步器是实现锁的关键。锁是面象用户的,用户不需要了解其中的底层原理，同步器是面象锁的,是关于锁实现的原理细节。</p><p>2.队列同步器的实现</p><p>独占式同步状态流程图如下：</p><pre><code>//tryAcquire(arg) == false 则获取同步状态失败，线程进入同步队列public final void acquire(int arg) {    if (!tryAcquire(arg) &amp;&amp;        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))        selfInterrupt();}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Lock接口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.lock()：获取锁。&lt;/p&gt;
&lt;p&gt;2.lockInterruptibly():可中断的获取锁，不同于lock(),在锁的获取中可以中断当前线程。&lt;/p&gt;
&lt;p&gt;3.tryLock()：
      
    
    </summary>
    
      <category term="Java并发编程" scheme="http://www.xuchunfa.cn/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>单例模式的不同写法</title>
    <link href="http://www.xuchunfa.cn/2018/08/28/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%8D%E5%90%8C%E5%86%99%E6%B3%95/"/>
    <id>http://www.xuchunfa.cn/2018/08/28/单例模式的不同写法/</id>
    <published>2018-08-28T08:41:34.000Z</published>
    <updated>2018-08-28T09:13:08.258Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>饿汉模式</p><p>  1.基于类加载的机制</p></li><li><p>懒汉模式（线程不安全）</p><pre><code>   public class Singleton {    private static Singleton instance;    private Singleton (){  }     public static Singleton getInstance() {    if (instance == null) {            instance = new Singleton();    }    return instance;    }  }  </code></pre></li></ul><ul><li><p>懒汉模式（线程安全）</p><p>  1.同步开销大,效率不高。</p></li></ul><ul><li><p>双重检查模式（DCL）</p><p>  1.还是会在某些情况下出现DCL失效的情况。</p></li></ul><ul><li>静态内部单例模式</li></ul><pre><code>    public class Singleton {     private Singleton(){        }      public static Singleton getInstance(){          return SingletonHolder.sInstance;      }      private static class SingletonHolder {      private static final Singleton sInstance = new Singleton();      }      } 1.第一次加载Singleton类不会实例化对象,只有在调用getInstance()方法时才会引起SingletonHolder类加载，然后再进行实例化。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;饿汉模式&lt;/p&gt;
&lt;p&gt;  1.基于类加载的机制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;懒汉模式（线程不安全）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   public class Singleton {  
  private static Singleton in
      
    
    </summary>
    
      <category term="Java设计模式" scheme="http://www.xuchunfa.cn/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>最长不含重复字符的子字符串</title>
    <link href="http://www.xuchunfa.cn/2018/08/27/%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://www.xuchunfa.cn/2018/08/27/最长不含重复字符的子字符串/</id>
    <published>2018-08-27T08:34:48.000Z</published>
    <updated>2018-08-27T08:35:50.271Z</updated>
    
    <content type="html"><![CDATA[<h4 id="最长不含重复字符的子字符串？"><a href="#最长不含重复字符的子字符串？" class="headerlink" title="最长不含重复字符的子字符串？"></a>最长不含重复字符的子字符串？</h4><pre><code>public class MaxDistinctSubString {//返回字符串长度public static String resolve(String str,int length){    if(str == null || length &lt; 0){        throw new RuntimeException(&quot;参数非法&quot;);    }    int distance = 0;    int currentLen = 0;    int maxLen = 0;    StringBuffer sb = new StringBuffer();    //用来存放字符在字符串中的最近访问的index    int[] judgeExisted = new int[256];    for(int j = 0;j &lt; judgeExisted.length;j++){        judgeExisted[j] = -1;    }     int startIndex = 0;    for(int i = 0;i &lt; length;i++){        //所有字符0~255        int index =str.charAt(i);        //字符没出现过        if(judgeExisted[index] &lt; 0){            currentLen = currentLen + 1;        }else {            distance = i - judgeExisted[index];            if(distance &lt;= currentLen){//字符出现在子串的中间                currentLen = distance;            }else {//d &gt; currentLen                currentLen = currentLen + 1;            }        }        //更新出现字符的坐标        judgeExisted[index] = i;        if(currentLen &gt; maxLen){            maxLen = currentLen;            //如果出现了重复的字符的话,i会一直前进但maxLen不会变,所以满足条件时,startIndex已经跳过了出现重复的字符。            startIndex = i + 1 - maxLen;        }    }    return str.substring(startIndex,startIndex + maxLen);}public static void main(String[] args){    String str = &quot;arabcacfrg&quot;;    System.out.println(MaxDistinctSubString.resolve(str,str.length()));}</code></pre><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;最长不含重复字符的子字符串？&quot;&gt;&lt;a href=&quot;#最长不含重复字符的子字符串？&quot; class=&quot;headerlink&quot; title=&quot;最长不含重复字符的子字符串？&quot;&gt;&lt;/a&gt;最长不含重复字符的子字符串？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public class M
      
    
    </summary>
    
      <category term="动态规划" scheme="http://www.xuchunfa.cn/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>最大子数组</title>
    <link href="http://www.xuchunfa.cn/2018/08/27/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>http://www.xuchunfa.cn/2018/08/27/最大子数组/</id>
    <published>2018-08-27T08:30:36.000Z</published>
    <updated>2018-08-27T08:33:04.475Z</updated>
    
    <content type="html"><![CDATA[<h4 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和?"></a>连续子数组的最大和?</h4><pre><code>public class MaxSubArraySum {public static int resolve(int[] array,int length){    if(array == null || length &lt; 0){        throw new RuntimeException(&quot;参数不合法&quot;);    }    int maxSub = 0;    int currentSum = 0;    //循环的思想解决动态规划问题    for(int i = 0;i&lt;length;i++){        //如果之前的和小于0的话,那么当前和应该从下一个数开始        if(currentSum &lt;= 0){            currentSum = array[i];        }else {            currentSum = currentSum + array[i];        }        //判断子数组的最大值        if(currentSum &gt; maxSub){            maxSub = currentSum;        }    }    return maxSub;}public static void main(String[] args){    int[] arr = {-1,2,3,-4,5,6,-7,9};    System.out.println(MaxSubArraySum.resolve(arr,arr.length));}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;连续子数组的最大和&quot;&gt;&lt;a href=&quot;#连续子数组的最大和&quot; class=&quot;headerlink&quot; title=&quot;连续子数组的最大和?&quot;&gt;&lt;/a&gt;连续子数组的最大和?&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public class MaxSubArraySum {

p
      
    
    </summary>
    
      <category term="动态规划" scheme="http://www.xuchunfa.cn/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>1到n的数组中和为m的所有组合</title>
    <link href="http://www.xuchunfa.cn/2018/08/26/1%E5%88%B0n%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%AD%E5%92%8C%E4%B8%BAm%E7%9A%84%E6%89%80%E6%9C%89%E7%BB%84%E5%90%88/"/>
    <id>http://www.xuchunfa.cn/2018/08/26/1到n的数组中和为m的所有组合/</id>
    <published>2018-08-26T13:18:06.000Z</published>
    <updated>2018-08-26T13:21:08.976Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1到n的数组中和为m的所有组合？"><a href="#1到n的数组中和为m的所有组合？" class="headerlink" title="1到n的数组中和为m的所有组合？"></a>1到n的数组中和为m的所有组合？</h4><pre><code>public class SumOfKnumber {public static void findKNumber(int sum, int n, int[] combine,int index){    //index 最大取到 n    if(index &gt; n || index &gt; sum)        return;    if(index == sum){        combine[index-1] = index;        printResult(combine);        //还可以作为其他组合的元素        combine[index-1] = 0;        return;    }    //选择i    combine[index-1] = index;    findKNumber(sum-index, n, combine, index+1);    //i被放弃    combine[index-1] = 0;    findKNumber(sum,n,combine,index+1);}private static void printResult(int[] combine) {    for(int i = 0;i &lt; combine.length;i++){        if(combine[i] != 0){            System.out.print(combine[i] + &quot; &quot;);        }    }    System.out.println();}public static void main(String[] args){    int[] combine = new int[7];    SumOfKnumber.findKNumber(10,7,combine,1);}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1到n的数组中和为m的所有组合？&quot;&gt;&lt;a href=&quot;#1到n的数组中和为m的所有组合？&quot; class=&quot;headerlink&quot; title=&quot;1到n的数组中和为m的所有组合？&quot;&gt;&lt;/a&gt;1到n的数组中和为m的所有组合？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public
      
    
    </summary>
    
      <category term="动态规划" scheme="http://www.xuchunfa.cn/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>字符串匹配算法</title>
    <link href="http://www.xuchunfa.cn/2018/08/25/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/"/>
    <id>http://www.xuchunfa.cn/2018/08/25/字符串匹配算法/</id>
    <published>2018-08-25T10:26:54.000Z</published>
    <updated>2018-08-25T10:27:47.880Z</updated>
    
    <content type="html"><![CDATA[<ul><li>KMP算法</li></ul><ul><li>BM算法</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;KMP算法&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;BM算法&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
      <category term="字符串" scheme="http://www.xuchunfa.cn/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>虚拟机字节码执行引擎</title>
    <link href="http://www.xuchunfa.cn/2018/08/24/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
    <id>http://www.xuchunfa.cn/2018/08/24/虚拟机字节码执行引擎/</id>
    <published>2018-08-24T12:48:13.000Z</published>
    <updated>2018-08-28T03:52:34.489Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>栈帧</p></blockquote><ul><li><p>局部变量表</p><p>  1.一个局部变量定义了但没有赋初值是不可以使用的.</p></li><li><p>操作数栈</p></li><li><p>动态连接</p></li><li><p>方法返回地址</p><p>  1.方法退出等效于当前栈帧出栈.如返回果有值的话,则将返回值压入调用者栈帧的操作数栈中.</p></li><li><p>附加信息</p></li></ul><p>其中动态连接,方法返回地址,附加信息统称为<strong>栈帧信息</strong>.</p><blockquote><p>方法调用</p></blockquote><p>一切方法调用在Class文件里面存储的都是符号引用,不是方法在实际运行时内存布局中的入口地址.</p><ul><li><p>解析</p><pre><code>方法在程序真正运行之前就有一个可确定的调用版本, 并且这个方法的调用版本在运行期间不可改变.符合以上条件的方法:1.静态方法2.私有方法3.实例构造器4.父类方法它们在类加载的时候就会把符号引用解析成直接引用.</code></pre></li></ul><ul><li>分派</li></ul><p>1.静态分派(方法重载)</p><p>1.1 java语言中的返回值不参与重载选择。</p><p>重载：“编译期绑定”，也叫编译期多态。方法重载主要是类内部多态性的一个体现。 </p><p>例如:</p><pre><code>public class O{static class A{}static class B extends A{}static class C extends A{}public void a(A a){    System.out.println(&quot;A method&quot;);}public void a(B b){    System.out.println(&quot;B method&quot;);}public void a(C c){    System.out.println(&quot;C method&quot;);}public static void main(String[] args){    O o = new O();    A b = new B();    A c = new C();    o.a(b);    o.a(c);}}</code></pre><p>上述代码的结果:</p><p>A method</p><p>A method</p><p><strong>虚拟机在重载时是通过参数的静态类型而不是实际类型作为判断依据.</strong></p><p>2.动态分派（方法重写）</p><p>重写：“运行期绑定”，也叫运行期多态。方法重写是父类与子类之间多态性的体现。</p><pre><code>在运行期间根据实际类型确定方法执行版本的分派。</code></pre><p>例如：</p><pre><code>class Dog{public void bark(){    System.out.println(&quot;woof &quot;);}}class Hound extends Dog{public void sniff(){    System.out.println(&quot;sniff &quot;);}public void bark(){    System.out.println(&quot;bowl&quot;);}}public class OverridingTest{public static void main(String [] args){    Dog dog = new Hound();    dog.bark();}}    </code></pre><p>输出：bowl</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;栈帧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;局部变量表&lt;/p&gt;
&lt;p&gt;  1.一个局部变量定义了但没有赋初值是不可以使用的.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;操作数栈&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态连接&lt;/p&gt;
&lt;/
      
    
    </summary>
    
      <category term="java虚拟机" scheme="http://www.xuchunfa.cn/categories/java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>数组中和为m的所有组合</title>
    <link href="http://www.xuchunfa.cn/2018/08/24/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%92%8C%E4%B8%BAm%E7%9A%84%E6%89%80%E6%9C%89%E7%BB%84%E5%90%88/"/>
    <id>http://www.xuchunfa.cn/2018/08/24/数组中和为m的所有组合/</id>
    <published>2018-08-24T10:09:40.000Z</published>
    <updated>2018-08-24T10:09:40.239Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>随机版本的快排</title>
    <link href="http://www.xuchunfa.cn/2018/08/24/%E9%9A%8F%E6%9C%BA%E7%89%88%E6%9C%AC%E7%9A%84%E5%BF%AB%E6%8E%92/"/>
    <id>http://www.xuchunfa.cn/2018/08/24/随机版本的快排/</id>
    <published>2018-08-24T04:24:16.000Z</published>
    <updated>2018-08-24T04:25:37.975Z</updated>
    
    <content type="html"><![CDATA[<pre><code>public class QuickSort {public static void swap(int[] a,int i,int j){    int temp;    temp = a[i];    a[i] = a[j];    a[j] = temp;}public static int partition(int[] a,int start,int end){    if(a == null || start &lt; 0 || end &gt; a.length-1){        throw new RuntimeException(&quot;参数不合法&quot;);    }    //轴值在[start,end]区间内随机生成,然后把轴值交换到数组中第一位    rand_pivot(a,start,end);    int i = start;    int j = end;    int pivot = a[start];    while (i &lt; j){        while (i &lt; j &amp;&amp; a[j] &gt;= pivot){            j--;        }        //a[i] = a[j];//这种写法时条件不能为a[j] &gt; pivot必须要 &gt;=        swap(a,i,j);        while (i &lt; j &amp;&amp; a[i] &lt;= pivot){            i++;        }        //a[j] = a[i];        swap(a,j,i);    }    //a[i] 或者 a[j]    //a[i] = pivot;    return i;}//随机化的选择主元private static void rand_pivot(int[] a, int start, int end) {    Random random = new Random();    int rand = start + random.nextInt(end - start + 1);//随机函数生成的整数区间在[0,length)    //交换第一个数和随机选出来的数    int temp = a[start];    a[start] = a[rand];    a[rand] = temp;}public static void quickSort(int[] a,int start,int end){    if(start &gt;= end)        return;    int index = partition(a,start,end);    quickSort(a,start,index-1);    quickSort(a,index+1,end);    /*int index;    if(start &lt; end){        index = partition(a,start,end);        quickSort(a,start,index-1);        quickSort(a,index+1,end);    }*/}public static void main(String[] args){    int[] a = {2,4,5,1,1,2,7,6,3};    QuickSort.quickSort(a,0,a.length-1);    System.out.println(Arrays.toString(a));}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;public class QuickSort {

public static void swap(int[] a,int i,int j){
    int temp;
    temp = a[i];
    a[i] = a[j];
    a[j] 
      
    
    </summary>
    
      <category term="排序" scheme="http://www.xuchunfa.cn/categories/%E6%8E%92%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>java动态绑定</title>
    <link href="http://www.xuchunfa.cn/2018/08/23/java%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/"/>
    <id>http://www.xuchunfa.cn/2018/08/23/java动态绑定/</id>
    <published>2018-08-23T07:04:48.000Z</published>
    <updated>2018-08-24T13:52:44.349Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>动态绑定(后期绑定)和前期绑定？</p></blockquote><p>1.普通的方法我们看new后面的是什么类型；(后期绑定)</p><p>2.域和静态方法我们看=前面声明的是什么类型。 (前期绑定)</p><p>3.final，static，private和构造方法是前期绑定的。</p><p>4.运行时（动态）绑定针对的范畴只是对象的（普通）方法。</p><pre><code>public class Father {protected String name = &quot;父亲属性&quot;;}public class Son extends Father {    protected String name = &quot;儿子属性&quot;;    public static void main(String[] args) {        Father sample = new Son();        System.out.println(&quot;调用的属性：&quot; + sample.name);}}</code></pre><p>上述代码的运行结果: <strong>父亲属性</strong></p><pre><code>public class Father {protected String name = &quot;父亲属性&quot;;public String getName() {    return name;}}　　public class Son extends Father {protected String name = &quot;儿子属性&quot;;public String getName() {    return name;}public static void main(String[] args) {    Father sample = new Son();    System.out.println(&quot;调用的属性:&quot; + sample.getName());}}</code></pre><p>上述代码的运行结果: <strong>儿子属性</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;动态绑定(后期绑定)和前期绑定？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.普通的方法我们看new后面的是什么类型；(后期绑定)&lt;/p&gt;
&lt;p&gt;2.域和静态方法我们看=前面声明的是什么类型。 (前期绑定)&lt;/p&gt;
&lt;p&gt;3.final，stat
      
    
    </summary>
    
      <category term="java基础" scheme="http://www.xuchunfa.cn/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>关于TopK问题的详解</title>
    <link href="http://www.xuchunfa.cn/2018/08/21/%E5%85%B3%E4%BA%8ETopK%E9%97%AE%E9%A2%98%E7%9A%84%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.xuchunfa.cn/2018/08/21/关于TopK问题的详解/</id>
    <published>2018-08-21T07:21:19.000Z</published>
    <updated>2018-08-24T06:42:24.011Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在O(N)时间内寻找最大(或最小)的K个数？</p></blockquote><ul><li>Random Select:</li></ul><p>本质上是求第K大或第K小的那个数。</p><pre><code>1.如果是求最小的K个数，则找到坐标为 k-1 的Pivot.左边放是比pivot小的值，右边比pivot大。2.如果是求最大的K个数，则找到坐标为 k-1 的Pivot.左边放是比pivot大的值，右边比pivot小。</code></pre><p>如果数组中整数的取值范围不大的话，可以用哈希表的方法解决。</p><p>思路：用一个计数数组来记录每个数字出现的次数。</p><pre><code>时间复杂度：0(n + MAXN)for(sumCount = 0, v = MAXN-1; v &gt;= 0; v--){    sumCount += count[v];    if(sumCount &gt;= K)        break;}return v;</code></pre><ul><li>堆排序解决</li></ul><p>例如：2亿个整数中求最大的100万之和？</p><p>思路：</p><ol><li>首先建立一个容量为100万（Top K）的int数组，从文件读取整数填充。</li><li>利用堆维护该100万条记录（确保堆顶元素为最小值）</li><li>从文件中读取一个整数与堆顶元素比较，如果大于堆顶元素则替换该元素，并调整堆的结构。</li><li>重复步骤3一直到数据读取完</li><li>将数组中的元素全部相加，得到结果</li></ol><p>代码如下：</p><pre><code>public class TopKProblem {//时间复杂度:(n-K)*logK 空间复杂度:O(K)public static int[] createKtopHeap(int[] num,int k){    int length = num.length;    int i = 0;    //通过堆维护Topk元素    int[] KNumberHeap = new int[k];    if(k &gt;= length){        k = length;        return num;    }    //初始化有k个元素的堆    for(; i &lt; k; i++){        KNumberHeap[i] = num[i];    }    //构建小顶堆    for(int j = KNumberHeap.length/2-1;j &gt;= 0;j--){        createMinHeap(KNumberHeap,j,KNumberHeap.length);    }    //从第k+1个元素开始循环,每次都与堆顶元素(K个元素中的最小值)比较,大于就替代然后再调整.    for(;i &lt; length;i++){        if(num[i] &gt; KNumberHeap[0]){            KNumberHeap[0] = num[i];            createMinHeap(KNumberHeap,0,KNumberHeap.length);        }    }    return KNumberHeap;}private static void createMinHeap(int[] a, int i , int len) {    int father = a[i];    int j;//j代表子结点坐标 i代表父结点坐标    while(2*i + 1 &lt; len){//如果i结点在堆顶上的话,需要自顶向下调整        j = 2*i + 1;        if(j + 1 &lt; len &amp;&amp; a[j] &gt; a[j+1] )            j++;        if(a[j] &lt; father){            a[i] = a[j];            i = j;        }else {//不用调整的话就不用再向下循环了,子节点都已经调整好了            break;        }    }    //找到最终位置    a[i] = father;}public static void main(String[] args){    Random random = new Random();    int[] num = new int[15];    for(int i = 0;i &lt; num.length;i++){        num[i] = random.nextInt(50);    }    System.out.println(Arrays.toString(num));    System.out.println(Arrays.toString(createKtopHeap(num,5)));}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在O(N)时间内寻找最大(或最小)的K个数？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Random Select:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本质上是求第K大或第K小的那个数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.如果是求最小的K个数
      
    
    </summary>
    
      <category term="数组" scheme="http://www.xuchunfa.cn/categories/%E6%95%B0%E7%BB%84/"/>
    
    
  </entry>
  
  <entry>
    <title>数组中第k大的数</title>
    <link href="http://www.xuchunfa.cn/2018/08/20/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACk%E5%A4%A7%E7%9A%84%E6%95%B0/"/>
    <id>http://www.xuchunfa.cn/2018/08/20/数组中第k大的数/</id>
    <published>2018-08-20T11:42:39.000Z</published>
    <updated>2018-08-24T07:21:36.776Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>多种解法开拓思路</p></blockquote><p>1.把数组从大到小进行排序，再遍历到第k个元素。</p><pre><code>时间复杂度：O(nlogn+k).</code></pre><p>2.利用选择排序，每一次遍历数组就可以选出一个最大值，遍历k次就得到了第K大的值。</p><pre><code>时间复杂度：O(n*k).所以最坏情况为O(n^2).</code></pre><p>3.基于快排的Quick Select.使用快排中的partition()函数，大的数值放在pivot左边，小的方右边。得到的Position就是第Position+1大的数值。然后再选择其中的一半数据递归。(也可以用循环解决)</p><pre><code>时间复杂度：O(n).详细证明见算法导论</code></pre><p>4.可以建立最大堆,然后pop操作进行k次,就能找到第K大的值。</p><p>5.通过优先队列实现,底层原理基于4方法。</p><pre><code>时间复杂度：O(n)空间复杂度：O(n)</code></pre><h3 id="该题目的变形版本"><a href="#该题目的变形版本" class="headerlink" title="该题目的变形版本?"></a>该题目的变形版本?</h3><blockquote><p>N个数中最大的第K个不同的数？</p></blockquote><p>例如：5，4，4，3 第三大的数是3,而不是4</p><blockquote><p>找第k到第m大的数？</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;多种解法开拓思路&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.把数组从大到小进行排序，再遍历到第k个元素。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;时间复杂度：O(nlogn+k).
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.利用选择排序，每一次遍历数组就可以选
      
    
    </summary>
    
      <category term="数组" scheme="http://www.xuchunfa.cn/categories/%E6%95%B0%E7%BB%84/"/>
    
    
  </entry>
  
  <entry>
    <title>类文件结构和类加载</title>
    <link href="http://www.xuchunfa.cn/2018/08/19/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    <id>http://www.xuchunfa.cn/2018/08/19/类文件结构和类加载/</id>
    <published>2018-08-19T11:55:10.000Z</published>
    <updated>2018-08-25T09:28:27.085Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>类文件结构</p></blockquote><p>1.java方法体中的代码经过javac编译器后，变成字节码存储在方法表的Code属性中。</p><p>2.java虚拟机通过对照指令表，将字节码翻译成了机器能够认识的机器指令。</p><p>对于2操作的规范化说法如下：</p><pre><code>java虚拟机的解释器从字节码流取出操作码，执行操作码所定义的操作。字节码指令集：由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需参数（称为操作数，Operands）而构成。操作码的长度：1字节。操作码的种数不超过256.</code></pre><blockquote><p>类加载机制</p></blockquote><p>定义：把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化,最终形成可以被虚拟机直接使用的java类型。</p><p>1.类加载的时机</p><ul><li><p>遇到下面三种情况</p><p>  1.new实例化对象时</p><p>  2.读取或设置一个类的静态字段时</p><p>  3.调用一个类的静态方法时</p></li><li><p>java.lang.reflect包的方法对类进行反射调用时</p></li><li><p>准备初始化子类时会触发父类的初始化</p></li></ul><blockquote><p>类加载过程</p></blockquote><ul><li>加载</li></ul><p>1.获取类的二进制字节流</p><p>2.转化为方法区的运行时数据结构</p><p>3.内存区生成java.lang.Class对象</p><p>连接阶段包括：验证、准备和解析</p><ul><li>验证</li></ul><p>1.是基于二进制字节流进行的</p><ul><li>准备阶段</li></ul><p>1.为类变量(static变量)分配内存以及初始化。</p><ul><li>解析</li></ul><p>1.虚拟机将符号引用替换为直接引用。</p><pre><code>例如：将静态方法、私有方法、实例构造器、父类方法的符号引用直接解析成直接引用。</code></pre><p>2.针对类或接口、字段、类方法、接口方法、方法类型、方法句柄以及调用点限定符。</p><ul><li>初始化</li></ul><p>1.执行类构造器<clinit>()方法的过程。</clinit></p><p>2.<clinit>()方法由编译器自动收集类中的所有类变量的复制动作和静态语句块。</clinit></p><blockquote><p>类加载器</p></blockquote><p>1.类加载器干啥用的？</p><pre><code>通过一个类的全限定名来获取描述此类的二进制字节流。</code></pre><p>2.类加载器的种类？</p><ul><li><p>启动类加载器</p><pre><code>1.System.class.getClassLoader()结果为null的原因，这并不表示System这个类没有类加载器，而是它的加载器比较特殊，是BootstrapClassLoader.2.加载存放在JAVA_HOME/lib目录中的类库或被-Xbootclasspath参数指定的路径。</code></pre></li></ul><ul><li><p>拓展类加载器</p><pre><code>1.加载JAVA_HOME/lib/ext目录或被java.ext.dirs系统变量指定的类库。</code></pre></li></ul><ul><li><p>应用程序类加载器(系统类加载器)</p><pre><code>1.加载用户类路径（classpath）下的类库。</code></pre></li></ul><h4 id="双亲委派模型？"><a href="#双亲委派模型？" class="headerlink" title="双亲委派模型？"></a>双亲委派模型？</h4><p><img src="https://i.imgur.com/fKQXKAa.jpg" alt=""></p><p>1.检查类是否已经加载。</p><p>2.如果没加载就逐层递归到父类。递归结束的条件是parent==null.</p><p>3.如果最上层Bootstrap都还没找到的话，则出栈，一层层调用自己的findclass方法。</p><p>代码如下：</p><pre><code>protected Class&lt;?&gt; loadClass(String name, boolean resolve)    throws ClassNotFoundException{    synchronized (getClassLoadingLock(name)) {        // First, check if the class has already been loaded        Class&lt;?&gt; c = findLoadedClass(name);        if (c == null) {            long t0 = System.nanoTime();            try {                if (parent != null) {                    c = parent.loadClass(name, false);                } else {                    c = findBootstrapClassOrNull(name);                }            } catch (ClassNotFoundException e) {                // ClassNotFoundException thrown if class not found                // from the non-null parent class loader            }            if (c == null) {                // If still not found, then invoke findClass in order                // to find the class.                long t1 = System.nanoTime();                c = findClass(name);                // this is the defining class loader; record the stats                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                sun.misc.PerfCounter.getFindClasses().increment();            }        }        if (resolve) {            resolveClass(c);        }        return c;    }}</code></pre><h3 id="类加载过程的总结"><a href="#类加载过程的总结" class="headerlink" title="类加载过程的总结"></a>类加载过程的总结</h3><p>当有触发类加载的条件时，会将java字节码以二进制流的形式装载到java虚拟机内存中去，并且把二进制流按字节码规范解析成jvm内部运行时的数据结构。最终解析完成的结果是生成了类访问的入口对象java.lang.Class,通过该对象可以访问类在方法区的内容。</p><p>然后会去验证和校验二进制流的合法性，接着发生“赋零”的初始化，紧接着就是将常量池中类的符号引用替代成直接引用。最后发生的才是程序指定的初始化内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;类文件结构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.java方法体中的代码经过javac编译器后，变成字节码存储在方法表的Code属性中。&lt;/p&gt;
&lt;p&gt;2.java虚拟机通过对照指令表，将字节码翻译成了机器能够认识的机器指令。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="java虚拟机" scheme="http://www.xuchunfa.cn/categories/java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>合并两个有序链表</title>
    <link href="http://www.xuchunfa.cn/2018/08/17/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://www.xuchunfa.cn/2018/08/17/合并两个有序链表/</id>
    <published>2018-08-17T08:17:36.000Z</published>
    <updated>2018-08-17T08:19:20.598Z</updated>
    
    <content type="html"><![CDATA[<pre><code>public class MergeSortedLink {public static ListNode merge(ListNode head1,ListNode head2){    ListNode mergedHead;    if(head1 == null){        return head2;    }    if(head2 == null){        return head1;    }    if(head1.data &lt; head2.data){        mergedHead = head1;        mergedHead.next = merge(head1.next,head2);    }else {        mergedHead = head2;        mergedHead.next = merge(head1,head2.next);    }    return mergedHead;}public static void main(String[] args){    Link link1 = new Link();    Link link2 = new Link();    link1.add(1);    link1.add(3);    link1.add(5);    link2.add(2);    link2.add(4);    link2.add(6);    link2.add(7);    ListNode newHead = MergeSortedLink.merge(link1.head,link2.head);    Link link3 = new Link();    link3.head = newHead;    link3.print();}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;public class MergeSortedLink {

public static ListNode merge(ListNode head1,ListNode head2){
    ListNode mergedHead;

    if(hea
      
    
    </summary>
    
      <category term="链表" scheme="http://www.xuchunfa.cn/categories/%E9%93%BE%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>删除链表中的重复结点</title>
    <link href="http://www.xuchunfa.cn/2018/08/17/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E7%BB%93%E7%82%B9/"/>
    <id>http://www.xuchunfa.cn/2018/08/17/删除链表中的重复结点/</id>
    <published>2018-08-17T07:03:51.000Z</published>
    <updated>2018-08-17T07:05:18.485Z</updated>
    
    <content type="html"><![CDATA[<pre><code>public class DeleteDuplicationNode {//例如(1,2,2,2,3) &gt;&gt; (1,2,3)public static void deleteDuplicationNode(ListNode head){    if(head == null){        throw new RuntimeException(&quot;链表不存在&quot;);    }    //默认是增序的(包含所有结点相等的情况)    boolean ascend = true;    ListNode post,p;    p = head;    while(p.next != null){        if(p.data &gt; p.next.data){            ascend = false;//降序        }        p = p.next;    }    p = head;    if(ascend){//链表递增时        while (p.next != null){            if(p.data == p.next.data){                post = p.next;                while(post.next != null){                    if(post.data &lt; post.next.data){                        p.next = post.next;                        break;//结束                    }                    post = post.next;                }                if(post.next == null){                    p.next = post.next;                    break;                }            }            p = p.next;        }    }else {//链表递减        while (p.next != null){            if(p.data == p.next.data){                post = p.next;                while(post.next != null){                    if(post.data &gt; post.next.data){                        p.next = post.next;                        break;                    }                    post = post.next;                }                if(post.next == null){                    p.next = post.next;                    break;                }            }            //break跳到这里,继续遍历            p = p.next;        }    }}//例如(1,2,3,3,4,4,5) &gt;&gt; (1,2,5)public static void DeleteDuplication(ListNode head){    if(head == null){        throw new RuntimeException(&quot;链表不存在&quot;);    }    ListNode pre = null;    ListNode p = head;    ListNode post;    while (p != null){        post = p.next;        boolean needDeleted = false;        if(post != null &amp;&amp; p.data == post.data){            needDeleted = true;        }        if(!needDeleted){            pre = p;            p = p.next;        }else {            int value = p.data;            ListNode toDelete = p;            while (toDelete != null &amp;&amp; toDelete.data == value){                post = toDelete.next;                toDelete = post;            }            if(pre == null){//删除头节点.可能所有结点相等 head = null                Link.head = post;            }else {                pre.next = post;            }            p = post;        }    }}public static void main(String[] args){    Link link = new Link();    link.add(1);    DeleteDuplicationNode.DeleteDuplication(link.head);    link.print();}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;public class DeleteDuplicationNode {

//例如(1,2,2,2,3) &amp;gt;&amp;gt; (1,2,3)
public static void deleteDuplicationNode(ListNode head){


      
    
    </summary>
    
      <category term="链表" scheme="http://www.xuchunfa.cn/categories/%E9%93%BE%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>字符串匹配</title>
    <link href="http://www.xuchunfa.cn/2018/08/17/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    <id>http://www.xuchunfa.cn/2018/08/17/字符串匹配/</id>
    <published>2018-08-17T07:00:19.000Z</published>
    <updated>2018-08-17T07:02:23.654Z</updated>
    
    <content type="html"><![CDATA[<h4 id="匹配匹配模式为-和-的字符串？"><a href="#匹配匹配模式为-和-的字符串？" class="headerlink" title="匹配匹配模式为. 和 * 的字符串？"></a>匹配匹配模式为. 和 * 的字符串？</h4><pre><code>public class RegularExpression {public static boolean match(String str,String pattern,int strLen,int patternLen,int strIndex,int patternIndex){    if(str == null || pattern == null){        return false;    }    return matchCore(str,pattern,strLen,patternLen,strIndex,patternIndex);}private static boolean matchCore(String str, String pattern,int strLen,int patternLen,int strIndex,int patternIndex) {    if(strIndex == strLen &amp;&amp; patternIndex == patternLen){        return true;    }    //模式匹配完了字符串没匹配完    if(strIndex &lt; strLen &amp;&amp; patternIndex == patternLen){        return  false;    }    //模式的第二个字符为&apos;*&apos;的情况    if(patternIndex+1 &lt; patternLen &amp;&amp; pattern.charAt(patternIndex + 1) == &apos;*&apos;){//注意边界条件最后一个字符,需要判断条件        if(strIndex &lt; strLen &amp;&amp; str.charAt(strIndex) == pattern.charAt(patternIndex) || strIndex &lt; strLen &amp;&amp; pattern.charAt(patternIndex) == &apos;.&apos;){            return matchCore(str,pattern,strLen,patternLen,strIndex+1,patternIndex+2) ||                    matchCore(str,pattern,strLen,patternLen,strIndex+1,patternIndex) ||                    matchCore(str,pattern,strLen,patternLen,strIndex,patternIndex+2);        }else {//字符串匹配完了模式还没匹配完            return matchCore(str,pattern,strLen,patternLen,strIndex,patternIndex+2);        }    }    //模式的第二个字符不为&apos;*&apos;的情况(注意条件 strIndex &lt; strLen )    if(strIndex &lt; strLen &amp;&amp; str.charAt(strIndex) == pattern.charAt(patternIndex) || (strIndex &lt; strLen &amp;&amp; pattern.charAt(patternIndex) == &apos;.&apos;)){        return matchCore(str,pattern,strLen,patternLen,++strIndex,++patternIndex);    }    //包含了str=&quot;ab&quot; pattern=&quot;....&quot;的情况了    return false;}public static void main(String[] args){    String str = &quot;ab&quot;;    String pattern = &quot;....&quot;;    int strLen = str.length();    int patternLen = pattern.length();    System.out.println(RegularExpression.match(str,pattern,strLen,patternLen,0,0));}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;匹配匹配模式为-和-的字符串？&quot;&gt;&lt;a href=&quot;#匹配匹配模式为-和-的字符串？&quot; class=&quot;headerlink&quot; title=&quot;匹配匹配模式为. 和 * 的字符串？&quot;&gt;&lt;/a&gt;匹配匹配模式为. 和 * 的字符串？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;publ
      
    
    </summary>
    
      <category term="字符串" scheme="http://www.xuchunfa.cn/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
  </entry>
  
</feed>
