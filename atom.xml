<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Flying in the ocean of knowledge</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xuchunfa.cn/"/>
  <updated>2018-09-09T08:53:24.522Z</updated>
  <id>http://www.xuchunfa.cn/</id>
  
  <author>
    <name>Xu chunfa</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux基础</title>
    <link href="http://www.xuchunfa.cn/2018/09/09/Linux%E5%9F%BA%E7%A1%80/"/>
    <id>http://www.xuchunfa.cn/2018/09/09/Linux基础/</id>
    <published>2018-09-09T08:47:26.000Z</published>
    <updated>2018-09-09T08:53:24.522Z</updated>
    
    <content type="html"><![CDATA[<p>1.硬链接和软链接</p><p>硬链接装的是原文件的inode节点，软链接装的是原文件所在的路径。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.硬链接和软链接&lt;/p&gt;
&lt;p&gt;硬链接装的是原文件的inode节点，软链接装的是原文件所在的路径。&lt;/p&gt;

      
    
    </summary>
    
      <category term="Linux基础" scheme="http://www.xuchunfa.cn/categories/Linux%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>面试常见Linux指令</title>
    <link href="http://www.xuchunfa.cn/2018/09/08/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81Linux%E6%8C%87%E4%BB%A4/"/>
    <id>http://www.xuchunfa.cn/2018/09/08/面试常见Linux指令/</id>
    <published>2018-09-08T08:12:30.000Z</published>
    <updated>2018-09-08T08:12:30.730Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot菜鸡入门</title>
    <link href="http://www.xuchunfa.cn/2018/09/07/SpringBoot%E8%8F%9C%E9%B8%A1%E5%85%A5%E9%97%A8/"/>
    <id>http://www.xuchunfa.cn/2018/09/07/SpringBoot菜鸡入门/</id>
    <published>2018-09-07T14:37:45.000Z</published>
    <updated>2018-09-07T15:18:12.518Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>SpringBoot干货</p></blockquote><p>1.spring-boot-starter-parent：提供相关的Maven依赖。</p><p>2.起步依赖 spring-boot-starter-xx:自动封装好你想要实现的功能的依赖。本质上是一个Maven对象模型。</p><p>3.Spring Boot Maven插件:把项目打包成可执行的JAR,所有的依赖都打进JAR包中。</p><p>4.注解</p><ul><li><p>@SpringBootApplication：开启自动配置。</p></li><li><p>@ConfigurationProperties(prefix = “com.dudu”)：绑定一个对象的bean(例子中指的是ConfigBean)</p></li><li><p>@EnableConfigurationProperties(${ConfigBean.Class}):Spring Boot 入口类上的注解，指明要加载那个Bean.</p></li><li><p>@Autowired:在控制器中引入ConfigBean</p><pre><code>@AutowiredConfigBean configBean</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;SpringBoot干货&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.spring-boot-starter-parent：提供相关的Maven依赖。&lt;/p&gt;
&lt;p&gt;2.起步依赖 spring-boot-starter-xx:自动封装好你想要实现
      
    
    </summary>
    
      <category term="Spring入门" scheme="http://www.xuchunfa.cn/categories/Spring%E5%85%A5%E9%97%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>树算法中好的思想</title>
    <link href="http://www.xuchunfa.cn/2018/09/06/%E6%A0%91%E7%AE%97%E6%B3%95%E4%B8%AD%E5%A5%BD%E7%9A%84%E6%80%9D%E6%83%B3/"/>
    <id>http://www.xuchunfa.cn/2018/09/06/树算法中好的思想/</id>
    <published>2018-09-06T03:16:41.000Z</published>
    <updated>2018-09-06T08:45:30.937Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>遍历直到叶子结点</p></blockquote><pre><code>//处理到达叶子结点时候的情况boolean isLeaf = pRoot.left == null &amp;&amp; pRoot.right == null;//前序遍历if(pRoot.left != null)     sumOfTrace(pRoot.left,sumValue);if(pRoot.right != null)     sumOfTrace(pRoot.right, sumValue);//处理到达叶子结点但未满足条件的情况......</code></pre><blockquote><p>提前结束树的遍历</p></blockquote><pre><code>//如果在左子树中找到结果 结果直接为Trueboolean isExisted = findPath(pRoot.left,node,list);//若不为True,继续遍历右子树if(!isExisted){     isExisted = findPath(pRoot.right,node,list);}</code></pre><blockquote><p>在需要辅助指针的时候可以从另一个函数里面传进去，而不需要定义成员变量</p></blockquote><pre><code>public BinaryTreeNode bstLinkedList(BinaryTreeNode pRoot){    BinaryTreeNode lastVisited = null;    //传入初始化为null的指针    reverse(pRoot,lastVisited);}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;遍历直到叶子结点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;//处理到达叶子结点时候的情况
boolean isLeaf = pRoot.left == null &amp;amp;&amp;amp; pRoot.right == null;

/
      
    
    </summary>
    
      <category term="树" scheme="http://www.xuchunfa.cn/categories/%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Mysql笔记</title>
    <link href="http://www.xuchunfa.cn/2018/09/04/Mysql%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.xuchunfa.cn/2018/09/04/Mysql笔记/</id>
    <published>2018-09-04T03:26:20.000Z</published>
    <updated>2018-09-09T07:33:05.240Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.数据类型理解</strong></p><p>int(M)： M表示的不是数据的最大长度，只是数据宽度，并不影响存储多少位长度的数据；</p><p>varchar(M)： M表示的是varchar类型数据在数据库中存储的最大长度，超过则不存；</p><p>char(N):存放的是字符的个数</p><p><strong>2.关键字的执行顺序</strong></p><p>（8）SELECT（9）DISTINCT (select_list)</p><p>（1）FROM (left_table)</p><p>（3）(join_type) JOIN (right_table)</p><p>（2）ON (join_condition)</p><p>（4）WHERE (where_condition)</p><p>（5）GROUP BY (group_by_list)</p><p>（6）WITH {CUTE|ROLLUP}</p><p>（7）HAVING (having_condition)</p><p>（10）ORDER BY (order_by_list)</p><p>（11）LIMIT (limit_number)</p><p><strong>3.LEFT JOIN 和 RIGHT JOIN 的区别</strong></p><ul><li><p>CROSS JOIN: 返回两个表的笛卡儿积。</p><p>  返回结果集的行号：<br>  set @mycnt = 0;<br>  select (@mycnt := @mycnt + 1) as ROWNUM,c.customers_id,o.order_id from customers AS c,orders AS o<br>  WHERE c.customers_id = o.customers_id </p></li></ul><ul><li><p>LEFT JOIN：以左表为基础的，左表的记录将会全部表示出来,而右表只会显示符合搜索条件的记录(例子中为: A.aID = B.bID).右表记录不足的地方均为NULL.（必须指定 ON 子句）</p></li><li><p>RIGHT JOIN：与上面的情况相反。</p></li><li><p>INNER JOIN: INNER可以省略，直接写成 JOIN 。并不以谁为基础,它只显示符合条件的记录.产生A和B的交集。INNER JOIN中的 WHERE 的过滤条件可以写在 ON 子句中。</p><pre><code>select c.customers_id,o.order_id,c.city from customers AS c JOIN orders AS o ON c.customers_id = o.customers_id AND c.customers_id = &apos;14&apos;或者使用 USING 关键字来简化 ON 子句：select c.customers_id,o.order_id,c.city from customers AS c JOIN orders AS o USING(customers_id) WHERE c.customers_id = &apos;14&apos;</code></pre></li></ul><p>当没有ON语句的时候会将 INNER JOIN 理解成 CROSS JOIN</p><p><strong>4.WHERE过滤器常见错误</strong></p><ul><li><p>在ON条件过滤器后还是会添加保留表中被ON过滤掉的记录,而WHERE条件是永久的过滤。</p></li><li><p>在WHERE条件中使用列别名,不能使用Select中的列别名，因为Select比 Where 晚执行，但是可以使用 From中列别名。</p><pre><code>错误：SELECT customers_id AS c,order_id AS o FROM orders WHERE c = &apos;aa&apos;</code></pre></li><li><p>在WHERE条件中使用统计的过滤</p><pre><code>错误：SELECT COUNT(customers_id) ,order_id  FROM orders WHERE COUNT(customers_id) &gt; 1</code></pre></li></ul><p><strong>5.COUNT容易犯的错误</strong></p><ul><li>COUNT(*)会把通过 OUTER JOIN 添加的行统计入内。而 COUNT(column_name) 函数返回指定列的值的数目（NULL 不会计入在内）</li></ul><p><strong>6.ORDER BY </strong></p><ul><li>NULL值在 ORDER BY 中被视为最小。</li></ul><p><strong>8.Having</strong></p><p>1.Having 通常于 Group by 一起使用。</p><p>2.弥补了WHERE关键字不能与聚合函数联合使用的不足。</p><p><strong>7.LIMIT</strong></p><ul><li>LIMIT n,m : 表示从第 n 条记录开始选择 m 条记录。对于数据量非常大的情景该执行语句的效率比较低。n = 0 代表第一行，limit 0,5 等价于 limit 5 都是返回前5行。</li></ul><p><strong>8.IN</strong></p><ul><li>IN引导的子句只能返回一个字段而 EXIST 可以返回多个。</li><li>EXIST 子句不在乎返回什么，而是在乎是不是有结果集返回。用于检查子查询是否至少会返回一行数据，该子查询实际上并不返回任何数据，而是返回值True或False.</li></ul><hr><blockquote><p>Mysql函数总结</p></blockquote><p>1.MOD(N,M)：表示 N 除以 M 的余数。</p><p>2.DATEDIFF(datepart,startdate,enddate)：返回两个日期之间的时间。</p><p>3.DATEADD(datepart,number,date)：在日期中添加或减去指定的时间间隔。</p><pre><code>eg:计算当前月的一天SELECT DATEADD(mm,DATEDIFF(mm,0,getdate()),0)</code></pre><p>4.IFNULL（expr1，expr2）：在 expr1 的值不为 NULL的情况下都返回 expr1，否则返回 expr2。</p><hr><blockquote><p>Mysql索引的数据结构</p></blockquote><p>1.B+树索引只能找到某条记录所在的页，需要根据二分查找法来进一步找到记录所在页的具体位置。</p><blockquote><p>InnoDB B+ 树索引(叶结点的data域保存了完整的数据记录)</p></blockquote><ul><li>聚集索引（每页大小16K）</li></ul><p>1.根据主键创建的一棵 B+ 树。</p><p>2.叶结点的data域是数据记录。</p><ul><li>辅助索引</li></ul><p>1.根据索引键（例如：用户信息表，主键是用户ID，这里可以在名字上面建立索引，即根据名字创建了一棵B+树）创建的一棵 B+ 树。</p><p>2.叶结点的data域存放的是主键值。</p><blockquote><p>MyISAM B+ 树索引（索引文件和数据文件实现了分离）</p></blockquote><p>1.叶结点的data域存放的是数据记录的地址。</p><p>2.主索引要求 key 是唯一的，辅助索引的key可以重复。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1.数据类型理解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;int(M)： M表示的不是数据的最大长度，只是数据宽度，并不影响存储多少位长度的数据；&lt;/p&gt;
&lt;p&gt;varchar(M)： M表示的是varchar类型数据在数据库中存储的最大长度，超过则不存；&lt;/p&gt;

      
    
    </summary>
    
      <category term="Mysql基础" scheme="http://www.xuchunfa.cn/categories/Mysql%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>结点的最近祖先</title>
    <link href="http://www.xuchunfa.cn/2018/09/03/%E7%BB%93%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E7%A5%96%E5%85%88/"/>
    <id>http://www.xuchunfa.cn/2018/09/03/结点的最近祖先/</id>
    <published>2018-09-03T11:46:51.000Z</published>
    <updated>2018-09-03T11:49:04.504Z</updated>
    
    <content type="html"><![CDATA[<h4 id="两个结点的最近祖先？"><a href="#两个结点的最近祖先？" class="headerlink" title="两个结点的最近祖先？"></a>两个结点的最近祖先？</h4><pre><code>public class CommonAncestor {//树为二叉搜索树的情况，默认node1 node2已经存在树中public BinaryTreeNode findCommonAncestor(BinaryTreeNode pRoot,int node1,int node2){    if(pRoot.data &gt; node1 &amp;&amp; pRoot.data &lt; node2 || pRoot.data &lt; node1 &amp;&amp; pRoot.data &gt; node2)        return pRoot;    if(node1 &lt; pRoot.data &amp;&amp; node2 &lt; pRoot.data){        return findCommonAncestor(pRoot.left,node1,node2);    }else if(node1 &gt; pRoot.data &amp;&amp; node2 &gt; pRoot.data){        return findCommonAncestor(pRoot.right,node1,node2);    }    return null;}//树为普通二叉树递归解法public BinaryTreeNode findCommonAncestor1(BinaryTreeNode pRoot,int node1,int node2){    //判断两个结点在同一条分支上？？？    if(pRoot == null)        return null;    if(pathIsExisted(pRoot.left,node1)){        if(pathIsExisted(pRoot.right,node2)) {            return pRoot;        }else//两个结点都在左子树中继续向下递归            return findCommonAncestor1(pRoot.left,node1,node2);    }else {        if(pathIsExisted(pRoot.left,node2))            return pRoot;        else//两个结点都在右子树中继续向下递归            return findCommonAncestor1(pRoot.right,node1,node2);    }}//判断路径中是否存在指定结点的值public boolean pathIsExisted(BinaryTreeNode pRoot,int node){    if(pRoot == null)        return false;    if(pRoot.data == node)        return true;    boolean flag = pathIsExisted(pRoot.left,node);    //如果找到了就不用继续递归了    if(!flag){        flag = pathIsExisted(pRoot.right,node);    }    return flag;}//树为普通二叉树非递归解法public BinaryTreeNode findCommonAncestor2(BinaryTreeNode pRoot,int node1,int node2){    //list1和list2保存根节点到目标结点的路径    List&lt;BinaryTreeNode&gt; list1 = new ArrayList&lt;BinaryTreeNode&gt;();    boolean path1 = findPath(pRoot,node1,list1);    List&lt;BinaryTreeNode&gt; list2 = new ArrayList&lt;BinaryTreeNode&gt;();    boolean path2 = findPath(pRoot,node2,list2);    BinaryTreeNode ancestor = null;    Iterator list1Iterator = list1.iterator();    Iterator list2Iterator = list2.iterator();    int diffIndex = -1;//默认没有出现两个不同的节点    int i = 0;    //找到两条路径岔开的那个位置结点，那么前一个结点就是最后一个公共路径上的结点，也就是最近的祖先    if(path1 &amp;&amp; path2){        while (list1Iterator.hasNext() &amp;&amp; list2Iterator.hasNext()){            if(list1Iterator.next() != list2Iterator.next()){                diffIndex = --i;                break;            }            i++;        }    }    if(diffIndex &gt;= 0)        ancestor = list1.get(diffIndex);    //diffIndex = -1 表示node1和node2在同一条路径上    return ancestor;}//保存包含指定节点路径结点的方法public boolean findPath(BinaryTreeNode pRoot, int node, List&lt;BinaryTreeNode&gt; list){    if(pRoot ==  null)        return false;    list.add(pRoot);    if(pRoot.data == node)        return true;    boolean isExisted = findPath(pRoot.left,node,list);    if(!isExisted){        isExisted = findPath(pRoot.right,node,list);    }    if(!isExisted)        list.remove(list.size()-1);    return isExisted;}public static void main(String[] args){    BinaryTree tree = new BinaryTree();    tree.createBinaryTree(tree.getRoot(),8);    tree.createBinaryTree(tree.getRoot(),3);    tree.createBinaryTree(tree.getRoot(),2);    tree.createBinaryTree(tree.getRoot(),5);    tree.createBinaryTree(tree.getRoot(),1);    tree.createBinaryTree(tree.getRoot(),12);    tree.createBinaryTree(tree.getRoot(),9);    CommonAncestor test = new CommonAncestor();    System.out.println(test.findCommonAncestor1(tree.getRoot(),3,2).data);}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;两个结点的最近祖先？&quot;&gt;&lt;a href=&quot;#两个结点的最近祖先？&quot; class=&quot;headerlink&quot; title=&quot;两个结点的最近祖先？&quot;&gt;&lt;/a&gt;两个结点的最近祖先？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public class CommonAncestor {

      
    
    </summary>
    
      <category term="树" scheme="http://www.xuchunfa.cn/categories/%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>丑数</title>
    <link href="http://www.xuchunfa.cn/2018/09/03/%E4%B8%91%E6%95%B0/"/>
    <id>http://www.xuchunfa.cn/2018/09/03/丑数/</id>
    <published>2018-09-03T02:30:46.000Z</published>
    <updated>2018-09-03T02:33:02.339Z</updated>
    
    <content type="html"><![CDATA[<h4 id="求解指定索引的丑数？"><a href="#求解指定索引的丑数？" class="headerlink" title="求解指定索引的丑数？"></a>求解指定索引的丑数？</h4><pre><code>public class UglyNumber {public static int resolve(int index){    if(index &lt;= 0){        throw new RuntimeException(&quot;参数非法&quot;);    }    int[] uglyNumber = new int[index];    uglyNumber[0] = 1;    int indexOf2,indexOf3,indexOf5;    indexOf2 = indexOf3 = indexOf5 = 0;    int uglyNumberIndex = 1;    while (uglyNumberIndex &lt; index){        int min = Min(uglyNumber[indexOf2]*2,uglyNumber[indexOf3]*3,uglyNumber[indexOf5]*5);        uglyNumber[uglyNumberIndex] = min;        //uglyNumber[uglyNumberIndex]代表的是目前数组中最大的丑数        while (uglyNumber[indexOf2]*2 &lt;= uglyNumber[uglyNumberIndex]){            indexOf2++;        }        //下次的uglyNumber[indexOf3]肯定就大于Max uglyNumber        while (uglyNumber[indexOf3]*3 &lt;= uglyNumber[uglyNumberIndex]){            indexOf3++;        }        while (uglyNumber[indexOf5]*5 &lt;= uglyNumber[uglyNumberIndex]){            indexOf5++;        }        uglyNumberIndex++;    }    return uglyNumber[index-1];}private static int Min(int i, int j, int k) {    int min;    return (min = i &lt; j ? i : j) &lt; k ? min : k;}public static void main(String[] args){    System.out.println(UglyNumber.resolve(100));}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;求解指定索引的丑数？&quot;&gt;&lt;a href=&quot;#求解指定索引的丑数？&quot; class=&quot;headerlink&quot; title=&quot;求解指定索引的丑数？&quot;&gt;&lt;/a&gt;求解指定索引的丑数？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public class UglyNumber {

pub
      
    
    </summary>
    
      <category term="策略类" scheme="http://www.xuchunfa.cn/categories/%E7%AD%96%E7%95%A5%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>逆序对的个数</title>
    <link href="http://www.xuchunfa.cn/2018/09/03/%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://www.xuchunfa.cn/2018/09/03/逆序对的个数/</id>
    <published>2018-09-03T02:28:22.000Z</published>
    <updated>2018-09-03T02:30:34.090Z</updated>
    
    <content type="html"><![CDATA[<h4 id="逆序对的个数？"><a href="#逆序对的个数？" class="headerlink" title="逆序对的个数？"></a>逆序对的个数？</h4><pre><code>public class InversePairNum {private int count = 0;private int[] temp;//保存排好序的中间结果，再将结果拷贝到原数组public int resolve(int[] num,int length){    temp = new int[length];    divideSort(num,0,length-1);    return count;}private void divideSort(int[] num, int left, int right) {    if(left &lt; right){        int mid = (left + right)/2;        //分成一个一个元素        divideSort(num,left,mid);        divideSort(num,mid+1,right);        mergeSort(num,left,mid,right);    }}private void mergeSort(int[] num, int left, int mid, int right) {    int leftEnd = mid;    int rightEnd = right;    int tempIndex = right;    //指针从后往前移    while (leftEnd &gt;= left &amp;&amp; rightEnd &gt;= mid + 1) {        if (num[leftEnd] &gt; num[rightEnd]) {            temp[tempIndex--] = num[leftEnd--];            //不是 right - mid 右边的指针是往前挪的            count += rightEnd - mid;        } else {            temp[tempIndex--] = num[rightEnd--];        }    }    //剩余元素    while (leftEnd &gt;= left) {        temp[tempIndex--] = num[leftEnd--];    }    while (rightEnd &gt;= mid + 1) {        temp[tempIndex--] = num[rightEnd--];    }    //利用临时数组temp来使得num数组左右两边都是有序的(递增的)    for (int i = left; i &lt;= right; i++) {        num[i] = temp[i];    }}public static void main(String[] args){    InversePairNum test = new InversePairNum();    int[] num = {4,6,3,1,5,7,2};    System.out.println(test.resolve(num,num.length));}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;逆序对的个数？&quot;&gt;&lt;a href=&quot;#逆序对的个数？&quot; class=&quot;headerlink&quot; title=&quot;逆序对的个数？&quot;&gt;&lt;/a&gt;逆序对的个数？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public class InversePairNum {

private int
      
    
    </summary>
    
      <category term="数组" scheme="http://www.xuchunfa.cn/categories/%E6%95%B0%E7%BB%84/"/>
    
    
  </entry>
  
  <entry>
    <title>Java笔记</title>
    <link href="http://www.xuchunfa.cn/2018/09/02/EffectiveJava%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.xuchunfa.cn/2018/09/02/EffectiveJava笔记/</id>
    <published>2018-09-02T07:34:14.000Z</published>
    <updated>2018-09-06T11:51:08.040Z</updated>
    
    <content type="html"><![CDATA[<p>1.有时可以用静态工厂方法来代替构造器。</p><p>2.带有私有构造函数的类不能被继承。</p><p>3.如果把那些不会修改的对象放在方法里面的话，要是频繁调用这个方法就会每次创建多余的对象,一种好的方法是在 static{…….} 代码块中初始化这些对象。</p><p>4.如果创建对象的代价非常高，那么此时可以创建对象池，目的是为了重用对象，通常情况下重用对象付出的代价要高于创建对象付出的代价。</p><p>5.为什么静态方法只能访问静态域？</p><pre><code>静态域是属于类的，程序在进行编译的时候就会加载到虚拟机内存的方法区，直到程序退出都会一直存在，而非静态域是和对象挂钩的，需要 new 一个对象，实例域才会在堆中分配内存，对象都还没有怎么能访问非静态域呢？</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.有时可以用静态工厂方法来代替构造器。&lt;/p&gt;
&lt;p&gt;2.带有私有构造函数的类不能被继承。&lt;/p&gt;
&lt;p&gt;3.如果把那些不会修改的对象放在方法里面的话，要是频繁调用这个方法就会每次创建多余的对象,一种好的方法是在 static{…….} 代码块中初始化这些对象。&lt;/p&gt;

      
    
    </summary>
    
      <category term="java语言基础" scheme="http://www.xuchunfa.cn/categories/java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Lock详解</title>
    <link href="http://www.xuchunfa.cn/2018/08/30/Lock%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.xuchunfa.cn/2018/08/30/Lock详解/</id>
    <published>2018-08-30T01:19:08.000Z</published>
    <updated>2018-08-31T09:14:28.144Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Lock接口</p></blockquote><p>1.lock()：获取锁。</p><p>2.lockInterruptibly():可中断的获取锁，不同于lock(),在锁的获取中可以中断当前线程。</p><p>3.tryLock()：尝试非阻塞的获取锁。</p><p>4.tryLock(long time, TimeUnit unit)：超时获取锁。</p><p>5.unlock()：释放锁。</p><p>6.newCondition()：获取等待通知组件。</p><h4 id="为什么锁的实现中使用组合同步器而不选择继承呢？"><a href="#为什么锁的实现中使用组合同步器而不选择继承呢？" class="headerlink" title="为什么锁的实现中使用组合同步器而不选择继承呢？"></a>为什么锁的实现中使用组合同步器而不选择继承呢？</h4><blockquote><p>队列同步器</p></blockquote><p>1.同步器是实现锁的关键。锁是面象用户的,用户不需要了解其中的底层原理，同步器是面象锁的,是关于锁实现的原理细节。</p><p>2.队列同步器的实现</p><p>独占式同步状态流程图如下：</p><pre><code>//tryAcquire(arg) == false 则获取同步状态失败，线程进入同步队列public final void acquire(int arg) {    if (!tryAcquire(arg) &amp;&amp;        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))        selfInterrupt();}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Lock接口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.lock()：获取锁。&lt;/p&gt;
&lt;p&gt;2.lockInterruptibly():可中断的获取锁，不同于lock(),在锁的获取中可以中断当前线程。&lt;/p&gt;
&lt;p&gt;3.tryLock()：
      
    
    </summary>
    
      <category term="Java并发编程" scheme="http://www.xuchunfa.cn/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>单例模式的不同写法</title>
    <link href="http://www.xuchunfa.cn/2018/08/28/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%8D%E5%90%8C%E5%86%99%E6%B3%95/"/>
    <id>http://www.xuchunfa.cn/2018/08/28/单例模式的不同写法/</id>
    <published>2018-08-28T08:41:34.000Z</published>
    <updated>2018-09-06T13:39:11.012Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>饿汉模式（在调用对象之前就已经初始化了）</p><p>  1.基于类加载的机制（是线程安全的！！！）</p><p>  public class Singleton {</p><p>  private static final Singleton INSTANCE = new Singleton();</p><p>  private Singleton(){}</p><p>  public static Singleton getInstance(){</p><pre><code>return INSTANCE;</code></pre><p>  }<br>  }</p></li></ul><p>这里加final的意思这么理解：</p><p>final关键字可以禁止指令重排，防止在 INSTANCE 还没完全赋值的情况下被使用.</p><p>为什么线程安全参考静态内部单例模式。</p><ul><li><p>懒汉模式（线程不安全）</p><pre><code>   public class Singleton {    private static Singleton instance;    private Singleton (){  }     public static Singleton getInstance() {    if (instance == null) {            instance = new Singleton();    }    return instance;    }  }  </code></pre></li></ul><p>这里为什么不能加final:</p><p>1.因为final static 域必须要（直接赋值）或者（通过静态代码块）来赋值，这样就直接初始化了，没有做到延迟初始化。</p><p>2.如果你是final非static成员，必须在构造器、代码块、或者直接定义赋值；</p><ul><li><p>懒汉模式（线程安全）</p><p>  1.同步开销大,效率不高。</p></li></ul><ul><li><p>双重检查模式（DCL）</p><p>  1.还是会在某些情况下出现DCL失效的情况。</p></li></ul><ul><li><p>静态内部单例模式</p><pre><code>public class Singleton { private Singleton(){    }  public static Singleton getInstance(){      return SingletonHolder.sInstance;  }  private static class SingletonHolder {      private static final Singleton sInstance = new Singleton();  }  }</code></pre></li></ul><hr><p>1.第一次加载Singleton类不会实例化对象,只有在调用getInstance()方法时才会引起SingletonHolder类加载的理解？？？</p><p>1.1 外部类 Singleton 加载的时候静态内部类 SingletonHolder 不会加载，内部类的加载不需要依附外部类，在使用时才会加载。所以当调用内部类 SingletonHolder 的静态域 sInstance 才会引起内部类的加载以及初始化。</p><p>1.2 不过当只调用外部类的静态变量，静态方法时，是不会让静态内部类的被加载。</p><p><strong>2.为什么是线程安全的？？？</strong></p><p>2.1 首先解释一下<clinit>()方法中包含类中的所有类（static）变量的赋值动作和静态语句块。</clinit></p><p>2.2 虚拟机会保证一个类的类构造器<clinit>()在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的类构造器<clinit>()，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。</clinit></clinit></clinit></p><p>特别需要注意的是，在这种情形下，其他线程虽然会被阻塞，但如果执行<clinit>()方法的那条线程退出后，其他线程在唤醒之后不会再次进入/执行<clinit>()方法，因为 在同一个类加载器下，一个类型只会被初始化一次。如果在一个类的<clinit>()方法中有耗时很长的操作，就可能造成多个线程阻塞，在实际应用中这种阻塞往往是隐藏的.</clinit></clinit></clinit></p><pre><code>一句话概括：java虚拟机保证在多线程的环境下类能够被正确加载。</code></pre><ul><li><p>枚举单例模式</p><p>  public enum Singleton {</p><pre><code>INSTANCE;private Singleton() {}</code></pre><p>  }</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;饿汉模式（在调用对象之前就已经初始化了）&lt;/p&gt;
&lt;p&gt;  1.基于类加载的机制（是线程安全的！！！）&lt;/p&gt;
&lt;p&gt;  public class Singleton {&lt;/p&gt;
&lt;p&gt;  private static final Singleton IN
      
    
    </summary>
    
      <category term="Java设计模式" scheme="http://www.xuchunfa.cn/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>最长不含重复字符的子字符串</title>
    <link href="http://www.xuchunfa.cn/2018/08/27/%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://www.xuchunfa.cn/2018/08/27/最长不含重复字符的子字符串/</id>
    <published>2018-08-27T08:34:48.000Z</published>
    <updated>2018-08-27T08:35:50.271Z</updated>
    
    <content type="html"><![CDATA[<h4 id="最长不含重复字符的子字符串？"><a href="#最长不含重复字符的子字符串？" class="headerlink" title="最长不含重复字符的子字符串？"></a>最长不含重复字符的子字符串？</h4><pre><code>public class MaxDistinctSubString {//返回字符串长度public static String resolve(String str,int length){    if(str == null || length &lt; 0){        throw new RuntimeException(&quot;参数非法&quot;);    }    int distance = 0;    int currentLen = 0;    int maxLen = 0;    StringBuffer sb = new StringBuffer();    //用来存放字符在字符串中的最近访问的index    int[] judgeExisted = new int[256];    for(int j = 0;j &lt; judgeExisted.length;j++){        judgeExisted[j] = -1;    }     int startIndex = 0;    for(int i = 0;i &lt; length;i++){        //所有字符0~255        int index =str.charAt(i);        //字符没出现过        if(judgeExisted[index] &lt; 0){            currentLen = currentLen + 1;        }else {            distance = i - judgeExisted[index];            if(distance &lt;= currentLen){//字符出现在子串的中间                currentLen = distance;            }else {//d &gt; currentLen                currentLen = currentLen + 1;            }        }        //更新出现字符的坐标        judgeExisted[index] = i;        if(currentLen &gt; maxLen){            maxLen = currentLen;            //如果出现了重复的字符的话,i会一直前进但maxLen不会变,所以满足条件时,startIndex已经跳过了出现重复的字符。            startIndex = i + 1 - maxLen;        }    }    return str.substring(startIndex,startIndex + maxLen);}public static void main(String[] args){    String str = &quot;arabcacfrg&quot;;    System.out.println(MaxDistinctSubString.resolve(str,str.length()));}</code></pre><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;最长不含重复字符的子字符串？&quot;&gt;&lt;a href=&quot;#最长不含重复字符的子字符串？&quot; class=&quot;headerlink&quot; title=&quot;最长不含重复字符的子字符串？&quot;&gt;&lt;/a&gt;最长不含重复字符的子字符串？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public class M
      
    
    </summary>
    
      <category term="动态规划" scheme="http://www.xuchunfa.cn/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>最大子数组</title>
    <link href="http://www.xuchunfa.cn/2018/08/27/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>http://www.xuchunfa.cn/2018/08/27/最大子数组/</id>
    <published>2018-08-27T08:30:36.000Z</published>
    <updated>2018-08-27T08:33:04.475Z</updated>
    
    <content type="html"><![CDATA[<h4 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和?"></a>连续子数组的最大和?</h4><pre><code>public class MaxSubArraySum {public static int resolve(int[] array,int length){    if(array == null || length &lt; 0){        throw new RuntimeException(&quot;参数不合法&quot;);    }    int maxSub = 0;    int currentSum = 0;    //循环的思想解决动态规划问题    for(int i = 0;i&lt;length;i++){        //如果之前的和小于0的话,那么当前和应该从下一个数开始        if(currentSum &lt;= 0){            currentSum = array[i];        }else {            currentSum = currentSum + array[i];        }        //判断子数组的最大值        if(currentSum &gt; maxSub){            maxSub = currentSum;        }    }    return maxSub;}public static void main(String[] args){    int[] arr = {-1,2,3,-4,5,6,-7,9};    System.out.println(MaxSubArraySum.resolve(arr,arr.length));}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;连续子数组的最大和&quot;&gt;&lt;a href=&quot;#连续子数组的最大和&quot; class=&quot;headerlink&quot; title=&quot;连续子数组的最大和?&quot;&gt;&lt;/a&gt;连续子数组的最大和?&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public class MaxSubArraySum {

p
      
    
    </summary>
    
      <category term="动态规划" scheme="http://www.xuchunfa.cn/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>1到n的数组中和为m的所有组合</title>
    <link href="http://www.xuchunfa.cn/2018/08/26/1%E5%88%B0n%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%AD%E5%92%8C%E4%B8%BAm%E7%9A%84%E6%89%80%E6%9C%89%E7%BB%84%E5%90%88/"/>
    <id>http://www.xuchunfa.cn/2018/08/26/1到n的数组中和为m的所有组合/</id>
    <published>2018-08-26T13:18:06.000Z</published>
    <updated>2018-09-06T11:18:06.390Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1到n的数组中和为m的所有组合？"><a href="#1到n的数组中和为m的所有组合？" class="headerlink" title="1到n的数组中和为m的所有组合？"></a>1到n的数组中和为m的所有组合？</h4><pre><code>public class SumOfKnumber {public static void findKNumber(int sum, int n, int[] combine,int index){    //index 最大取到 n    if(index &gt; n || index &gt; sum)        return;    if(index == sum){        combine[index-1] = index;        printResult(combine);        //还可以作为其他组合的元素        combine[index-1] = 0;        return;    }    //选择i    combine[index-1] = index;    findKNumber(sum-index, n, combine, index+1);    //i被放弃    combine[index-1] = 0;    findKNumber(sum,n,combine,index+1);}private static void printResult(int[] combine) {    for(int i = 0;i &lt; combine.length;i++){        if(combine[i] != 0){            System.out.print(combine[i] + &quot; &quot;);        }    }    System.out.println();}public static void main(String[] args){    int[] combine = new int[7];    SumOfKnumber.findKNumber(10,7,combine,1);}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1到n的数组中和为m的所有组合？&quot;&gt;&lt;a href=&quot;#1到n的数组中和为m的所有组合？&quot; class=&quot;headerlink&quot; title=&quot;1到n的数组中和为m的所有组合？&quot;&gt;&lt;/a&gt;1到n的数组中和为m的所有组合？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public
      
    
    </summary>
    
      <category term="动态规划" scheme="http://www.xuchunfa.cn/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>字符串匹配算法</title>
    <link href="http://www.xuchunfa.cn/2018/08/25/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/"/>
    <id>http://www.xuchunfa.cn/2018/08/25/字符串匹配算法/</id>
    <published>2018-08-25T10:26:54.000Z</published>
    <updated>2018-08-25T10:27:47.880Z</updated>
    
    <content type="html"><![CDATA[<ul><li>KMP算法</li></ul><ul><li>BM算法</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;KMP算法&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;BM算法&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
      <category term="字符串" scheme="http://www.xuchunfa.cn/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>虚拟机字节码执行引擎</title>
    <link href="http://www.xuchunfa.cn/2018/08/24/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
    <id>http://www.xuchunfa.cn/2018/08/24/虚拟机字节码执行引擎/</id>
    <published>2018-08-24T12:48:13.000Z</published>
    <updated>2018-08-28T03:52:34.489Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>栈帧</p></blockquote><ul><li><p>局部变量表</p><p>  1.一个局部变量定义了但没有赋初值是不可以使用的.</p></li><li><p>操作数栈</p></li><li><p>动态连接</p></li><li><p>方法返回地址</p><p>  1.方法退出等效于当前栈帧出栈.如返回果有值的话,则将返回值压入调用者栈帧的操作数栈中.</p></li><li><p>附加信息</p></li></ul><p>其中动态连接,方法返回地址,附加信息统称为<strong>栈帧信息</strong>.</p><blockquote><p>方法调用</p></blockquote><p>一切方法调用在Class文件里面存储的都是符号引用,不是方法在实际运行时内存布局中的入口地址.</p><ul><li><p>解析</p><pre><code>方法在程序真正运行之前就有一个可确定的调用版本, 并且这个方法的调用版本在运行期间不可改变.符合以上条件的方法:1.静态方法2.私有方法3.实例构造器4.父类方法它们在类加载的时候就会把符号引用解析成直接引用.</code></pre></li></ul><ul><li>分派</li></ul><p>1.静态分派(方法重载)</p><p>1.1 java语言中的返回值不参与重载选择。</p><p>重载：“编译期绑定”，也叫编译期多态。方法重载主要是类内部多态性的一个体现。 </p><p>例如:</p><pre><code>public class O{static class A{}static class B extends A{}static class C extends A{}public void a(A a){    System.out.println(&quot;A method&quot;);}public void a(B b){    System.out.println(&quot;B method&quot;);}public void a(C c){    System.out.println(&quot;C method&quot;);}public static void main(String[] args){    O o = new O();    A b = new B();    A c = new C();    o.a(b);    o.a(c);}}</code></pre><p>上述代码的结果:</p><p>A method</p><p>A method</p><p><strong>虚拟机在重载时是通过参数的静态类型而不是实际类型作为判断依据.</strong></p><p>2.动态分派（方法重写）</p><p>重写：“运行期绑定”，也叫运行期多态。方法重写是父类与子类之间多态性的体现。</p><pre><code>在运行期间根据实际类型确定方法执行版本的分派。</code></pre><p>例如：</p><pre><code>class Dog{public void bark(){    System.out.println(&quot;woof &quot;);}}class Hound extends Dog{public void sniff(){    System.out.println(&quot;sniff &quot;);}public void bark(){    System.out.println(&quot;bowl&quot;);}}public class OverridingTest{public static void main(String [] args){    Dog dog = new Hound();    dog.bark();}}    </code></pre><p>输出：bowl</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;栈帧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;局部变量表&lt;/p&gt;
&lt;p&gt;  1.一个局部变量定义了但没有赋初值是不可以使用的.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;操作数栈&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态连接&lt;/p&gt;
&lt;/
      
    
    </summary>
    
      <category term="java虚拟机" scheme="http://www.xuchunfa.cn/categories/java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>数组中和为m的所有组合</title>
    <link href="http://www.xuchunfa.cn/2018/08/24/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%92%8C%E4%B8%BAm%E7%9A%84%E6%89%80%E6%9C%89%E7%BB%84%E5%90%88/"/>
    <id>http://www.xuchunfa.cn/2018/08/24/数组中和为m的所有组合/</id>
    <published>2018-08-24T10:09:40.000Z</published>
    <updated>2018-09-09T08:50:42.720Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="动态规划" scheme="http://www.xuchunfa.cn/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>随机版本的快排</title>
    <link href="http://www.xuchunfa.cn/2018/08/24/%E9%9A%8F%E6%9C%BA%E7%89%88%E6%9C%AC%E7%9A%84%E5%BF%AB%E6%8E%92/"/>
    <id>http://www.xuchunfa.cn/2018/08/24/随机版本的快排/</id>
    <published>2018-08-24T04:24:16.000Z</published>
    <updated>2018-08-24T04:25:37.975Z</updated>
    
    <content type="html"><![CDATA[<pre><code>public class QuickSort {public static void swap(int[] a,int i,int j){    int temp;    temp = a[i];    a[i] = a[j];    a[j] = temp;}public static int partition(int[] a,int start,int end){    if(a == null || start &lt; 0 || end &gt; a.length-1){        throw new RuntimeException(&quot;参数不合法&quot;);    }    //轴值在[start,end]区间内随机生成,然后把轴值交换到数组中第一位    rand_pivot(a,start,end);    int i = start;    int j = end;    int pivot = a[start];    while (i &lt; j){        while (i &lt; j &amp;&amp; a[j] &gt;= pivot){            j--;        }        //a[i] = a[j];//这种写法时条件不能为a[j] &gt; pivot必须要 &gt;=        swap(a,i,j);        while (i &lt; j &amp;&amp; a[i] &lt;= pivot){            i++;        }        //a[j] = a[i];        swap(a,j,i);    }    //a[i] 或者 a[j]    //a[i] = pivot;    return i;}//随机化的选择主元private static void rand_pivot(int[] a, int start, int end) {    Random random = new Random();    int rand = start + random.nextInt(end - start + 1);//随机函数生成的整数区间在[0,length)    //交换第一个数和随机选出来的数    int temp = a[start];    a[start] = a[rand];    a[rand] = temp;}public static void quickSort(int[] a,int start,int end){    if(start &gt;= end)        return;    int index = partition(a,start,end);    quickSort(a,start,index-1);    quickSort(a,index+1,end);    /*int index;    if(start &lt; end){        index = partition(a,start,end);        quickSort(a,start,index-1);        quickSort(a,index+1,end);    }*/}public static void main(String[] args){    int[] a = {2,4,5,1,1,2,7,6,3};    QuickSort.quickSort(a,0,a.length-1);    System.out.println(Arrays.toString(a));}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;public class QuickSort {

public static void swap(int[] a,int i,int j){
    int temp;
    temp = a[i];
    a[i] = a[j];
    a[j] 
      
    
    </summary>
    
      <category term="排序" scheme="http://www.xuchunfa.cn/categories/%E6%8E%92%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>java动态绑定</title>
    <link href="http://www.xuchunfa.cn/2018/08/23/java%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/"/>
    <id>http://www.xuchunfa.cn/2018/08/23/java动态绑定/</id>
    <published>2018-08-23T07:04:48.000Z</published>
    <updated>2018-08-24T13:52:44.349Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>动态绑定(后期绑定)和前期绑定？</p></blockquote><p>1.普通的方法我们看new后面的是什么类型；(后期绑定)</p><p>2.域和静态方法我们看=前面声明的是什么类型。 (前期绑定)</p><p>3.final，static，private和构造方法是前期绑定的。</p><p>4.运行时（动态）绑定针对的范畴只是对象的（普通）方法。</p><pre><code>public class Father {protected String name = &quot;父亲属性&quot;;}public class Son extends Father {    protected String name = &quot;儿子属性&quot;;    public static void main(String[] args) {        Father sample = new Son();        System.out.println(&quot;调用的属性：&quot; + sample.name);}}</code></pre><p>上述代码的运行结果: <strong>父亲属性</strong></p><pre><code>public class Father {protected String name = &quot;父亲属性&quot;;public String getName() {    return name;}}　　public class Son extends Father {protected String name = &quot;儿子属性&quot;;public String getName() {    return name;}public static void main(String[] args) {    Father sample = new Son();    System.out.println(&quot;调用的属性:&quot; + sample.getName());}}</code></pre><p>上述代码的运行结果: <strong>儿子属性</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;动态绑定(后期绑定)和前期绑定？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.普通的方法我们看new后面的是什么类型；(后期绑定)&lt;/p&gt;
&lt;p&gt;2.域和静态方法我们看=前面声明的是什么类型。 (前期绑定)&lt;/p&gt;
&lt;p&gt;3.final，stat
      
    
    </summary>
    
      <category term="java基础" scheme="http://www.xuchunfa.cn/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>关于TopK问题的详解</title>
    <link href="http://www.xuchunfa.cn/2018/08/21/%E5%85%B3%E4%BA%8ETopK%E9%97%AE%E9%A2%98%E7%9A%84%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.xuchunfa.cn/2018/08/21/关于TopK问题的详解/</id>
    <published>2018-08-21T07:21:19.000Z</published>
    <updated>2018-08-24T06:42:24.011Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在O(N)时间内寻找最大(或最小)的K个数？</p></blockquote><ul><li>Random Select:</li></ul><p>本质上是求第K大或第K小的那个数。</p><pre><code>1.如果是求最小的K个数，则找到坐标为 k-1 的Pivot.左边放是比pivot小的值，右边比pivot大。2.如果是求最大的K个数，则找到坐标为 k-1 的Pivot.左边放是比pivot大的值，右边比pivot小。</code></pre><p>如果数组中整数的取值范围不大的话，可以用哈希表的方法解决。</p><p>思路：用一个计数数组来记录每个数字出现的次数。</p><pre><code>时间复杂度：0(n + MAXN)for(sumCount = 0, v = MAXN-1; v &gt;= 0; v--){    sumCount += count[v];    if(sumCount &gt;= K)        break;}return v;</code></pre><ul><li>堆排序解决</li></ul><p>例如：2亿个整数中求最大的100万之和？</p><p>思路：</p><ol><li>首先建立一个容量为100万（Top K）的int数组，从文件读取整数填充。</li><li>利用堆维护该100万条记录（确保堆顶元素为最小值）</li><li>从文件中读取一个整数与堆顶元素比较，如果大于堆顶元素则替换该元素，并调整堆的结构。</li><li>重复步骤3一直到数据读取完</li><li>将数组中的元素全部相加，得到结果</li></ol><p>代码如下：</p><pre><code>public class TopKProblem {//时间复杂度:(n-K)*logK 空间复杂度:O(K)public static int[] createKtopHeap(int[] num,int k){    int length = num.length;    int i = 0;    //通过堆维护Topk元素    int[] KNumberHeap = new int[k];    if(k &gt;= length){        k = length;        return num;    }    //初始化有k个元素的堆    for(; i &lt; k; i++){        KNumberHeap[i] = num[i];    }    //构建小顶堆    for(int j = KNumberHeap.length/2-1;j &gt;= 0;j--){        createMinHeap(KNumberHeap,j,KNumberHeap.length);    }    //从第k+1个元素开始循环,每次都与堆顶元素(K个元素中的最小值)比较,大于就替代然后再调整.    for(;i &lt; length;i++){        if(num[i] &gt; KNumberHeap[0]){            KNumberHeap[0] = num[i];            createMinHeap(KNumberHeap,0,KNumberHeap.length);        }    }    return KNumberHeap;}private static void createMinHeap(int[] a, int i , int len) {    int father = a[i];    int j;//j代表子结点坐标 i代表父结点坐标    while(2*i + 1 &lt; len){//如果i结点在堆顶上的话,需要自顶向下调整        j = 2*i + 1;        if(j + 1 &lt; len &amp;&amp; a[j] &gt; a[j+1] )            j++;        if(a[j] &lt; father){            a[i] = a[j];            i = j;        }else {//不用调整的话就不用再向下循环了,子节点都已经调整好了            break;        }    }    //找到最终位置    a[i] = father;}public static void main(String[] args){    Random random = new Random();    int[] num = new int[15];    for(int i = 0;i &lt; num.length;i++){        num[i] = random.nextInt(50);    }    System.out.println(Arrays.toString(num));    System.out.println(Arrays.toString(createKtopHeap(num,5)));}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在O(N)时间内寻找最大(或最小)的K个数？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Random Select:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本质上是求第K大或第K小的那个数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.如果是求最小的K个数
      
    
    </summary>
    
      <category term="数组" scheme="http://www.xuchunfa.cn/categories/%E6%95%B0%E7%BB%84/"/>
    
    
  </entry>
  
</feed>
